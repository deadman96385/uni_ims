/*
 * THIS IS AN UNPUBLISHED WORK CONTAINING D2 TECHNOLOGIES, INC. CONFIDENTIAL AND
 * PROPRIETARY INFORMATION.  IF PUBLICATION OCCURS, THE FOLLOWING NOTICE
 * APPLIES: "COPYRIGHT 2005-2008 D2 TECHNOLOGIES, INC. ALL RIGHTS RESERVED"
 *
 * $D2Tech$ $Rev: 28422 $ $Date: 2014-08-22 11:55:05 +0800 (Fri, 22 Aug 2014) $
 *
 */

#include <osal.h>
#include <_vtspr_rtcp.h>
 
/*
 * ======== _VTSPR_rtcpSetCname() ========
 *
 * This routine sets CNAME on the specificed interface to the given name.
 */
void _VTSPR_rtcpSetCname(
    VTSPR_NetObj *net_ptr,
    vint          infc,
    const char   *name_ptr)
{
     _VTSPR_RtcpCname *cname_ptr;
    uint32             temp32;
    char              *dst_ptr;
    char              *src_ptr;
    char              *len_ptr;
    uvint              loop;
    vint               pktLen;

    cname_ptr = &(net_ptr->rtcpCname[infc]);

    dst_ptr = (char *)&(cname_ptr->cname[2]);
    *(dst_ptr++) = _VTSP_RTCP_SDES_TYPE_CNAME;
    len_ptr = dst_ptr++;
    src_ptr = (char *)name_ptr;

    for (loop = 0; loop < _VTSP_RTCP_CNAME_SZ * sizeof(uint32); loop++) {
        if (0 == *src_ptr) {
            break;
        }
        *(dst_ptr++) = *(src_ptr++);
    }
    *len_ptr = loop;
    
    switch (loop & 0x3) {
        case 0:
            *(dst_ptr++) = 0;
            *(dst_ptr++) = 0;
            loop += 4;
            break;
        case 1:
            *(dst_ptr++) = 0;
            loop += 3;
            break;
        case 2:
            *(dst_ptr++) = 0;
            *(dst_ptr++) = 0;
            *(dst_ptr++) = 0;
            *(dst_ptr++) = 0;
            loop += 6;
            break;
        case 3:
            *(dst_ptr++) = 0;
            *(dst_ptr++) = 0;
            *(dst_ptr++) = 0;
            loop += 5;
            break;
    }
    pktLen = (loop >> 2) + 1;

    temp32  = ((uint32)0x81 << 24) | (_VTSP_RTCP_PTYPE_SDES << 16) | (pktLen);
    cname_ptr->cname[0] = OSAL_netHtonl(temp32);
    cname_ptr->cname[1] = 0;
    cname_ptr->length = pktLen + 1;
}

/*
 * ======== _VTSPR_rtcpSetControl() ========
 *
 * Configure the RTCP control param sent vfrom  
 * VTSP_config() 
 */
void _VTSPR_rtcpSetControl(
    _VTSPR_RtcpObject *rtcp_ptr,
    uvint              control,
    uvint              val)
{
    switch (control) {
        case VTSP_TEMPL_CONTROL_RTCP_INTERVAL:
            /* 10ms unit */
            rtcp_ptr->sendCountFixed = val;
            break;
        case VTSP_TEMPL_CONTROL_RTCP_MASK:
            rtcp_ptr->enableMask = val;
            break;

        case VTSP_TEMPL_CONTROL_RTCP_TOS:
            rtcp_ptr->tos = val;
            break;
    }
}

/*
 * ======== _VTSPR_rtcpNextInterval() ========
 *
 * This function computes the next timeout that forces an SR or RR to be sent.
 * If Fixed interval is set, it resets the timeout to the fixed value.
 */
vint _VTSPR_rtcpNextInterval(
    _VTSPR_RtcpObject *rtcp_ptr)
{
    vint   nextCount;
    uint32 xSeed;
    uint32 ySeed;
    uint32 acc;
    int32 result;
    vint   loop;

    if (0 != rtcp_ptr->sendCountFixed) {
        rtcp_ptr->sendCount = rtcp_ptr->sendCountFixed;
        return (_VTSPR_RTP_OK);
    }

    /*
     * Initialize the seeds.  The first time this function is called after the
     * RTCP session has commenced, the sendCount was initialized to zero.
     */

    if (0 == rtcp_ptr->sendCount) {
        rtcp_ptr->xSeed = 1;
        rtcp_ptr->ySeed = 2;
    }
    /*
     * Noise generator function.
     *   Random numbers are generated by concatenating two 16-bit 
     *   multiply-with-carry generators:
     *      x(n) = 36969 * x(n-1) + carry mod 2^16
     *      y(n) = 18000 * y(n-1) + carry mod 2^16
     *   The sequence of resulting x's has period the order of about 2^60.
     *   Random number generated has (1<<15) mean with 
     *     RAND_MAX = 65563
     *     RAND_MIN = 0
     */
    xSeed = rtcp_ptr->xSeed;
    ySeed = rtcp_ptr->ySeed;
    result = 0;
    for (loop = 0; loop < 4; loop++) {
        xSeed = (36969 * (xSeed & 0xFFFF)) + (xSeed >> 16);
        ySeed = (18000 * (ySeed & 0xFFFF)) + (ySeed >> 16);

        acc = (xSeed << 16);
        acc = acc + (ySeed & 0xFFFF);
        acc = acc >> 16;
        result += (int32)(acc - 0x8000);            

    }
    
    rtcp_ptr->xSeed = xSeed;
    rtcp_ptr->ySeed = ySeed;

    /*
     * sendCount is set to a random time between 2.5 and 7.5 seconds. The first
     * time through, half the value is used.
     *
     * The first time this function is called after the RTCP session has
     * commenced, the sendCount was initialized to zero. Set sendCount to a
     * random time between 1.25 and 3.75 seconds [125 - 375 intervals].
     *
     * After the first time, new sendCounts are based on the minimum interval (5
     * seconds). This is because our sessions are small (2 streams/session
     * maximum) and that using a fraction (5%) of the bandwidth for control
     * messages would require sending more often than the minimum.
     */
    nextCount = 500 + ((500 * result) >> 18);
    if (0 == rtcp_ptr->sendCount) {
        nextCount = nextCount >> 1;
    }

    /*
     * Multiply by compensation factor (2.71828 - 1.5)
     */
    rtcp_ptr->sendCount = (nextCount * 79841) >> 16;

    return (_VTSPR_RTP_OK);
}
