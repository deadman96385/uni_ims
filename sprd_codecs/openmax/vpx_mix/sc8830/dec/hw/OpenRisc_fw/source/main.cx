#include <stdio.h>
#include <ctype.h>

#include "sci_types.h"
#include "video_common.h"
#if defined(MPEG4_DEC)
#include "mp4dec_mode.h"
#elif defined(MPEG4_ENC)
#elif defined(H264_DEC)
#elif defined(REAL_DEC)
#else //JPEG
#include "jpegcodec_def.h"
#endif

#if defined(SIM_IN_WIN)

	//////////////////////////////////////////////////////////////////////////
	// Dump files for test vector and trace information
	//////////////////////////////////////////////////////////////////////////
	char *get_a_word(char *str, char *buff)
	{
		char *p = str;
		while(*p && isalpha(*p)) p++;
		memcpy(buff, str, p - str);
		buff[p - str] = 0;
		while(*p && !isalpha((*p))) p++;
		if (*p) return p;
		return NULL;
	}
	void process_special_trace_vector(char *str)
	{
		
	}

	uint32 process_trace_enable_param(char *str)
	{
		uint32 i, value, count;
		char buff[20];
		char param_str[][20] = {
			"vld", "isqt", "ipred",  "dbk", "mbc", "mca", "dct","mea", "vlc", "bsm", "fw","chit", "all"//weihu
		};
		
		count = sizeof(param_str) / 20;
		value = 0;
		do {
			str = get_a_word(str, buff);
			for (i = 0; i < count; i++) {
				if (_stricmp(buff, param_str[i]) == 0) {
					printf("\n %s tracing...", buff);
					if (i == (count - 1)) {
						value |= 0xFFFFFFFF;
						break;
					}
					value += (1 << i);
					break;
				}
			}
			process_special_trace_vector(buff);
		} while(str);
		return value;
	}

	uint32 process_vector_enable_param(char *str)
	{
		uint32 i, value, count;
		char buff[20];
		char param_str[][20] = {
			"vld", "isqt", "ipred",  "dbk", "mbc", "mca", "dct","mea", "vlc", "bsm", "fw","chit","all"//weihu
		};
		
		count = sizeof(param_str) / 20;
		value = 0;
		do {
			str = get_a_word(str, buff);
			for (i = 0; i < count; i++) {
				if (_stricmp(buff, param_str[i]) == 0) {
					printf("\n %s test_vector generation...", buff);
					if (i == (count - 1)) {
						value |= 0xFFFFFFFF;
						break;
					}
					value += (1 << i);
					break;
				}
			}
			process_special_trace_vector(buff);
		} while(str);
		return value;
	}
#endif //SIM_IN_WIN

//used for malloc
LOCAL uint8 *s_inter_mem_bfr_ptr;		
LOCAL uint8 *s_extra_mem_bfr_ptr;		
PUBLIC uint32 g_inter_malloced_size;
PUBLIC uint32 g_extra_malloced_size;

PUBLIC INPUT_PARA_T *g_input;
PUBLIC int32 g_stream_type;

FILE *	g_err_inf_fp;
uint8	g_err_inf[10000];
PUBLIC int32 g_uv_interleaved;

#if defined(SIM_IN_WIN) 
	#if defined(JPEG_ENC)||defined(MPEG4_ENC)
		FILE *s_pEnc_input_src_file;
		FILE *s_pEnc_output_bs_file;
		FILE *s_pEnc_output_recon_file;
	#endif
	#if defined(JPEG_DEC)|| defined(MPEG4_DEC)||defined(H264_DEC)||defined(REAL_DEC)
	    FILE *s_pDec_input_bs_file; //file pointer of H.264 bit stream
	    FILE *s_pDec_recon_yuv_file; //file pointer of reconstructed YUV sequence
		FILE *s_pDec_disp_yuv_file; //file pointer of display YUV sequence
		FILE *s_pEnc_output_recon_file;//file pointer of encoder resconstruted YUV sequence
	    FILE *s_pDec_debug_file;
	#endif //#if defined(JPEG_ENC)
#else 
    uint8 *ptrInbfr;
    int g_streamLen;

    uint8 *ptrOutBfr; // to store the decoded frame
    uint8 *g_pOutBfr;
#endif

LOCAL void InitInterMallocMemory(void)
{
#if defined(SIM_WITH_VSP)
	s_inter_mem_bfr_ptr = (uint8 *)(INTER_MALLOC_MEM_START_ADDR);	
#elif defined(SIM_NO_VSP)
	s_inter_mem_bfr_ptr = (uint8 *)malloc(TOTAL_INTER_MALLOC_SIZE);
#endif

	g_inter_malloced_size = 0;
}

LOCAL void InitExtraMallocMemory(void)
{
#if defined(SIM_WITH_VSP)
	s_extra_mem_bfr_ptr = (uint8 *)(EXTRA_MALLOC_MEM_START_ADDR);
	
#elif defined(SIM_NO_VSP)
	s_extra_mem_bfr_ptr = (uint8 *)malloc(TOTAL_EXTRA_MALLOC_SIZE);
#endif

	g_extra_malloced_size = 0;
}

LOCAL void FreeInterMallocMemory(void)
{
#if defined(SIM_NO_VSP)
	if(s_inter_mem_bfr_ptr)
	{
		free(s_inter_mem_bfr_ptr);
	}
#endif //defined(SIM_NO_VSP)

	g_inter_malloced_size = 0;
}

LOCAL void FreeExtraMallocMemory(void)
{
#if defined(SIM_NO_VSP)
	if(s_extra_mem_bfr_ptr)
	{
		free(s_extra_mem_bfr_ptr);
	}
#endif //defined(SIM_NO_VSP)

	g_extra_malloced_size = 0;
}

PUBLIC void *MallocInterMem(uint32 mem_size)
{
	uint8 *pMem = PNULL;

	mem_size = ((mem_size + 3) &(~3));

	if((0 == mem_size)||(mem_size> (TOTAL_INTER_MALLOC_SIZE-g_inter_malloced_size)))
	{
		SCI_ASSERT(0);
		return 0;
	}
	
	pMem = s_inter_mem_bfr_ptr + g_inter_malloced_size;
	g_inter_malloced_size += mem_size;
	
	return (void *)pMem;
}

PUBLIC void *MallocExtraMem(uint32 mem_size)
{
	uint8 *pMem = PNULL;

	mem_size = ((mem_size + 3) &(~3));

	if((0 == mem_size)||(mem_size> (TOTAL_EXTRA_MALLOC_SIZE-g_extra_malloced_size)))
	{
		SCI_ASSERT(0);
		return 0;
	}
	
	pMem = s_extra_mem_bfr_ptr + g_extra_malloced_size;
	g_extra_malloced_size += mem_size;
	
	return (void *)pMem;
}

PUBLIC void *ExtraMemAlloc_64WordAlign(uint32 mem_size)
{
	uint32 CurrAddr, _64WordAlignAddr;
		
	CurrAddr = (uint32)s_extra_mem_bfr_ptr + g_extra_malloced_size;

	_64WordAlignAddr = ((CurrAddr + 255) >>8)<<8;

	mem_size += (_64WordAlignAddr - CurrAddr);

	if((0 == mem_size)||(mem_size> (TOTAL_EXTRA_MALLOC_SIZE-g_extra_malloced_size)))
	{
		SCI_ASSERT(0);
		return 0;
	}
	
	g_extra_malloced_size += mem_size;
	
	return (void *)_64WordAlignAddr;
}

#if !defined(MPEG4_ENC)
LOCAL void init_conf(void)
{
	FILE *fd;
	char *p;
#if defined(MPEG4_ENC)
	char configure_file_path[200] = "..\\seq\\"; //"D:/SC8801H/code/Firmware_RTL_verification_Mp4Enc/mp4_encoder/simulation/vc/seq/";
#elif defined(MPEG4_DEC)
	char configure_file_path[200] = "..\\seq\\"; //"D:/SC8801H/code/Firmware_RTL_verification_Mp4Dec/mp4_decoder/simulation/vc/seq/";
#elif defined(JPEG_ENC)
	char configure_file_path[200] = "seq\\"; //"D:/SC8801H/code/Firmware_RTL_verification_Mp4Dec/jpeg_codec/simulation/VC/Enc_WinPrj/seq/";
#elif defined(JPEG_DEC)
	char configure_file_path[200] = "seq\\";
#elif defined(H264_DEC)
	char configure_file_path[200] = "..\\seq\\";
#elif defined(REAL_DEC)
	char configure_file_path[200] = ".\\";
#else
	assert(0);
#endif //

	g_input = (INPUT_PARA_T *)MallocExtraMem(sizeof(INPUT_PARA_T));

#if defined(SIM_IN_WIN)
	// read the configuration file
	#if defined(MPEG4_ENC)
		assert(NULL != (fd=fopen(strcat(configure_file_path, "mp4_encoder.cfg"),"r")));
	#elif defined(MPEG4_DEC)
		assert(NULL != (fd=fopen(strcat(configure_file_path, "mp4_decoder.cfg"),"r")));
	#elif defined(JPEG_DEC)
		assert(NULL != (fd=fopen(strcat(configure_file_path, "jpeg_decoder.cfg"),"r")));
	#elif defined(JPEG_ENC)
		assert(NULL != (fd=fopen(strcat(configure_file_path, "jpeg_encoder.cfg"),"r")));
	#elif defined(H264_DEC)
		assert(NULL != (fd=fopen(strcat(configure_file_path, "h264_decoder.cfg"),"r")));
	#elif defined(REAL_DEC)
		assert(NULL != (fd=fopen(strcat(configure_file_path, "rv_decoder.cfg"),"r")));
	#endif

	fscanf(fd,"%s",g_input->infile);                // input file, bitsream or yuv file
	fscanf(fd,"%*[^\n]");
		
	fscanf(fd,"%s",g_input->outfile);               // output file, yuv420 format or jpeg file
	fscanf(fd,"%*[^\n]");
	
	#if defined(JPEG_ENC)
		fscanf(fd,"%d",&(g_input->quality_level));      // jpeg encoder parameter, quality level
	#elif defined(JPEG_DEC)
		fscanf(fd,"%d",&(g_input->scaling_down_factor));// jpeg encoder parameter, quality level
	#else	
		fscanf(fd,"%s",g_input->reffile);               // reference file, yuv420 format
	#endif
	fscanf(fd,"%*[^\n]");
		
	fscanf(fd,"%s",g_input->streamType);				//H264, AVS, MPEG4, H263, VC-1, REAL, JPEG
	fscanf(fd,"%*[^\n]");
	
	fscanf(fd,"%s",g_input->AVS_Version);				//only for AVS, avs version, 52c,52j...
	fscanf(fd,"%*[^\n]");								//if other standard, this element will be ignored.

	fscanf(fd,"%s",g_input->trace_enable_flag);         //flag of module trace information 
	fscanf(fd,"%*[^\n]");
	
	fscanf(fd,"%s",g_input->vector_enable_flag);        //flag of module test vector
	fscanf(fd,"%*[^\n]");
		
	fscanf(fd,"%d",&(g_input->pic_width));				//only for encoder
	fscanf(fd,"%*[^\n]");							

	fscanf(fd,"%d",&(g_input->pic_height));				//only for encoder
	fscanf(fd,"%*[^\n]");							

	#if defined(JPEG_ENC)
		fscanf(fd,"%d",&(g_input->mcu_info));			// mcu infomation of jpeg encoder
	#elif defined(JPEG_DEC)
		fscanf(fd,"%d",&(g_input->is_output_yuv));      // output_rgb or not of jpeg encoder
	#else //MPEG4_DEC
		fscanf(fd,"%d",&(g_input->frame_num_dec));      // frame num to decode or encode
	#endif //
	fscanf(fd,"%*[^\n]");
	
	fclose (fd);
		
	p = g_input->streamType;
	if (!strcmp(p, "AVS")) {
		g_stream_type = STREAM_ID_AVS;
	}else if (!strcmp(p, "H264")) {
		g_stream_type = STREAM_ID_H264;
	}else if (!strcmp(p, "MPEG4")) {
		g_stream_type = STREAM_ID_MPEG4;
	}else if (!strcmp(p, "H263")) {
		g_stream_type = STREAM_ID_H263;
	}else if (!strcmp(p, "VC1")) {
		g_stream_type = STREAM_ID_VC1;
	}else if (!strcmp(p, "JPEG")) {
		g_stream_type = STREAM_ID_JPEG;
	}else if (!strcmp(p, "REAL8")) {
		g_stream_type = STREAM_ID_REAL8;
	}else if (!strcmp(p, "REAL9")) {
		g_stream_type = STREAM_ID_REAL9;
	}else {
		printf("unknow stream type: %s\n", p); 
	}

	g_trace_enable_flag = process_trace_enable_param(g_input->trace_enable_flag);
	//argv[7]
	g_vector_enable_flag = process_vector_enable_param(g_input->vector_enable_flag);

	//g_vector_enable_flag = 0; //now, we dont output any test vector. xiaoweiluo@20090519
		
	fprintf(stdout,"\n--------------------------------------------------------------------------\n");
	fprintf(stdout," Input %s bitstream	: %s \n", p, g_input->infile);
	fprintf(stdout," Output decoded YUV420	: %s \n",g_input->outfile);
#else //arm
	#if defined(MPEG4_DEC)||defined(MPEG4_ENC)
		g_stream_type = STREAM_ID_MPEG4;
	#elif defined(JPEG_DEC)||defined(JPEG_ENC)
		g_stream_type = STREAM_ID_JPEG;
	#endif

	g_input->frame_num_dec = 5;

	#if defined(MPEG4_ENC)
		g_input->pic_width = 352;
		g_input->pic_height = 288;
	#endif //
	
#endif // SIM_IN_WIN   
		
	FPRINTF(stdout,"--------------------------------------------------------------------------\n");
}
#else
extern int g_samp_rate;
LOCAL void init_conf(void)
{
	FILE *fd;
	
	g_input = (INPUT_PARA_T *)MallocExtraMem(sizeof(INPUT_PARA_T));

	assert(NULL != (fd=fopen("..\\seq\\mp4_encoder.cfg","r")));

	fscanf(fd,"%s", g_input->infile);                // input file, bitsream or yuv file
	fscanf(fd,"%*[^\n]");
		
	fscanf(fd,"%s", g_input->outfile);               // output file, yuv420 format
	fscanf(fd,"%*[^\n]");
	

	fscanf(fd,"%s", g_input->recfile);               // reference file, yuv420 format
	fscanf(fd,"%*[^\n]");

		
	fscanf(fd,"%d", &g_input->is_short_header);            
	fscanf(fd,"%*[^\n]");
		
	fscanf(fd,"%d", &(g_input->pic_width));			//only for encoder
	fscanf(fd,"%*[^\n]");							

	fscanf(fd,"%d", &(g_input->pic_height));			//only for encoder
	fscanf(fd,"%*[^\n]");							
			
	fscanf(fd,"%d", &(g_input->frame_num_enc));      // frame num to decode or encode
	fscanf(fd,"%*[^\n]");

	fscanf(fd,"%d", &(g_input->rc_ena));      // 
	fscanf(fd,"%*[^\n]");
		
	fscanf(fd,"%d", &(g_input->bit_rate));      // 
	fscanf(fd,"%*[^\n]");

	fscanf(fd,"%d", &(g_input->src_frm_rate));      // 
	fscanf(fd,"%*[^\n]");

	fscanf(fd,"%d", &(g_input->samp_rate));      // 
	fscanf(fd,"%*[^\n]");

	fscanf(fd,"%d", &(g_input->step_I));      // 
	fscanf(fd,"%*[^\n]");

	fscanf(fd,"%d", &(g_input->step_P));      // 
	fscanf(fd,"%*[^\n]");

	fclose (fd);
	
	g_samp_rate = g_input->samp_rate;	

	g_stream_type = STREAM_ID_MPEG4;


	fprintf(stdout,"\n--------------------------------------------------------------------------\n");
	fprintf(stdout," Input bitstream	: %s \n", g_input->infile);
	fprintf(stdout," Output decoded YUV420	: %s \n",g_input->outfile);
  	
	FPRINTF(stdout,"--------------------------------------------------------------------------\n");
}
#endif

LOCAL void paramet_set(void)
{
#if defined(SIM_IN_WIN)
	char tmp_file_path[200];
	#if defined(MPEG4_ENC)
		char file_path[200] = ""; //"D:/SC8801H/code/Firmware_RTL_verification_Mp4Dec/mp4_encoder/simulation/vc/winprj/";
	#elif defined(MPEG4_DEC)
		char file_path[200] = "";//"D:/SC8801H/code/Firmware_RTL_verification_Mp4Dec/mp4_decoder/simulation/vc/winprj/";
	#elif defined(JPEG_ENC)
		char file_path[200] = "";//"D:/SC8801H/code/Firmware_RTL_verification_Mp4Dec/jpeg_codec/simulation/VC/Enc_WinPrj/seq/";
	#elif defined(JPEG_DEC)
		char file_path[200] = "";//"D:/SC8801H/code/Firmware_RTL_verification_Mp4Dec/jpeg_codec/simulation/VC/Dec_WinPrj/seq/";
	#elif defined(H264_DEC)	
		char file_path[200] = "";
	#elif defined(REAL_DEC)	
		char file_path[200] = "";
	#else
		assert(0);
	#endif
	
	#if defined(JPEG_ENC)||defined(MPEG4_ENC)
		s_pEnc_input_src_file = fopen (g_input->infile, "rb");
		SCI_ASSERT (s_pEnc_input_src_file != NULL);
		
		strcpy(tmp_file_path, file_path);
		s_pEnc_output_bs_file = fopen (strcat(tmp_file_path, g_input->outfile), "wb");
		SCI_ASSERT (s_pEnc_output_bs_file != NULL);
		#if defined(MPEG4_ENC)
			strcpy(tmp_file_path, file_path);
			s_pEnc_output_recon_file = fopen (strcat(tmp_file_path, g_input->recfile), "wb");
			SCI_ASSERT (s_pEnc_output_recon_file != NULL);
		#endif
	#else
		s_pDec_input_bs_file = fopen (g_input->infile, "rb");
		SCI_ASSERT (s_pDec_input_bs_file != NULL);
		
		strcpy(tmp_file_path, file_path);
		#if defined(MPEG4_DEC)
			s_pDec_disp_yuv_file = fopen (strcat(tmp_file_path, g_input->outfile), "wb");
			SCI_ASSERT (s_pDec_disp_yuv_file != NULL);
			strcpy(tmp_file_path, file_path);
			s_pDec_recon_yuv_file = fopen (strcat(tmp_file_path, "test_dec.yuv"), "wb");
			SCI_ASSERT (s_pDec_recon_yuv_file != NULL);
			strcpy(tmp_file_path, file_path);
			s_pEnc_output_recon_file = fopen (strcat(tmp_file_path, "..\\seq\\enc_rec.yuv"), "rb");
			SCI_ASSERT (s_pEnc_output_recon_file != NULL);
		//	g_err_inf_fp   = fopen ("D:\\SC8801H\\code\\Firmware_vt\\linjiang\\AddNoise\\allI\\err_infor.txt", "rb");
			g_err_inf_fp   = fopen ("..\\seq\\err_infor.txt", "rb");
			fread (g_err_inf, 1, 10000, g_err_inf_fp);
		#elif defined(REAL_DEC)
			s_pDec_disp_yuv_file = fopen (strcat(tmp_file_path, g_input->outfile), "wb");
			SCI_ASSERT (s_pDec_disp_yuv_file != NULL);

		#else //H264
			s_pDec_recon_yuv_file = fopen (strcat(tmp_file_path, g_input->outfile), "wb");
			SCI_ASSERT (s_pDec_recon_yuv_file != NULL);
		#endif
		
	#endif //#if defined(JPEG_ENC)||defined(MPEG4_ENC)

		strcpy(tmp_file_path, file_path);
		SCI_ASSERT(NULL != (g_fp_trace_fw = fopen(strcat(tmp_file_path, "trace_fw.txt"),"w"))); 

#else //in arm

	#if defined(SIM_IN_ADS) //only when in arm and without VSP, should include videostream array data.
	{
		extern unsigned char videoStream[];

		ptrInbfr = videoStream;
		g_streamLen = 51200;
	}
	#endif //defined(SIM_IN_ADS)

	#if defined(SIM_WITH_VSP)	
		ptrOutBfr = (uint8 *) MallocExtraMem(0); //need not use this if SIM_WITH_VSP
	#else
		ptrOutBfr = (uint8 *) MallocExtraMem(352*288*3/2 * 6);  //can store 6 cif frame
	#endif	 
		g_pOutBfr = ptrOutBfr;	
#endif //defined(SIM_IN_WIN)

}

void PrintfConfRTLVrf (int FrameWidth, int FrameHeight, INPUT_PARA_T * input_ptr, int readFileSize)
{
//	int i, input_file_path_len;
//	FILE * config_fp; 	
//
//	#if defined(MPEG4_ENC)
//		char test_vect_file_path[200] = "D:/SC8801H/code/Firmware/mp4_encoder/simulation/test_vectors/";
//	#elif defined(MPEG4_DEC)
//		char test_vect_file_path[200] = "D:/SC8801H/code/Firmware/mp4_decoder/simulation/test_vectors/";
//	#elif defined(JPEG_ENC)
//		char test_vect_file_path[200] = "D:/SC8801H/code/Firmware/jpeg_codec/simulation/VC/Enc_WinPrj/test_vectors/";	
//	#elif defined(JPEG_DEC)
//		char test_vect_file_path[200] = "D:/SC8801H/code/Firmware/jpeg_codec/simulation/VC/Dec_WinPrj/test_vectors/";
//	#else
//		assert(0);
//	#endif
//
//
//	assert(NULL != (config_fp = fopen(strcat(test_vect_file_path, "default.cfg"),"w")));
//
//	i = input_file_path_len = strlen(g_input->infile);
//
//	while(g_input->infile[i] != '\\')
//	{
//			i--;
//	}
//
//#if defined(MPEG4_DEC)
//	fprintf (config_fp, "ENC_DEC = DECODE\n");
//	fprintf (config_fp, "STANDARD = MPEG4\n");
//	fprintf (config_fp, "BITSTREAM_BADDR = 0000_0000\n");
//	fprintf (config_fp, "BITSTREAM_SIZE   = %d\n", readFileSize);
//	fprintf (config_fp, "BITSTREAM_FILE   = ./test_vectors/");	fprintf (config_fp, "%s\n", g_input->infile+i+1);
//	fprintf (config_fp, "FRAME_WIDTH   = %d\n", FrameWidth);
//	fprintf (config_fp, "FRAME_HEIGHT   = %d\n", FrameHeight);
//	fprintf (config_fp, "FRAME_NUM   = %d\n", input_ptr->frame_num_dec);
//#elif defined(MPEG4_ENC)
//	fprintf (config_fp, "ENC_DEC = ENCODE\n");
//	fprintf (config_fp, "STANDARD = MPEG4\n");
//	fprintf (config_fp, "BITSTREAM_BADDR = 0000_0000\n");
//	fprintf (config_fp, "BITSTREAM_SIZE   = %d\n", readFileSize);
//	fprintf (config_fp, "ENC_RAW_FILE   = ./test_vectors/"); fprintf (config_fp, "%s\n", g_input->infile+i+1);
//	fprintf (config_fp, "ENC_YUV_FORMAT   = YUV420\n");
//	
//	fprintf (config_fp, "FRAME_WIDTH   = %d\n", FrameWidth);
//	fprintf (config_fp, "FRAME_HEIGHT   = %d\n", FrameHeight);
//	fprintf (config_fp, "FRAME_NUM   = %d\n", g_input->frame_num_enc);
//#elif defined(JPEG_DEC)
//	fprintf (config_fp, "ENC_DEC = DECODE\n");
//	fprintf (config_fp, "STANDARD = JPEG\n");
//	fprintf (config_fp, "BITSTREAM_BADDR = 0000_0000\n");
//	fprintf (config_fp, "BITSTREAM_SIZE   = %d\n", readFileSize);
//	fprintf (config_fp, "BITSTREAM_FILE   = ./test_vectors/"); fprintf (config_fp, "%s\n", g_input->infile+i+1);
//	fprintf (config_fp, "FRAME_WIDTH   = %d\n", FrameWidth);
//	fprintf (config_fp, "FRAME_HEIGHT   = %d\n", FrameHeight);
//	fprintf (config_fp, "FRAME_NUM   = %d\n", 1);
//#else //JPEG_ENC
//	fprintf (config_fp, "ENC_DEC = ENCODE\n");
//	fprintf (config_fp, "STANDARD = JPEG\n");
//	fprintf (config_fp, "BITSTREAM_BADDR = 0000_0000\n");
//	fprintf (config_fp, "BITSTREAM_SIZE   = %d\n", readFileSize);
//	fprintf (config_fp, "ENC_RAW_FILE   = ./test_vectors/"); fprintf (config_fp, "%s\n", g_input->infile+i+1);
//	if(g_input->mcu_info == 3)
//	{
//		fprintf (config_fp, "ENC_YUV_FORMAT   = YUV422\n");
//	}else
//	{
//		fprintf (config_fp, "ENC_YUV_FORMAT   = YUV420\n");
//	}
//	
//	fprintf (config_fp, "FRAME_WIDTH   = %d\n", FrameWidth);
//	fprintf (config_fp, "FRAME_HEIGHT   = %d\n", FrameHeight);
//	fprintf (config_fp, "FRAME_NUM   = %d\n", 1);
//#endif
//
//	fclose(config_fp);
}

extern void Mp4Enc_main(void);
extern void Mp4Dec_main(void);
extern void JpegEnc_main(void);
extern void JpegDec_main(void);
extern void H264Dec_main(void);
extern int g_readFileSize;

void main(void)
{
	InitInterMallocMemory();
	InitExtraMallocMemory();

	init_conf();
	paramet_set();

	g_uv_interleaved = 1;

#if defined(MPEG4_ENC)
	Mp4Enc_main();
#elif defined(MPEG4_DEC)
	Mp4Dec_main();
#elif defined(JPEG_ENC)
	JpegEnc_main();
#elif defined(JPEG_DEC)
	JpegDec_main();
#elif defined(H264_DEC)
	H264Dec_main();
#elif defined(REAL_DEC)
	RvDec_main();
#else
	assert(0);
#endif

#if !defined(_ARM_)
	if(g_vector_enable_flag)
	{
		int FrameWidth;
		int FrameHeight;
		int readFileSize;

#if defined(MPEG4_DEC)
		extern DEC_VOP_MODE_T *Mp4Dec_GetVopmode(void);
		DEC_VOP_MODE_T *vop_mode_ptr = Mp4Dec_GetVopmode();
		
		FrameWidth = vop_mode_ptr->FrameWidth;
		FrameHeight = vop_mode_ptr->FrameHeight;
		readFileSize = g_readFileSize;
#elif defined(MPEG4_ENC)
		FrameWidth = g_input->pic_width;
		FrameHeight = g_input->pic_height;
		readFileSize = FrameWidth*FrameHeight*3/2;
#elif defined(JPEG_DEC)
		JPEG_CODEC_T *Get_JPEGDecCodec(void);
		JPEG_CODEC_T *jpeg_fw_codec = Get_JPEGDecCodec();

		FrameWidth = jpeg_fw_codec->out_width;
		FrameHeight = jpeg_fw_codec->out_height;
		readFileSize = jpeg_fw_codec->decoded_stream_len;
		
#else //JPEG_ENC
		FrameWidth = g_input->pic_width;
		FrameHeight = g_input->pic_height;
		if(g_input->mcu_info == 3) //422
		{
			readFileSize = FrameWidth*FrameHeight*2;	
		}else
		{
			readFileSize = FrameWidth*FrameHeight*3/2;	
		}
#endif 
		PrintfConfRTLVrf (FrameWidth, FrameHeight, g_input, readFileSize);
	}
#endif

#if defined(SIM_IN_WIN)
	#if defined(JPEG_ENC)||defined(MPEG4_ENC)
		fclose(s_pEnc_input_src_file);
		fclose(s_pEnc_output_bs_file);
		#if defined(MPEG4_ENC)
			fclose(s_pEnc_output_recon_file);
		#endif
	#else
		fclose(s_pDec_input_bs_file);
		#if defined(REAL_DEC)
			fclose(s_pDec_disp_yuv_file);
		#else
			fclose(s_pDec_recon_yuv_file);
		#endif
		#if defined(MPEG4_DEC)
			fclose(s_pDec_disp_yuv_file);
			fclose(s_pEnc_output_recon_file);
		#endif
	#endif//defined(JPEG_ENC)||defined(MPEG4_ENC)
		fclose(g_fp_trace_fw);
#endif //defined(SIM_IN_WIN)

	FreeInterMallocMemory();
	FreeExtraMallocMemory();	
}
