/******************************************************************************
 ** File Name:    h264enc_set.c											      *
 ** Author:       Xiaowei Luo                                                 *
 ** DATE:         12/14/2006                                                  *
 ** Copyright:    2006 Spreatrum, Incoporated. All Rights Reserved.           *
 ** Description:                                                              *
 *****************************************************************************/
/******************************************************************************
 **                   Edit    History                                         *
 **---------------------------------------------------------------------------* 
 ** DATE          NAME            DESCRIPTION                                 * 
 ** 12/14/2006    Xiaowei Luo     Create.                                     *
 *****************************************************************************/
/*----------------------------------------------------------------------------*
**                        Dependencies                                        *
**---------------------------------------------------------------------------*/
#include "sc6800x_video_header.h"
#include "hmea_mode.h"
#include "hmea_global.h"
#include "tv_mea.h"
#include "hvlc_tv.h"
/**---------------------------------------------------------------------------*
**                        Compiler Flag                                       *
**---------------------------------------------------------------------------*/
#ifdef   __cplusplus
    extern   "C" 
    {
#endif

extern MODE_DECISION_T	* g_mode_dcs_ptr;

typedef struct  {
	int32 skip_count[3];
	int32 ctx_count[3];
} SKIP_STAT;
SKIP_STAT skip_freq;		

PUBLIC void H264Enc_get_mb_avail (ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr)
{
	int32 mb_x = img_ptr->mb_x;
	int32 mb_y = img_ptr->mb_y;
	int32 curr_mb_slice_nr = mb_info_ptr->slice_nr;	

	mb_cache_ptr->mb_avail_a = ((mb_x > 0) && (curr_mb_slice_nr == (mb_info_ptr - 1)->slice_nr)); //left
	mb_cache_ptr->mb_avail_b = ((mb_y > 0) && (curr_mb_slice_nr == (mb_info_ptr - img_ptr->frame_width_in_mbs)->slice_nr)); //top
	mb_cache_ptr->mb_avail_c = ((mb_y > 0) && 
		(mb_x < (img_ptr->frame_width_in_mbs -1)) && (curr_mb_slice_nr == (mb_info_ptr - img_ptr->frame_width_in_mbs+1)->slice_nr)); //top right
	mb_cache_ptr->mb_avail_d = ((mb_x > 0) && 
		(mb_y > 0) && (curr_mb_slice_nr == (mb_info_ptr - img_ptr->frame_width_in_mbs-1)->slice_nr)); //top left

	return;
}

void H264Enc_start_macroblock (ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr)
{
	int32 i_left_xy = -1;
	int32 i_top_type = -1;
	int32 i_left_type = -1;
	int32 i;
	ENC_MB_MODE_T *top_mb_info_ptr = mb_info_ptr - img_ptr->frame_width_in_mbs;
	ENC_MB_MODE_T *left_mb_info_ptr = mb_info_ptr - 1;
	const int32 i_chroma_qp_table[52] =
	{
		 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
		10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
		20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
		29, 30, 31, 32, 32, 33, 34, 34, 35, 35,
		36, 36, 37, 37, 37, 38, 38, 38, 39, 39,
		39, 39
	};

	mb_info_ptr->qp = img_ptr->qp;
/*#ifdef RC_BU
#ifndef NO_BU_CHANGE
#ifdef PIPELINE_BU_RC
	uint8 RC_QP = rc_pic_paras.curr_pic_qp;
	// Constant QP for I frame, PSNR issue
#ifdef CONST_QP_I
	if ( (img_ptr->frame_num % INTRA_PERIOD)==0 )
	{
		mb_info_ptr->qp = RC_QP;
	}
	else if (img_ptr->curr_mb_nr%BU_SIZE == BU_SIZE-PIPE_MB) // need to calculate the QP for the next basic unit, but not update
#else
	if (img_ptr->curr_mb_nr%BU_SIZE == BU_SIZE-PIPE_MB) // need to calculate the QP for the next basic unit, but not update
#endif
	{
		uint32 BU_nr = (img_ptr->curr_mb_nr+PIPE_MB)/BU_SIZE;
		if (BU_nr != 0 && BU_nr < ceil(g_input->pic_width*g_input->pic_height/256/(double)BU_SIZE))
		{
			RC_QP = rc_init_BU(&(rc_pic_paras), &(rc_bu_paras), BU_bit_stat, BU_nr);
		}
		rc_bu_paras.next_BU_QP = RC_QP;	
		mb_info_ptr->qp = rc_bu_paras.curr_BU_QP;
	}
	else if (img_ptr->curr_mb_nr%BU_SIZE == 0)
	{
		if (img_ptr->curr_mb_nr == 0)
		{
			rc_bu_paras.curr_BU_QP = rc_pic_paras.curr_pic_qp;
			mb_info_ptr->qp = rc_pic_paras.curr_pic_qp;
		}
		else
		{
			rc_bu_paras.curr_BU_QP = rc_bu_paras.next_BU_QP;
			mb_info_ptr->qp = rc_bu_paras.curr_BU_QP;
			if (img_ptr->curr_mb_nr == BU_SIZE)
			{
				rc_pic_paras.remain_bits = rc_pic_paras.target_bits-BU_bit_stat;	
			}
			else
			{
				rc_pic_paras.remain_bits -= BU_bit_stat;	
			}		
		}
		BU_bit_stat = 0;
	}
	else
	{
		mb_info_ptr->qp = rc_bu_paras.curr_BU_QP;
	}
#else
	uint8 RC_QP = rc_pic_paras.curr_pic_qp;

	// Constant QP for I frame, PSNR issue
#ifdef CONST_QP_I
	if ( (img_ptr->frame_num % INTRA_PERIOD)==0 )
	{
		mb_info_ptr->qp = rc_pic_paras.curr_pic_qp;
	}
	else if ( (img_ptr->curr_mb_nr%BU_SIZE == 0) )
#else
	if ( (img_ptr->curr_mb_nr%BU_SIZE == 0) )
#endif
	{
		uint32 BU_nr = img_ptr->curr_mb_nr/BU_SIZE;
		if (BU_nr != 0)
		{
			RC_QP = rc_init_BU(&(rc_pic_paras), &(rc_bu_paras), BU_bit_stat, BU_nr);
		}
		rc_pic_paras.curr_pic_qp = RC_QP;	
		mb_info_ptr->qp = RC_QP;
		BU_bit_stat = 0;
	}
	else
	{
		mb_info_ptr->qp = rc_pic_paras.curr_pic_qp;
	}
#endif	// of PIPELINE_BU_RC
#endif	// of NO_BU_CHANGE
#endif	// of RC_BU*/
	mb_info_ptr->qp_c = i_chroma_qp_table[Clip3(0, 51, mb_info_ptr->qp + img_ptr->i_chroma_qp_offset)];

	mb_cache_ptr->is_skip = 0;

	if(img_ptr->sh.i_first_mb == 0)
		mb_info_ptr->slice_nr = 0;
	else if(img_ptr->sh.i_first_mb == img_ptr->curr_mb_nr)
		mb_info_ptr->slice_nr = left_mb_info_ptr->slice_nr + 1;
	else
		mb_info_ptr->slice_nr = left_mb_info_ptr->slice_nr;

	H264Enc_get_mb_avail (img_ptr, mb_info_ptr, mb_cache_ptr);

	VSP_WRITE_REG (VSP_GLB_REG_BASE+GLB_CTRL0_OFF, (img_ptr->mb_y << 8) | (img_ptr->mb_x << 0), "vsp global reg: configure current MB position");

	mb_cache_ptr->is_skip_a = (mb_cache_ptr->mb_avail_a) ? left_mb_info_ptr->is_skip : 0;
	mb_cache_ptr->is_skip_b = (mb_cache_ptr->mb_avail_b) ? top_mb_info_ptr->is_skip : 0;

	//load cache
	if (mb_cache_ptr->mb_avail_b) //top
	{
		mb_cache_ptr->i_mb_type_top = i_top_type = top_mb_info_ptr->type;

		//load intra 4x4
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[0] - 8] = top_mb_info_ptr->intra4x4_pred_mode[12];
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[1] - 8] = top_mb_info_ptr->intra4x4_pred_mode[13];
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[4] - 8] = top_mb_info_ptr->intra4x4_pred_mode[14];
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[5] - 8] = top_mb_info_ptr->intra4x4_pred_mode[15];

		//load nnz
		mb_cache_ptr->nnz[x264_scan8[0] - 8] = top_mb_info_ptr->nnz[10];
		mb_cache_ptr->nnz[x264_scan8[1] - 8] = top_mb_info_ptr->nnz[11];
		mb_cache_ptr->nnz[x264_scan8[4] - 8] = top_mb_info_ptr->nnz[14];
		mb_cache_ptr->nnz[x264_scan8[5] - 8] = top_mb_info_ptr->nnz[15];

		mb_cache_ptr->nnz[x264_scan8[16+0] - 8] = top_mb_info_ptr->nnz[16+2];
		mb_cache_ptr->nnz[x264_scan8[16+1] - 8] = top_mb_info_ptr->nnz[16+3];

		mb_cache_ptr->nnz[x264_scan8[16+4+0] - 8] = top_mb_info_ptr->nnz[16+4+2];
		mb_cache_ptr->nnz[x264_scan8[16+4+1] - 8] = top_mb_info_ptr->nnz[16+4+3];
	}else
	{
		mb_cache_ptr->i_mb_type_top = -1;

		//load intra 4x4
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[0] - 8] = 
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[1] - 8] = 
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[4] - 8] = 
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[5] - 8] = -1;

		//load nnz
		mb_cache_ptr->nnz[x264_scan8[0] - 8] = 
		mb_cache_ptr->nnz[x264_scan8[1] - 8] = 
		mb_cache_ptr->nnz[x264_scan8[4] - 8] = 
		mb_cache_ptr->nnz[x264_scan8[5] - 8] = 
		mb_cache_ptr->nnz[x264_scan8[16+0] - 8] = 
		mb_cache_ptr->nnz[x264_scan8[16+1] - 8] = 
		mb_cache_ptr->nnz[x264_scan8[16+4+0] - 8] = 
		mb_cache_ptr->nnz[x264_scan8[16+4+1] - 8] = 0x80;
	}

	if (mb_cache_ptr->mb_avail_a)
	{
		mb_cache_ptr->i_mb_type_left = i_left_type = left_mb_info_ptr->type;


		//load intra 4x4
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[0] - 1] = left_mb_info_ptr->intra4x4_pred_mode[3];
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[2] - 1] = left_mb_info_ptr->intra4x4_pred_mode[7];
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[8] - 1] = left_mb_info_ptr->intra4x4_pred_mode[11];
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[10] - 1] = left_mb_info_ptr->intra4x4_pred_mode[15];

		//load nnz
		mb_cache_ptr->nnz[x264_scan8[0] - 1] = left_mb_info_ptr->nnz[5];
		mb_cache_ptr->nnz[x264_scan8[2] - 1] = left_mb_info_ptr->nnz[7];
		mb_cache_ptr->nnz[x264_scan8[8] - 1] = left_mb_info_ptr->nnz[13];
		mb_cache_ptr->nnz[x264_scan8[10] - 1] = left_mb_info_ptr->nnz[15];

		mb_cache_ptr->nnz[x264_scan8[16+0] - 1] = left_mb_info_ptr->nnz[16+1];
		mb_cache_ptr->nnz[x264_scan8[16+2] - 1] = left_mb_info_ptr->nnz[16+3];

		mb_cache_ptr->nnz[x264_scan8[16+4+0] - 1] = left_mb_info_ptr->nnz[16+4+1];
		mb_cache_ptr->nnz[x264_scan8[16+4+2] - 1] = left_mb_info_ptr->nnz[16+4+3];
	}else
	{
		mb_cache_ptr->i_mb_type_left = -1;

		//load inter 4x4
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[0] - 1] = 
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[2] - 1] = 
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[8] - 1] = 
		mb_cache_ptr->intra4x4_pred_mode[x264_scan8[10] - 1] = -1;

		//load nnz
		mb_cache_ptr->nnz[x264_scan8[0] - 1] = 
		mb_cache_ptr->nnz[x264_scan8[2] - 1] = 
		mb_cache_ptr->nnz[x264_scan8[8] - 1] = 
		mb_cache_ptr->nnz[x264_scan8[10] - 1] = 
		mb_cache_ptr->nnz[x264_scan8[16+0] - 1] = 
		mb_cache_ptr->nnz[x264_scan8[16+2] - 1] = 
		mb_cache_ptr->nnz[x264_scan8[16+4+0] - 1] = 
		mb_cache_ptr->nnz[x264_scan8[16+4+2] - 1] = 0x80;
	}

	if (mb_cache_ptr->mb_avail_c)
	{
		mb_cache_ptr->i_mb_type_topright = (top_mb_info_ptr+1)->type;
	}else
	{
		mb_cache_ptr->i_mb_type_topright = -1;
	}

	if (mb_cache_ptr->mb_avail_d)
	{
		mb_cache_ptr->i_mb_type_topleft = (top_mb_info_ptr-1)->type;
	}else
	{
		mb_cache_ptr->i_mb_type_topleft = -1;
	}

	//load ref/mv/mvd
	if (img_ptr->sh.i_type != SLICE_TYPE_I)
	{
		int32 i_list;

		for (i_list = 0; i_list < 1; i_list++)
		{
			if (mb_cache_ptr->mb_avail_d) //top&left
			{
				int32 i8 = x264_scan8[0] - 1 - 1*8;
				ENC_MB_MODE_T *tl_mb_info_ptr = mb_info_ptr - img_ptr->frame_width_in_mbs -1;
				mb_cache_ptr->ref[i8] = tl_mb_info_ptr->ref[3];
				mb_cache_ptr->mv[i8][0] = tl_mb_info_ptr->mv[15][0];
				mb_cache_ptr->mv[i8][1] = tl_mb_info_ptr->mv[15][1];
			}else
			{
				int32 i8 = x264_scan8[0] - 1 - 1*8;
				mb_cache_ptr->ref[i8] = -2;
				mb_cache_ptr->mv[i8][0] = 0;
				mb_cache_ptr->mv[i8][1] = 0;
			}

			if (mb_cache_ptr->mb_avail_b) //top
			{
				int32 i8 = x264_scan8[0] - 1*8;
				ENC_MB_MODE_T *top_mb_info_ptr = mb_info_ptr - img_ptr->frame_width_in_mbs;

				mb_cache_ptr->ref[i8+0] = 
				mb_cache_ptr->ref[i8+1] = top_mb_info_ptr->ref[2+0];
				mb_cache_ptr->ref[i8+2] = 
				mb_cache_ptr->ref[i8+3] = top_mb_info_ptr->ref[2+1];

				for (i = 0; i < 4; i++)
				{
					mb_cache_ptr->mv[i8+i][0] = top_mb_info_ptr->mv[12+i][0];	
					mb_cache_ptr->mv[i8+i][1] = top_mb_info_ptr->mv[12+i][1];
				}
			}else
			{
				int32 i8 = x264_scan8[0] - 8;

				for(i = 0; i < 4; i++)
				{
					mb_cache_ptr->ref[i8+i] = -2;
					mb_cache_ptr->mv[i8+i][0] = 0;
					mb_cache_ptr->mv[i8+i][1] = 0;
				}
			}

			if (mb_cache_ptr->mb_avail_c) //top&right
			{
				int32 i8 = x264_scan8[0] + 4 - 1*8;
				ENC_MB_MODE_T *tr_mb_info_ptr = mb_info_ptr - img_ptr->frame_width_in_mbs +1;

				mb_cache_ptr->ref[i8] = tr_mb_info_ptr->ref[2];
				//mb_cache_ptr->ref[i8] = 0;	// if C is intra, treat it as P with zero mv
				mb_cache_ptr->mv[i8][0] = tr_mb_info_ptr->mv[12][0];	
				mb_cache_ptr->mv[i8][1] = tr_mb_info_ptr->mv[12][1];
				/*if(tr_mb_info_ptr->ref[2]!=0)
				{
					assert(tr_mb_info_ptr->mv[12][0]==0);
					assert(tr_mb_info_ptr->mv[12][1]==0);
				}*/
				//g_mode_dcs_ptr->top_right_ref_idx = tr_mb_info_ptr->ref[2];	// for IME not using D, set C always available
			}else
			{
				int32 i8 = x264_scan8[0] + 4 - 1*8;

				//mb_cache_ptr->ref[i8] = 0;	// -2, force to 0
				mb_cache_ptr->ref[i8] = -2;
				mb_cache_ptr->mv[i8][0] = 0;
				mb_cache_ptr->mv[i8][1] = 0;
				//g_mode_dcs_ptr->top_right_ref_idx = -2;	// for IME not using D, set C always available
			}

			if (mb_cache_ptr->mb_avail_a)
			{
				int32 i8 = x264_scan8[0] - 1;
				ENC_MB_MODE_T *left_mb_info_ptr = mb_info_ptr - 1;

				// assume left MB is inter for IME pipeline stage to obtain MVP
				// (because left MB has not finished mode decision)
				mb_cache_ptr->ref[i8+0*8] = 
				mb_cache_ptr->ref[i8+1*8] = 0;	//left_mb_info_ptr->ref[1];
				mb_cache_ptr->ref[i8+2*8] = 
				mb_cache_ptr->ref[i8+3*8] = 0;	//left_mb_info_ptr->ref[3];
				g_mode_dcs_ptr->left_ref_idx = left_mb_info_ptr->ref[1]; // left_mb_info_ptr->ref[3]

				for (i = 0; i < 4; i++)
				{
					mb_cache_ptr->mv[i8+i*8][0] = g_mode_dcs_ptr->left_blk_mv_ime[i].x; 
					mb_cache_ptr->mv[i8+i*8][1] = g_mode_dcs_ptr->left_blk_mv_ime[i].y;
					g_mode_dcs_ptr->left_blk_mv_fme[i].x = left_mb_info_ptr->mv[3+i*4][0];
					g_mode_dcs_ptr->left_blk_mv_fme[i].y = left_mb_info_ptr->mv[3+i*4][1];
					//mb_cache_ptr->mv[i8+i*8][0] = left_mb_info_ptr->mv[3+i*4][0];	
					//mb_cache_ptr->mv[i8+i*8][1] = left_mb_info_ptr->mv[3+i*4][1];
				}
			}else
			{
				int32 i8 = x264_scan8[0] - 1;

				for(i = 0; i < 4; i++)
				{
					mb_cache_ptr->ref[i8+i*8] = -2;
					mb_cache_ptr->mv[i8+i*8][0] = 0;
					mb_cache_ptr->mv[i8+i*8][1] = 0;
					g_mode_dcs_ptr->left_blk_mv_fme[i].x = 0;
					g_mode_dcs_ptr->left_blk_mv_fme[i].y = 0;
				}
				g_mode_dcs_ptr->left_ref_idx = -2;
			}
		} //for	
	}	
}

void H264Enc_JudgeMBMode (ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr)
{
	uint32 vsp_mb_type;
	int32 y, x;
	MODE_DECISION_T * mode_dcs_ptr = g_mode_dcs_ptr;
	uint8 zScanOrder[16] =
	{
		0,  1,  4,  5,
		2,  3,  6,  7,
		8,  9, 12, 13,
	   10, 11, 14, 15
	};

	vsp_mb_type = mode_dcs_ptr->mb_type;
	mb_info_ptr->mv_skip = 0;
	mb_info_ptr->is_inter16 = 0;
	mb_info_ptr->cost = mode_dcs_ptr->min_cost;
	mb_info_ptr->is_intra = 0;
	mb_info_ptr->is_skip = 0;
	mb_info_ptr->i_chroma_pred_mode = 0;

	if (img_ptr->sh.i_type == SLICE_TYPE_I)
	{
		mb_info_ptr->is_intra = 1;
		
		if (vsp_mb_type == INTRA_MB_16X16)
		{
			mb_info_ptr->type = I_16x16;
			mb_info_ptr->i_intra16x16_pred_mode = mode_dcs_ptr->intra16_mode_y;
		}
		else
		{
			mb_info_ptr->type = I_4x4;
			for (y=0; y<16; y++)
			{
				mb_info_ptr->intra4x4_pred_mode[y] = mode_dcs_ptr->intra4x4_pred_mode[y];
				g_mb_cache_ptr->intra4x4_pred_mode[x264_scan8[zScanOrder[y]]] = mb_info_ptr->intra4x4_pred_mode[y];
			}

			//i4 pred mode
		}	
		
		mb_info_ptr->i_chroma_pred_mode = mode_dcs_ptr->intra_mode_c;

		for( y = 0; y < 4; y++ )
        {
			for( x = 0; x < 4; x++ )
			{
				g_mb_cache_ptr->ref[x264_scan8[0]+x+8*y] = 0;

				g_mb_cache_ptr->mv[x264_scan8[0]+x+8*y][0] = 0;
				g_mb_cache_ptr->mv[x264_scan8[0]+x+8*y][1] = 0;
			}
		}		
	}
	else
	{

////////////////////////////////lsw for skip///////////////////////////////
//		{
//			ENC_MB_MODE_T *top_mb_info_ptr = mb_info_ptr - img_ptr->frame_width_in_mbs;
//			ENC_MB_MODE_T *left_mb_info_ptr = mb_info_ptr - 1;
//			int is_skip_a, is_skip_b, is_skip_c, is_skip_d;
//			int ctx;
//
//			is_skip_a = (g_mb_cache_ptr->mb_avail_a) ? left_mb_info_ptr->is_skip : 0;
//			is_skip_b = (g_mb_cache_ptr->mb_avail_b) ? top_mb_info_ptr->is_skip : 0;
//
//			ctx = is_skip_a + is_skip_b;
//
//			skip_freq.ctx_count[ctx]++;
//
//
// 		}
///////////////////////////////////////////////////////////////////////////
		if (vsp_mb_type == INTRA_MB_16X16)
		{
			mb_info_ptr->is_intra = 1;
			mb_info_ptr->type = I_16x16;
			mb_info_ptr->i_intra16x16_pred_mode = mode_dcs_ptr->intra16_mode_y;

			for( y = 0; y < 4; y++ )
			{
				for( x = 0; x < 4; x++ )
				{
					g_mb_cache_ptr->ref[x264_scan8[0]+x+8*y] = 0;

					g_mb_cache_ptr->mv[x264_scan8[0]+x+8*y][0] = 0;
					g_mb_cache_ptr->mv[x264_scan8[0]+x+8*y][1] = 0;
				}
			}
			mb_info_ptr->i_chroma_pred_mode = mode_dcs_ptr->intra_mode_c;	
		}
		else if (vsp_mb_type == INTRA_MB_4X4)
		{
			mb_info_ptr->is_intra = 1;
			mb_info_ptr->type = I_4x4;
			for (y=0; y<16; y++)
			{
				mb_info_ptr->intra4x4_pred_mode[y] = mode_dcs_ptr->intra4x4_pred_mode[y];
				g_mb_cache_ptr->intra4x4_pred_mode[x264_scan8[zScanOrder[y]]] = mb_info_ptr->intra4x4_pred_mode[y];
			}

			mb_info_ptr->i_chroma_pred_mode = mode_dcs_ptr->intra_mode_c;

			//i4 pred mode
		}
		else if (vsp_mb_type == INTER_MB_SKIP)
		{
			mb_info_ptr->is_skip = 1;
			g_mb_cache_ptr->is_skip = 1;
			mb_info_ptr->type = P_SKIP;	
			mb_info_ptr->is_inter16 = 1;
			mb_info_ptr->i_partition = D_16x16;	
////////////////////////////////lsw for skip///////////////////////////////
//			{
//				ENC_MB_MODE_T *top_mb_info_ptr = mb_info_ptr - img_ptr->frame_width_in_mbs;
//				ENC_MB_MODE_T *left_mb_info_ptr = mb_info_ptr - 1;
//				int is_skip_a, is_skip_b, is_skip_c, is_skip_d;
//				int ctx;
//
//				is_skip_a = (g_mb_cache_ptr->mb_avail_a) ? left_mb_info_ptr->is_skip : 0;
//				is_skip_b = (g_mb_cache_ptr->mb_avail_b) ? top_mb_info_ptr->is_skip : 0;
//
//				ctx = is_skip_a + is_skip_b;
//
//				skip_freq.skip_count[ctx]++;
//
//
// 			}
///////////////////////////////////////////////////////////////////////////
		}
		else if (vsp_mb_type == INTER_MB_16X16)
		{
			mb_info_ptr->type = P_L0;
			mb_info_ptr->i_partition = D_16x16;				
			mb_info_ptr->is_inter16 = 1;
		}
		else if (vsp_mb_type == INTER_MB_16X8)
		{
			mb_info_ptr->type = P_L0;
			mb_info_ptr->i_partition = D_16x8;
		}
		else if (vsp_mb_type == INTER_MB_8X16)
		{
			mb_info_ptr->type = P_L0;
			mb_info_ptr->i_partition = D_8x16;
		}
		else //8x8
		{
			int32 i8x8;
			
			mb_info_ptr->type = P_8x8;
			mb_info_ptr->i_partition = D_8x8;

			for (i8x8 = 0; i8x8 < 4; i8x8++)
			{
				mb_info_ptr->i_sub_partition[i8x8] = BLK8X8;
			}
		}

//		g_mb_cache_ptr->ref[x264_scan8[0]] = 
//        g_mb_cache_ptr->ref[x264_scan8[4]] =
//        g_mb_cache_ptr->ref[x264_scan8[8]] =
//        g_mb_cache_ptr->ref[x264_scan8[12]] = 0;

        for( y = 0; y < 4; y++ )
        {
			for( x = 0; x < 4; x++ )
			{
				int blk8_id;

				blk8_id = (y>>1)*2 + (x>>1);

				g_mb_cache_ptr->ref[x264_scan8[0]+x+8*y] = 0;

				g_mb_cache_ptr->mv[x264_scan8[0]+x+8*y][0] = mode_dcs_ptr->blk_mv[blk8_id].x;
				g_mb_cache_ptr->mv[x264_scan8[0]+x+8*y][1] = mode_dcs_ptr->blk_mv[blk8_id].y;
			}
		}		
	}
}

/*void ConfigureMea (MODE_DECISION_T * mode_dcs_ptr)
{
	uint32 cmd;
	
	cmd = (mode_dcs_ptr->mb_y << 8) | (mode_dcs_ptr->mb_x << 0);
	PrintfCmd (1, MEA_REG_BASE+MEA_MB_POS_OFF, cmd, 0);

	cmd = (mode_dcs_ptr->top_avail << 1) | mode_dcs_ptr->left_avail;
	PrintfCmd (1, MEA_REG_BASE+MEA_NEI_AVAIL_OFF, cmd, 0);

	cmd = (mode_dcs_ptr->fmd_en << 24) | (mode_dcs_ptr->lambda << 16) | 
		  (mode_dcs_ptr->unrestricted_mv << 8) | (mode_dcs_ptr->max_sch_step << 4) | (0<<1) | (0<<0);
	PrintfCmd (1, MEA_REG_BASE+MEA_CFG_OFF, cmd, 0);
		
	if (!mode_dcs_ptr->is_i_frame)
	{	
		cmd = (mode_dcs_ptr->sch_range_y << 8) | mode_dcs_ptr->sch_range_x;
		PrintfCmd (1, MEA_REG_BASE+MEA_SRCH_RANGE_OFF, cmd, 0);		
		
		cmd = (0 << 16) | (mode_dcs_ptr->inter16_mode_cost_th << 0);
		PrintfCmd (1, MEA_REG_BASE+MEA_ME_THR_OFF, cmd, 0);
		
		cmd = mode_dcs_ptr->pred_mv_num;
		PrintfCmd (1, MEA_REG_BASE+MEA_PRE_NUM_OFF, cmd, 0);
		
		cmd = ((uint32*)(mode_dcs_ptr->pred_mv))[0];
		PrintfCmd (1, MEA_REG_BASE+MEA_MVP0_OFF, cmd, 0);
		
		cmd = ((uint32*)(mode_dcs_ptr->pred_mv))[1];
		PrintfCmd (1, MEA_REG_BASE+MEA_MVP1_OFF, cmd, 0);
		
		cmd = ((uint32*)(mode_dcs_ptr->pred_mv))[2];
		PrintfCmd (1, MEA_REG_BASE+MEA_MVP2_OFF, cmd, 0);
		
		cmd = ((mode_dcs_ptr->ref_idx_d & 0xff) << 24) | ((mode_dcs_ptr->ref_idx_c & 0xff) << 16) |
			((mode_dcs_ptr->ref_idx_b & 0xff) <<  8) | ((mode_dcs_ptr->ref_idx_a & 0xff) << 0);
		PrintfCmd (1, MEA_REG_BASE+MEA_REF_IDX_OFF, cmd, 0);
		
		cmd = ((uint32 *)mode_dcs_ptr->left_blk_mv)[0];
		PrintfCmd (1, MEA_REG_BASE+MEA_L0_MV_OFF, cmd, 0);
		
		cmd = ((uint32 *)mode_dcs_ptr->left_blk_mv)[1];
		PrintfCmd (1, MEA_REG_BASE+MEA_L1_MV_OFF, cmd, 0);
		
		cmd = ((uint32 *)mode_dcs_ptr->top_blk_mv)[0];
		PrintfCmd (1, MEA_REG_BASE+MEA_T0_MV_OFF, cmd, 0);
		
		cmd = ((uint32 *)mode_dcs_ptr->top_blk_mv)[1];
		PrintfCmd (1, MEA_REG_BASE+MEA_T1_MV_OFF, cmd, 0);
		
		cmd = ((uint32 *)(&mode_dcs_ptr->tr_blk_mv))[0];
		PrintfCmd (1, MEA_REG_BASE+MEA_TR_MV_OFF, cmd, 0);
		
		cmd = ((uint32 *)(&mode_dcs_ptr->tl_blk_mv))[0];
		PrintfCmd (1, MEA_REG_BASE+MEA_TL_MV_OFF, cmd, 0);
	}

	PrintfCmd (1, MEA_REG_BASE+MEA_CTR_OFF, 1, 0);
}*/

void HMEAConfig (ENC_IMAGE_PARAMS_T * img_ptr, ENC_MB_MODE_T * mb_info_ptr, ENC_MB_CACHE_T * mb_cache_ptr)
{
	int32	mvp[2];
// 	int		right_avail;
// 	int		bot_avail;
	int		pred_num = 0;
	MODE_DECISION_T * mode_dcs_ptr  = g_mode_dcs_ptr; 
	ENC_MB_MODE_T * lmb_info_ptr  = mb_info_ptr-1;
	ENC_MB_MODE_T * tmb_info_ptr  = mb_info_ptr - img_ptr->frame_width_in_mbs;
	ENC_MB_MODE_T * tlmb_info_ptr = tmb_info_ptr - 1;
	ENC_MB_MODE_T * trmb_info_ptr = tmb_info_ptr + 1;
	ENC_MB_MODE_T * rmb_info_ptr  = mb_info_ptr+1;    //right mb in previous frame
	ENC_MB_MODE_T * bmb_info_ptr  = mb_info_ptr+img_ptr->frame_width_in_mbs; //bottom mb in previous frame
	
	mode_dcs_ptr->is_i_frame = (img_ptr->sh.i_type == SLICE_TYPE_I)?1:0;

	mode_dcs_ptr->mb_x = img_ptr->mb_x;
	mode_dcs_ptr->mb_y = img_ptr->mb_y;

	mode_dcs_ptr->skip_ctx = mb_cache_ptr->is_skip_a + mb_cache_ptr->is_skip_b;


//	mode_dcs_ptr->me_flag = img_ptr->me_flag;

	mode_dcs_ptr->cost_thresh  = 0;
	mode_dcs_ptr->intra_thresh = 0;// 0xffff;

	mode_dcs_ptr->max_sch_step	= SEARCH_MAX_STEP;
	mode_dcs_ptr->sch_range_x	= SEARCH_RANGE_X;
	mode_dcs_ptr->sch_range_y	= SEARCH_RANGE_Y;
	mode_dcs_ptr->unrestricted_mv	= 0;
	mode_dcs_ptr->fmd_en		= FAST_MODE_DCS_EN;

	mode_dcs_ptr->lambda = i_qp0_cost_table[mb_info_ptr->qp];

	mode_dcs_ptr->lambda2 = i_qp0_cost2_table[mb_info_ptr->qp];
//#endif


	mode_dcs_ptr->left_avail = mb_cache_ptr->mb_avail_a;
	mode_dcs_ptr->top_avail  = mb_cache_ptr->mb_avail_b;
	mode_dcs_ptr->tr_avail   = mb_cache_ptr->mb_avail_c;
	mode_dcs_ptr->tl_avail   = mb_cache_ptr->mb_avail_d;


	mode_dcs_ptr->qp_per	= g_qpPerRem_tbl[mb_info_ptr->qp][0];
	mode_dcs_ptr->qp_rem	= g_qpPerRem_tbl[mb_info_ptr->qp][1];
	mode_dcs_ptr->qp_per_c	= g_qpPerRem_tbl[mb_info_ptr->qp_c][0];
	mode_dcs_ptr->qp_rem_c	= g_qpPerRem_tbl[mb_info_ptr->qp_c][1];

	if(mode_dcs_ptr->top_avail)
	{
		mode_dcs_ptr->top_blk_4x4_mode[0] = tmb_info_ptr->intra4x4_pred_mode[12];
		mode_dcs_ptr->top_blk_4x4_mode[1] = tmb_info_ptr->intra4x4_pred_mode[13];
		mode_dcs_ptr->top_blk_4x4_mode[2] = tmb_info_ptr->intra4x4_pred_mode[14];
		mode_dcs_ptr->top_blk_4x4_mode[3] = tmb_info_ptr->intra4x4_pred_mode[15];
	}

	if(mode_dcs_ptr->left_avail)
	{
		mode_dcs_ptr->left_blk_4x4_mode[0] = lmb_info_ptr->intra4x4_pred_mode[3];
		mode_dcs_ptr->left_blk_4x4_mode[1] = lmb_info_ptr->intra4x4_pred_mode[7];
		mode_dcs_ptr->left_blk_4x4_mode[2] = lmb_info_ptr->intra4x4_pred_mode[11];
		mode_dcs_ptr->left_blk_4x4_mode[3] = lmb_info_ptr->intra4x4_pred_mode[15];
	}

	//config neighbor mb type, for fast mode decision

	//config pred mv
	if (img_ptr->sh.i_type != SLICE_TYPE_I)
	{
		mode_dcs_ptr->pred_mv[pred_num].x = 0;
		mode_dcs_ptr->pred_mv[pred_num].y = 0;
		pred_num++;

		H264Enc_mb_predict_mv(img_ptr, mb_info_ptr, mb_cache_ptr, 0, 4, mvp, 1);
		mode_dcs_ptr->pred_mv[pred_num].x = mvp[0];
		mode_dcs_ptr->pred_mv[pred_num].y = mvp[1];
		pred_num++;
		
		FPRINTF_ME(g_me_pred_mv_fp, "\npredict mvx: %x, mvy: %x\n", mvp[0], mvp[1]);
#if 0
		//add left, top, and top_right mv for predictor
		if (!lmb_info_ptr->is_intra && !lmb_info_ptr->is_skip && mode_dcs_ptr->left_avail)
		{
			mode_dcs_ptr->pred_mv[pred_num].x = mb_cache_ptr->mv[11][0];	//left
			mode_dcs_ptr->pred_mv[pred_num].y = mb_cache_ptr->mv[11][1];
			pred_num++;
		}

		if (!tmb_info_ptr->is_intra && !tmb_info_ptr->is_skip && mode_dcs_ptr->top_avail)
		{
			mode_dcs_ptr->pred_mv[pred_num].x = mb_cache_ptr->mv[4][0];	//top
			mode_dcs_ptr->pred_mv[pred_num].y = mb_cache_ptr->mv[4][1];
			pred_num++;
		}
		
		if (!trmb_info_ptr->is_intra && !trmb_info_ptr->is_skip && mb_cache_ptr->mb_avail_c)
		{
			mode_dcs_ptr->pred_mv[pred_num].x = mb_cache_ptr->mv[8][0];	//top_right
			mode_dcs_ptr->pred_mv[pred_num].y = mb_cache_ptr->mv[8][1];
			pred_num++;
		}

		if (!tlmb_info_ptr->is_intra && !tlmb_info_ptr->is_skip && mb_cache_ptr->mb_avail_d)
		{
			mode_dcs_ptr->pred_mv[pred_num].x = mb_cache_ptr->mv[3][0];	//top_left
			mode_dcs_ptr->pred_mv[pred_num].y = mb_cache_ptr->mv[3][1];
			pred_num++;
		}

		//configure colocated mb's mv in previous frame

		/*	*/
		//configure right mb in previous frame
		right_avail = mode_dcs_ptr->mb_x < img_ptr->frame_width_in_mbs - 1;
		if (!rmb_info_ptr->is_intra && right_avail)
		{
			mode_dcs_ptr->pred_mv[pred_num].x = rmb_info_ptr->mv[0][0];
			mode_dcs_ptr->pred_mv[pred_num].y = rmb_info_ptr->mv[0][1];
			pred_num++;
		}

		bot_avail = mode_dcs_ptr->mb_y < img_ptr->frame_height_in_mbs - 1;
		if (!bmb_info_ptr->is_intra && bot_avail)
		{
			mode_dcs_ptr->pred_mv[pred_num].x = bmb_info_ptr->mv[0][0];
			mode_dcs_ptr->pred_mv[pred_num].y = bmb_info_ptr->mv[0][1];
			pred_num++;
		}	
		
		if (!mb_info_ptr->is_intra)
		{
			mode_dcs_ptr->pred_mv[pred_num].x = mb_info_ptr->mv[0][0];
			mode_dcs_ptr->pred_mv[pred_num].y = mb_info_ptr->mv[0][1];
			pred_num++;
		}
#endif
		
		mode_dcs_ptr->pred_mv_num = pred_num;

	}

#if 0
	//config sub-mb mode skipped threshold
	if (mb_cache_ptr->mb_avail_a && mb_cache_ptr->mb_avail_b && mb_cache_ptr->mb_avail_c && mb_cache_ptr->mb_avail_d)
	{
		int inter16_num = 0;
		int sum_cost = 0;
		ENC_MB_MODE_T * lmb_info_ptr  = mb_info_ptr-1;
		ENC_MB_MODE_T * tmb_info_ptr  = mb_info_ptr - img_ptr->frame_width_in_mbs;
		ENC_MB_MODE_T * tlmb_info_ptr = tmb_info_ptr - 1;
		ENC_MB_MODE_T * trmb_info_ptr = tmb_info_ptr + 1;

		if (lmb_info_ptr->is_inter16)
		{
			inter16_num++;
			sum_cost += lmb_info_ptr->cost;
		}

		if (tmb_info_ptr->is_inter16)
		{
			inter16_num++;
			sum_cost += tmb_info_ptr->cost;
		}

		if (tlmb_info_ptr->is_inter16)
		{
			inter16_num++;
			sum_cost += tlmb_info_ptr->cost;
		}

		if (trmb_info_ptr->is_inter16)
		{
			inter16_num++;
			sum_cost += trmb_info_ptr->cost;
		}

		if (inter16_num >= 3)
		{
			mode_dcs_ptr->inter16_mode_cost_th = sum_cost / inter16_num;
		}
		else
		{
			mode_dcs_ptr->inter16_mode_cost_th = 0; 
		}
	}
	else
#endif
	{
		//all mode are checked if mb at the frame boundary
		mode_dcs_ptr->inter16_mode_cost_th = 0; 
	}

	mode_dcs_ptr->fast_skip_det = 0;

	//config neighbor mb's mv
	mode_dcs_ptr->left_blk_mv[0].x = mb_cache_ptr->mv[8*1+3][0];
	mode_dcs_ptr->left_blk_mv[0].y = mb_cache_ptr->mv[8*1+3][1];
	mode_dcs_ptr->left_blk_mv[1].x = mb_cache_ptr->mv[8*2+3][0];
	mode_dcs_ptr->left_blk_mv[1].y = mb_cache_ptr->mv[8*2+3][1];
	mode_dcs_ptr->left_blk_mv[2].x = mb_cache_ptr->mv[8*3+3][0];
	mode_dcs_ptr->left_blk_mv[2].y = mb_cache_ptr->mv[8*3+3][1];
	mode_dcs_ptr->left_blk_mv[3].x = mb_cache_ptr->mv[8*4+3][0];
	mode_dcs_ptr->left_blk_mv[3].y = mb_cache_ptr->mv[8*4+3][1];

	mode_dcs_ptr->top_blk_mv[0].x  = mb_cache_ptr->mv[4][0];
	mode_dcs_ptr->top_blk_mv[0].y  = mb_cache_ptr->mv[4][1];
	mode_dcs_ptr->top_blk_mv[1].x  = mb_cache_ptr->mv[5][0];
	mode_dcs_ptr->top_blk_mv[1].y  = mb_cache_ptr->mv[5][1];
	mode_dcs_ptr->top_blk_mv[2].x  = mb_cache_ptr->mv[6][0];
	mode_dcs_ptr->top_blk_mv[2].y  = mb_cache_ptr->mv[6][1];
	mode_dcs_ptr->top_blk_mv[3].x  = mb_cache_ptr->mv[7][0];
	mode_dcs_ptr->top_blk_mv[3].y  = mb_cache_ptr->mv[7][1];

	mode_dcs_ptr->tr_blk_mv.x = mb_cache_ptr->mv[8][0];
	mode_dcs_ptr->tr_blk_mv.y = mb_cache_ptr->mv[8][1];

	mode_dcs_ptr->tl_blk_mv.x = mb_cache_ptr->mv[3][0];
	mode_dcs_ptr->tl_blk_mv.y = mb_cache_ptr->mv[3][1];
	
	mode_dcs_ptr->ref_idx_a  = mb_cache_ptr->ref[8*1+3];
	mode_dcs_ptr->ref_idx_b  = mb_cache_ptr->ref[4];
	mode_dcs_ptr->ref_idx_c  = mb_cache_ptr->ref[8];
	mode_dcs_ptr->ref_idx_d  = mb_cache_ptr->ref[3];

//	ConfigureMea (mode_dcs_ptr);
}


/*****************************************************************************
 * x264_macroblock_analyse:
 *****************************************************************************/
void H264Enc_AnalyseStart( ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr)
{
	HMEAConfig (img_ptr, mb_info_ptr, mb_cache_ptr);

#ifdef TV_OUT
#ifdef ONE_FRAME
	if(img_ptr->frame_num>FRAME_X)
#endif
	Print_IEA_Mode(img_ptr, mb_info_ptr, mb_cache_ptr);
#endif

#if _CMODEL_
	ModeDecisionModule ();
#endif

	// restore left MB's mv & ref
	mb_cache_ptr->mv[11][0] = g_mode_dcs_ptr->left_blk_mv_fme[0].x;
	mb_cache_ptr->mv[11][1] = g_mode_dcs_ptr->left_blk_mv_fme[0].y;
	mb_cache_ptr->mv[19][0] = g_mode_dcs_ptr->left_blk_mv_fme[1].x;
	mb_cache_ptr->mv[19][1] = g_mode_dcs_ptr->left_blk_mv_fme[1].y;
	mb_cache_ptr->mv[27][0] = g_mode_dcs_ptr->left_blk_mv_fme[2].x;
	mb_cache_ptr->mv[27][1] = g_mode_dcs_ptr->left_blk_mv_fme[2].y;
	mb_cache_ptr->mv[35][0] = g_mode_dcs_ptr->left_blk_mv_fme[3].x;
	mb_cache_ptr->mv[35][1] = g_mode_dcs_ptr->left_blk_mv_fme[3].y;
	mb_cache_ptr->ref[11] =
	mb_cache_ptr->ref[19] =
	mb_cache_ptr->ref[27] =
	mb_cache_ptr->ref[35] = g_mode_dcs_ptr->left_ref_idx;
	// restore C's ref
//	mb_cache_ptr->ref[8] = g_mode_dcs_ptr->top_right_ref_idx; // g_mode_dcs_ptr->ref_idx_c is not used here after

//	PrintfCmd (2, MEA_REG_BASE+MEA_CTR_OFF, 2, 2);

	//read out mode decision result
	H264Enc_JudgeMBMode(img_ptr, mb_info_ptr);
	
	return;	
}

LOCAL GetSkipMVPredictor(ENC_MB_CACHE_T *mb_cache_ptr, MOTION_VECTOR_T * mvp)
{
	int		i_refa;
	int   	i_refb;
	int     	i_refc;
	int     	i_refd;
	MOTION_VECTOR_T 	mv_a;
	MOTION_VECTOR_T 	mv_b;
	MOTION_VECTOR_T 	mv_c;
// 	MOTION_VECTOR_T 	mv_d;

	int		i_count;
// 	int		cur_blk_idx;	//index in cache
// 	int		l_blk_idx;	
// 	int		t_blk_idx;
// 	int		tr_blk_idx;
// 	int		tl_blk_idx;
	int		i_ref = 0;

	i_refa  = mb_cache_ptr->ref[4+1*8-1];//left
	i_refb  = mb_cache_ptr->ref[4];//top
	i_refc  = mb_cache_ptr->ref[4+1*8-8+4];//top right
	i_refd  = mb_cache_ptr->ref[3];//top left

	mv_a.x = mb_cache_ptr->mv[11][0];
	mv_a.y = mb_cache_ptr->mv[11][1];//[l_blk_idx];
	mv_b.x = mb_cache_ptr->mv[4][0];	
	mv_b.y = mb_cache_ptr->mv[4][1];	//[t_blk_idx];
	mv_c.x = mb_cache_ptr->mv[8][0];
	mv_c.y = mb_cache_ptr->mv[8][1];//[tr_blk_idx];	
	if(i_refc == 0xfffffffe)
	{
		i_refc = i_refd;
		mv_c.x = mb_cache_ptr->mv[3][0];
		mv_c.y = mb_cache_ptr->mv[3][1];//[tr_blk_idx];	
	}

	i_count = 0;
	if( i_refa == i_ref ) i_count++;
	if( i_refb == i_ref ) i_count++;
	if( i_refc == i_ref ) i_count++;

	if( i_count > 1 )
	{
		mvp->x = MEDIAN( mv_a.x, mv_b.x, mv_c.x );
		mvp->y = MEDIAN( mv_a.y, mv_b.y, mv_c.y );
	}
	else if( i_count == 1 )
	{
		if( i_refa == i_ref )
		{
			mvp->x = mv_a.x;
			mvp->y = mv_a.y;
		}
		else if( i_refb == i_ref )
		{
		 	mvp->x = mv_b.x;
			mvp->y = mv_b.y;
		}
		else
		{
			mvp->x = mv_c.x;
			mvp->y = mv_c.y;
		}
	}
	else if( i_refb == -2 && i_refc == -2 && i_refa != -2 )
	{
		mvp->x = mv_a.x;
		mvp->y = mv_a.y;
	}
	else
	{
		mvp->x = MEDIAN( mv_a.x, mv_b.x, mv_c.x );
	   	mvp->y = MEDIAN( mv_a.y, mv_b.y, mv_c.y );
	}
}

LOCAL void ProbeSkipLast(ENC_MB_CACHE_T *mb_cache_ptr, MOTION_VECTOR_T *mvp)
{
	int i_refa = mb_cache_ptr->ref[x264_scan8[0] - 1];
	int i_refb = mb_cache_ptr->ref[x264_scan8[0] - 8];
	int16 *mv_a = mb_cache_ptr->mv[x264_scan8[0] - 1];
	int16 *mv_b = mb_cache_ptr->mv[x264_scan8[0] - 8];
	
	if( i_refa == -2 || i_refb == -2 ||
		( i_refa == 0 && mv_a[0] == 0 && mv_a[1] == 0 ) ||
		( i_refb == 0 && mv_b[0] == 0 && mv_b[1] == 0 ) )
	{
		mvp->x = mvp->y = 0;
	}
	else
	{
		GetSkipMVPredictor(mb_cache_ptr, mvp);
	}
}

LOCAL void H264Enc_read_nnz_from_dct (ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr)
{
	uint32 tc0, tc1, tc2, tc3, tc4, tc5;
	int32* nnz_ptr = mb_cache_ptr->nnz;
	int32 mb_type = mb_info_ptr->type;
	int32 is_inter16 = mb_info_ptr->is_inter16;
	int32 ref = mb_cache_ptr->ref[x264_scan8[0]];
	uint32 out_cbp;
	int i;

	if(mb_info_ptr->type == P_SKIP)
	{
		for(i = 0; i < 24; i++)
		{
			nnz_ptr[x264_scan8[i]] = 0;
		}
			
		mb_info_ptr->i_cbp_chroma = 0;
		mb_info_ptr->i_cbp_luma = 0;
	}
	else
	{
		//read back the tc from vld
		tc0 = VSP_READ_REG(VSP_DCT_REG_BASE+HDCT_NNZ_BLK_0_OFF, "read out block0 nnz of current MB from dct");
		tc1 = VSP_READ_REG(VSP_DCT_REG_BASE+HDCT_NNZ_BLK_1_OFF, "read out block1 nnz of current MB from dct");
		tc2 = VSP_READ_REG(VSP_DCT_REG_BASE+HDCT_NNZ_BLK_2_OFF, "read out block2 nnz of current MB from dct");
		tc3 = VSP_READ_REG(VSP_DCT_REG_BASE+HDCT_NNZ_BLK_3_OFF, "read out block3 nnz of current MB from dct");
		tc4 = VSP_READ_REG(VSP_DCT_REG_BASE+HDCT_NNZ_BLK_4_OFF, "read out block4 nnz of current MB from dct");
		tc5 = VSP_READ_REG(VSP_DCT_REG_BASE+HDCT_NNZ_BLK_5_OFF, "read out block5 nnz of current MB from dct");

		nnz_ptr [x264_scan8[0]] = (tc0 >> 24) & 0xff;
		nnz_ptr [x264_scan8[1]] = (tc0 >> 16) & 0xff;
		nnz_ptr [x264_scan8[2]] = (tc0 >> 8 ) & 0xff;
		nnz_ptr [x264_scan8[3]] = (tc0 >> 0 ) & 0xff;

		nnz_ptr [x264_scan8[4]] = (tc1 >> 24) & 0xff;
		nnz_ptr [x264_scan8[5]] = (tc1 >> 16) & 0xff;
		nnz_ptr [x264_scan8[6]] = (tc1 >> 8 ) & 0xff;
		nnz_ptr [x264_scan8[7]] = (tc1 >> 0 ) & 0xff;

		nnz_ptr [x264_scan8[8]] = (tc2 >> 24) & 0xff;
		nnz_ptr [x264_scan8[9]] = (tc2 >> 16) & 0xff;
		nnz_ptr [x264_scan8[10]] = (tc2 >> 8 ) & 0xff;
		nnz_ptr [x264_scan8[11]] = (tc2 >> 0 ) & 0xff;

		nnz_ptr [x264_scan8[12]] = (tc3 >> 24) & 0xff;
		nnz_ptr [x264_scan8[13]] = (tc3 >> 16) & 0xff;
		nnz_ptr [x264_scan8[14]] = (tc3 >> 8 ) & 0xff;
		nnz_ptr [x264_scan8[15]] = (tc3 >> 0 ) & 0xff;

		//cb
		nnz_ptr [x264_scan8[16]] = (tc4 >> 24) & 0xff;
		nnz_ptr [x264_scan8[17]] = (tc4 >> 16) & 0xff;
		nnz_ptr [x264_scan8[18]] = (tc4 >> 8 ) & 0xff;
		nnz_ptr [x264_scan8[19]] = (tc4 >> 0 ) & 0xff;
		
		//cr
		nnz_ptr [x264_scan8[20]] = (tc5 >> 24) & 0xff;
		nnz_ptr [x264_scan8[21]] = (tc5 >> 16) & 0xff;
		nnz_ptr [x264_scan8[22]] = (tc5 >> 8 ) & 0xff;
		nnz_ptr [x264_scan8[23]] = (tc5 >> 0 ) & 0xff;

		out_cbp = VSP_READ_REG(VSP_DCT_REG_BASE+HDCT_OUT_CBP_OFF, "read out cbp");
		mb_info_ptr->i_cbp_chroma = out_cbp>>4;
		mb_info_ptr->i_cbp_luma = out_cbp&0xf;

		// derek 2012-08-14 SKIP judge in MEA
		/*if(mb_type == P_L0 && is_inter16 && !out_cbp && ref == 0 && mb_info_ptr->i_partition == D_16x16)
		{
			int j;
			MOTION_VECTOR_T mvp;

			ProbeSkipLast(mb_cache_ptr, &mvp);

 			if( mb_cache_ptr->mv[x264_scan8[0]][0]== mvp.x &&
           			mb_cache_ptr->mv[x264_scan8[0]][1] == mvp.y )
 			{
 				mb_info_ptr->type = P_SKIP;
 				mb_info_ptr->is_skip = 1;	
 				mb_info_ptr->is_inter16 = 1;
 				for(i = 0; i < 4; i++)
 				{
 					for(j = 0; j < 4; j++)
 					{
 						mb_cache_ptr->mv[x264_scan8[4*i + j]][0] = mvp.x;
 						mb_cache_ptr->mv[x264_scan8[4*i + j]][1] = mvp.y;
 					}
 				}
 			}
		}*/
	}

	return;
}


void H264Enc_ConfigDctQuantMB(ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr)
{	
	int32 mb_info_cmd;
	int32 qp_info_cmd;
	uint32 qp_per,qp_rem,qp_per_c,qp_rem_c;
	int32 mb_type	= mb_info_ptr->type;
//	int32 cbp		= mb_cache_ptr->cbp;
//	int32 cbp_uv	= mb_cache_ptr->cbp_uv;

	if (mb_type == I_16x16)
	{
		mb_info_cmd = (0 << 28);
	}else if (mb_type == P_SKIP)
	{
		mb_info_cmd = (1 << 28);
	}else if (mb_type == I_PCM)
	{
		mb_info_cmd = (2 << 28);
	}else
	{
		mb_info_cmd = (3 << 28);
	}
	mb_info_cmd |= (!IS_INTRA(mb_info_ptr->type))<<24;

	mb_info_cmd |= (mb_info_ptr->type==I_4x4);
	
	qp_per = g_qpPerRem_tbl[mb_info_ptr->qp][0];
	qp_rem = g_qpPerRem_tbl[mb_info_ptr->qp][1];
	qp_per_c = g_qpPerRem_tbl[mb_info_ptr->qp_c][0];
	qp_rem_c = g_qpPerRem_tbl[mb_info_ptr->qp_c][1];
	qp_info_cmd = (qp_per<<12) | (qp_per_c<<8) | (qp_rem<<4) | (qp_rem_c<<0);
	VSP_WRITE_REG(VSP_DCT_REG_BASE+IICT_CFG1_OFF, qp_info_cmd, "configure qp information");
	
	VSP_WRITE_REG(VSP_DCT_REG_BASE+HDCT_CFG0_OFF, mb_info_cmd, "configure mb_type and cbp");

	VSP_WRITE_REG(VSP_DCT_REG_BASE+DCT_CONFIG_OFF, 1, "configure dct config: fdct");
	
	VSP_WRITE_REG(VSP_DCT_REG_BASE+IICT_CTRL_OFF, 1, "start iqt");
	
#if _CMODEL_
	hdct_module();
#endif
	
	if(READ_REG_POLL(VSP_DCT_REG_BASE+IICT_CTRL_OFF, V_BIT_1, V_BIT_1, TIME_OUT_CLK,"iict: polling iict one MB status"))
	{
		img_ptr->error_flag = TRUE;
	}

	H264Enc_read_nnz_from_dct (mb_info_ptr, mb_cache_ptr);
	
	return;
}

void H264Enc_ConfigDctQuantBlock(ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr, uint8 blkIdx)
{	
	int32 mb_info_cmd;
	int32 qp_info_cmd;
	uint32 qp_per,qp_rem,qp_per_c,qp_rem_c;
	int32 mb_type	= mb_info_ptr->type;

	if (mb_type == I_16x16)
	{
		mb_info_cmd = (0 << 28);
	}else if (mb_type == P_SKIP)
	{
		mb_info_cmd = (1 << 28);
	}else if (mb_type == I_PCM)
	{
		mb_info_cmd = (2 << 28);
	}else
	{
		mb_info_cmd = (3 << 28);
	}
	mb_info_cmd |= (!IS_INTRA(mb_info_ptr->type))<<24;
	mb_info_cmd |= (blkIdx << 20);
	
	qp_per = g_qpPerRem_tbl[mb_info_ptr->qp][0];
	qp_rem = g_qpPerRem_tbl[mb_info_ptr->qp][1];
	qp_per_c = g_qpPerRem_tbl[mb_info_ptr->qp_c][0];
	qp_rem_c = g_qpPerRem_tbl[mb_info_ptr->qp_c][1];
	qp_info_cmd = (qp_per<<12) | (qp_per_c<<8) | (qp_rem<<4) | (qp_rem_c<<0);
	VSP_WRITE_REG(VSP_DCT_REG_BASE+IICT_CFG1_OFF, qp_info_cmd, "configure qp information");
	
	VSP_WRITE_REG(VSP_DCT_REG_BASE+HDCT_CFG0_OFF, mb_info_cmd, "configure mb_type and cbp");

	VSP_WRITE_REG(VSP_DCT_REG_BASE+DCT_CONFIG_OFF, 1, "configure dct config: fdct");
	
	VSP_WRITE_REG(VSP_DCT_REG_BASE+IICT_CTRL_OFF, 1, "start iqt");
	
#if _CMODEL_
	hdct_module();
#endif
	
	if(READ_REG_POLL(VSP_DCT_REG_BASE+IICT_CTRL_OFF, V_BIT_1, V_BIT_1, TIME_OUT_CLK,"iict: polling iict one MB status"))
	{
		img_ptr->error_flag = TRUE;
	}

// 	H264Enc_read_nnz_from_dct (mb_info_ptr, mb_cache_ptr);
	
	return;
}

void h264enc_macroblock_encode (ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr)
{	
	H264Enc_ConfigDctQuantMB(img_ptr, mb_info_ptr, mb_cache_ptr);
}

void h264enc_block_encode (ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr, uint8 blkIdx)
{	
	H264Enc_ConfigDctQuantBlock(img_ptr, mb_info_ptr, mb_cache_ptr, blkIdx);
}

void H264Enc_start_iqt_macroblock (ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr)
{
	int32 mb_info_cmd;
	int32 qp_info_cmd;
	uint32 qp_per,qp_rem,qp_per_c,qp_rem_c;
	int32 mb_type	= mb_info_ptr->type;

	if (mb_type == I_16x16)
	{
		mb_info_cmd = (0 << 28);
	}else if (mb_type == P_SKIP)
	{
		mb_info_cmd = (1 << 28);
	}else if (mb_type == I_PCM)
	{
		mb_info_cmd = (2 << 28);
	}else
	{
		mb_info_cmd = (3 << 28);
	}
	mb_info_cmd |= (!IS_INTRA(mb_info_ptr->type))<<24;
	mb_info_cmd |= (mb_info_ptr->type==I_4x4);
	
	qp_per = g_qpPerRem_tbl[mb_info_ptr->qp][0];
	qp_rem = g_qpPerRem_tbl[mb_info_ptr->qp][1];
	qp_per_c = g_qpPerRem_tbl[mb_info_ptr->qp_c][0];
	qp_rem_c = g_qpPerRem_tbl[mb_info_ptr->qp_c][1];
	qp_info_cmd = (qp_per<<12) | (qp_per_c<<8) | (qp_rem<<4) | (qp_rem_c<<0);
	VSP_WRITE_REG(VSP_DCT_REG_BASE+IICT_CFG1_OFF, qp_info_cmd, "configure qp information");
	
	VSP_WRITE_REG(VSP_DCT_REG_BASE+HDCT_CFG0_OFF, mb_info_cmd, "configure mb_type and cbp");

	VSP_WRITE_REG(VSP_DCT_REG_BASE+DCT_CONFIG_OFF, 0, "configure dct config: idct");
	
	VSP_WRITE_REG(VSP_DCT_REG_BASE+IICT_CTRL_OFF, 1, "start iqt");

#if _CMODEL_
	hdct_module();
#endif
}

void H264Enc_CheckMBCStatus (ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr)
{
	int32 mb_info_cmd=0;
	mb_info_cmd |= (!IS_INTRA(mb_info_ptr->type))<<30;
	mb_info_cmd |= (mb_info_ptr->type==I_4x4)<<28;
	mb_info_cmd |= 0xffffff;
	VSP_WRITE_REG(VSP_MBC_REG_BASE+MBC_CMD0_OFF, mb_info_cmd, "configure mb information.");

#if _CMODEL_
	mbc_module();
#endif //_CMODEL_

	//check the mbc done flag, or time out flag; if time out, error occur then reset the vsp	
	if(READ_REG_POLL(VSP_MBC_REG_BASE+MBC_ST0_OFF, V_BIT_5, V_BIT_5, TIME_OUT_CLK, "MBC: polling mbc done"))
	{
		img_ptr->error_flag = TRUE;
		return;
	}
	
	VSP_WRITE_REG(VSP_MBC_REG_BASE+MBC_ST0_OFF, V_BIT_5, "clear MBC done flag");

}

int32 H264Enc_mb_pred_intra4x4_mode (ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, int32 idx, ENC_MB_CACHE_T *mb_cache_ptr)
{
	int32 ma = mb_cache_ptr->intra4x4_pred_mode[x264_scan8[idx] - 1];
	int32 mb = mb_cache_ptr->intra4x4_pred_mode[x264_scan8[idx] - 8];
	int32 m = mmin(g_mb_pred_mode4x4_fix[ma+1], g_mb_pred_mode4x4_fix[mb+1]);

	if (m < 0)
	{
		return I_PRED_4x4_DC;
	}

	return m;
}

void h264enc_macroblock_write_cavlc( ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr )
{
	int32 mb_type = mb_info_ptr->type;
	int32 i;
	int32 mb_i_offset;

	switch(img_ptr->sh.i_type) 
	{
	case SLICE_TYPE_I:
		mb_i_offset = 0;
		break;
	case SLICE_TYPE_P:
		mb_i_offset = 5;
		break;
	default:
		break;
	}

	/* Write:
      - type
      - prediction
      - mv */
	/*if (mb_type == I_PCM)
	{
		 // Untested
		WRITE_UE_V(mb_i_offset+25);
		H264Enc_ByteAlign(0);

		//TBD

		//luma
		//cb
		//cr

		return;
	}else */
	if (mb_type == I_4x4)
	{
		WRITE_UE_V(mb_i_offset+0);
#ifdef TV_OUT
		mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
		PrintfCavlcOffset(mb_info_ptr, "intra_4x4_mb_type");
		mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
		mb_info_ptr->mb_type_val = mb_i_offset+0;
		mb_info_ptr->prev_intra4x4_pred_mode_flag = 0;
		mb_info_ptr->rem_intra4x4_pred_mode[0] = 0;
		mb_info_ptr->rem_intra4x4_pred_mode[1] = 0;
		mb_info_ptr->rem_intra4x4_pred_mode[2] = 0;

		//prediction: Luma
		for (i = 0; i < 16; i++)
		{
			int32 pred = H264Enc_mb_pred_intra4x4_mode (img_ptr, mb_info_ptr, i, mb_cache_ptr);
			uint8 zScanOrder[16] =
					{
						0,  1,  4,  5,
						2,  3,  6,  7,
						8,  9, 12, 13,
					   10, 11, 14, 15
					};
			int32 mode = g_mb_pred_mode4x4_fix[mb_info_ptr->intra4x4_pred_mode[zScanOrder[i]]+1];
	
			if (pred == mode)
			{
				H264Enc_OutputBits (1, 1); /* b_prev_intra4x4_pred_mode */
				mb_info_ptr->prev_intra4x4_pred_mode_flag |= (1 << i);
#ifdef TV_OUT
				mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
				PrintfCavlcOffset(mb_info_ptr, "prev_intra4x4_pred_mode_flag");
				mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
			}else
			{
				H264Enc_OutputBits (0, 1);  /* b_prev_intra4x4_pred_mode */
#ifdef TV_OUT
				mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
				PrintfCavlcOffset(mb_info_ptr, "prev_intra4x4_pred_mode_flag");
				mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif

				if (mode < pred)
				{
					H264Enc_OutputBits (mode, 3);
					mb_info_ptr->rem_intra4x4_pred_mode[i/7] |= ((mode & 0xf) << ((i%7)*4));
#ifdef TV_OUT
					mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
					PrintfCavlcOffset(mb_info_ptr, "rem_intra4x4_pred_mode");
					mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
				}else
				{
					H264Enc_OutputBits (mode - 1, 3);
					mb_info_ptr->rem_intra4x4_pred_mode[i/7] |= (((mode-1) & 0xf) << ((i%7)*4));
#ifdef TV_OUT
					mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
					PrintfCavlcOffset(mb_info_ptr, "rem_intra4x4_pred_mode");
					mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
				}
			}	
		}
		WRITE_UE_V (g_mb_pred_mode8x8c_fix[mb_info_ptr->i_chroma_pred_mode]);
#ifdef TV_OUT
		mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
		PrintfCavlcOffset(mb_info_ptr, "intra_chroma_pred_mode");
		mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
	}else if (mb_type == I_16x16)
	{
		uint32 val;

		val = mb_i_offset + 1 + g_mb_pred_mode16x16_fix[mb_info_ptr->i_intra16x16_pred_mode] + 
			mb_info_ptr->i_cbp_chroma * 4 + ((mb_info_ptr->i_cbp_luma == 0)?0:12);
		mb_info_ptr->mb_type_val = val;
		WRITE_UE_V (val);
#ifdef TV_OUT
		mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
		PrintfCavlcOffset(mb_info_ptr, "intra_16x16_mb_type");
		mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
		WRITE_UE_V(g_mb_pred_mode8x8c_fix[mb_info_ptr->i_chroma_pred_mode]);
#ifdef TV_OUT
		mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
		PrintfCavlcOffset(mb_info_ptr, "intra_chroma_pred_mode");
		mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
	}else if (mb_type == P_L0)
	{
		int32 mvp[2];

		if (mb_info_ptr->i_partition == D_16x16)
		{
			WRITE_UE_V (0);
#ifdef TV_OUT
			mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
			PrintfCavlcOffset(mb_info_ptr, "inter_16x16_mb_type");
			mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
			mb_info_ptr->mb_type_val = 0;

            if( img_ptr->sh.i_num_ref_idx_l0_active > 1 )
            {
                WRITE_TE_V( img_ptr->sh.i_num_ref_idx_l0_active - 1, mb_cache_ptr->ref[x264_scan8[0]] );
#ifdef TV_OUT
				mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
				PrintfCavlcOffset(mb_info_ptr, "ref_idx_l0");
				mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
            }
            H264Enc_mb_predict_mv(img_ptr, mb_info_ptr, mb_cache_ptr, 0, 4, mvp, 0);
            WRITE_SE_V (mb_cache_ptr->mv[x264_scan8[0]][0] - mvp[0] );
#ifdef TV_OUT
			mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
			PrintfCavlcOffset(mb_info_ptr, "mvd_l0");
			mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
            WRITE_SE_V (mb_cache_ptr->mv[x264_scan8[0]][1] - mvp[1] );
#ifdef TV_OUT
			mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
			PrintfCavlcOffset(mb_info_ptr, "mvd_l0");
			mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
			mb_info_ptr->mvd_8x8[0][0] = 
			mb_info_ptr->mvd_8x8[1][0] = 
			mb_info_ptr->mvd_8x8[2][0] = 
			mb_info_ptr->mvd_8x8[3][0] = (mb_cache_ptr->mv[x264_scan8[0]][0] - mvp[0]);
			mb_info_ptr->mvd_8x8[0][1] = 
			mb_info_ptr->mvd_8x8[1][1] = 
			mb_info_ptr->mvd_8x8[2][1] = 
			mb_info_ptr->mvd_8x8[3][1] = (mb_cache_ptr->mv[x264_scan8[0]][1] - mvp[1]);
		}else if (mb_info_ptr->i_partition == D_16x8)
		{
			WRITE_UE_V (1);
			mb_info_ptr->mb_type_val = 1;
            if( img_ptr->sh.i_num_ref_idx_l0_active > 1 )
            {
                WRITE_TE_V (img_ptr->sh.i_num_ref_idx_l0_active - 1, mb_cache_ptr->ref[x264_scan8[0]] );
                WRITE_TE_V (img_ptr->sh.i_num_ref_idx_l0_active - 1, mb_cache_ptr->ref[x264_scan8[8]] );
            }

            H264Enc_mb_predict_mv (img_ptr, mb_info_ptr, mb_cache_ptr, 0, 4, mvp, 0);
            WRITE_SE_V (mb_cache_ptr->mv[x264_scan8[0]][0] - mvp[0] );
            WRITE_SE_V (mb_cache_ptr->mv[x264_scan8[0]][1] - mvp[1] );

            H264Enc_mb_predict_mv (img_ptr, mb_info_ptr, mb_cache_ptr, 8, 4, mvp, 0);
            WRITE_SE_V (mb_cache_ptr->mv[x264_scan8[8]][0] - mvp[0] );
            WRITE_SE_V (mb_cache_ptr->mv[x264_scan8[8]][1] - mvp[1] );
		}else if (mb_info_ptr->i_partition == D_8x16) 
		{
			WRITE_UE_V (2);
			mb_info_ptr->mb_type_val = 2;
            if( img_ptr->sh.i_num_ref_idx_l0_active > 1 )
            {
                WRITE_TE_V (img_ptr->sh.i_num_ref_idx_l0_active - 1, mb_cache_ptr->ref[x264_scan8[0]] );
                WRITE_TE_V (img_ptr->sh.i_num_ref_idx_l0_active - 1, mb_cache_ptr->ref[x264_scan8[4]] );
            }

            H264Enc_mb_predict_mv (img_ptr, mb_info_ptr, mb_cache_ptr, 0, 2, mvp, 0);
            WRITE_SE_V (mb_cache_ptr->mv[x264_scan8[0]][0] - mvp[0] );
            WRITE_SE_V (mb_cache_ptr->mv[x264_scan8[0]][1] - mvp[1] );

            H264Enc_mb_predict_mv(img_ptr, mb_info_ptr, mb_cache_ptr, 4, 2, mvp, 0);
            WRITE_SE_V (mb_cache_ptr->mv[x264_scan8[4]][0] - mvp[0] );
            WRITE_SE_V (mb_cache_ptr->mv[x264_scan8[4]][1] - mvp[1] );
		}
	}else if (mb_type == P_8x8)
	{
		int32 b_sub_ref0;
		
		if ( (mb_cache_ptr->ref[x264_scan8[0]] == 0) &&
			 (mb_cache_ptr->ref[x264_scan8[4]] == 0) &&
			 (mb_cache_ptr->ref[x264_scan8[8]] == 0) &&
			 (mb_cache_ptr->ref[x264_scan8[12]] == 0)
		   )
		{
			WRITE_UE_V(4);
			b_sub_ref0 = 0;
			mb_info_ptr->mb_type_val = 4;
		}else
		{
			WRITE_UE_V(3);
			b_sub_ref0 = 1;
			mb_info_ptr->mb_type_val = 3;
		}
#ifdef TV_OUT
		mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
		PrintfCavlcOffset(mb_info_ptr, "inter_8x8_mb_type");
		mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif

		/* sub mb type */
		for (i = 0; i < 4; i++)
		{
			uint8 sub_mb_type_p_to_golomb[4]= { 3, 1, 2, 0 };

			WRITE_UE_V(sub_mb_type_p_to_golomb[mb_info_ptr->i_sub_partition[i]]);
#ifdef TV_OUT
			mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
			PrintfCavlcOffset(mb_info_ptr, "sub_mb_type");
			mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
		}

		/* ref0 */
		if (img_ptr->sh.i_num_ref_idx_l0_active > 1 && b_sub_ref0)
		{
			WRITE_TE_V (img_ptr->sh.i_num_ref_idx_l0_active-1, mb_cache_ptr->ref[x264_scan8[0]]);
#ifdef TV_OUT
			mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
			PrintfCavlcOffset(mb_info_ptr, "ref_idx_l0");
			mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
			WRITE_TE_V (img_ptr->sh.i_num_ref_idx_l0_active-1, mb_cache_ptr->ref[x264_scan8[4]]);
#ifdef TV_OUT
			mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
			PrintfCavlcOffset(mb_info_ptr, "ref_idx_l0");
			mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
			WRITE_TE_V (img_ptr->sh.i_num_ref_idx_l0_active-1, mb_cache_ptr->ref[x264_scan8[8]]);
#ifdef TV_OUT
			mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
			PrintfCavlcOffset(mb_info_ptr, "ref_idx_l0");
			mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
			WRITE_TE_V (img_ptr->sh.i_num_ref_idx_l0_active-1, mb_cache_ptr->ref[x264_scan8[12]]);
#ifdef TV_OUT
			mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
			PrintfCavlcOffset(mb_info_ptr, "ref_idx_l0");
			mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif
		}

		for (i = 0; i < 4; i++)
		{
			cavlc_mb8x8_mvd (img_ptr, mb_info_ptr, mb_cache_ptr, i);
		}
	}else
	{
        printf("invalid/unhandled mb_type\n" );
        return;
    }

	/* Coded block patern */
	if (mb_type == I_4x4)
	{
		uint8 intra4x4_cbp_to_golomb[48]=
		{
		  3, 29, 30, 17, 31, 18, 37,  8, 32, 38, 19,  9, 20, 10, 11,  2,
		 16, 33, 34, 21, 35, 22, 39,  4, 36, 40, 23,  5, 24,  6,  7,  1,
		 41, 42, 43, 25, 44, 26, 46, 12, 45, 47, 27, 13, 28, 14, 15,  0
		};

		WRITE_UE_V(intra4x4_cbp_to_golomb[(mb_info_ptr->i_cbp_chroma<<4)|(mb_info_ptr->i_cbp_luma)]);
	}else if (mb_type != I_16x16)
	{
		uint8 inter_cbp_to_golomb[48]=
		{
		  0,  2,  3,  7,  4,  8, 17, 13,  5, 18,  9, 14, 10, 15, 16, 11,
		  1, 32, 33, 36, 34, 37, 44, 40, 35, 45, 38, 41, 39, 42, 43, 19,
		  6, 24, 25, 20, 26, 21, 46, 28, 27, 47, 22, 29, 23, 30, 31, 12
		};

		WRITE_UE_V(inter_cbp_to_golomb[(mb_info_ptr->i_cbp_chroma<<4)|(mb_info_ptr->i_cbp_luma)]);
	}
#ifdef TV_OUT
	mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
	PrintfCavlcOffset(mb_info_ptr, "CBP");
	mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif

	/* write residual */
	if (mb_type == I_16x16)
	{
		cavlc_qp_delta(img_ptr, mb_info_ptr);
#ifdef TV_OUT
		mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
		PrintfCavlcOffset(mb_info_ptr, "qp_delta");
		mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif

	#if _CMODEL_
//		mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;	// CAVLC ONLY
		 /* DC Luma */
		FPRINTF (g_hvlc_event_fp, "luma dc:\n");
		block_residual_write_cavlc (img_ptr, mb_info_ptr, BLOCK_INDEX_LUMA_DC, (int16*)(vsp_dct_io_0+HDCT_COEFF_LUMA_DC_BASE),16);

		/* AC Luma */
		if (mb_info_ptr->i_cbp_luma != 0)
		{
			for (i = 0; i < 16; i++)
			{
				FPRINTF (g_hvlc_event_fp, "luma ac, blk_id: %d\n", i);
				block_residual_write_cavlc (img_ptr, mb_info_ptr, i, (int16*)vsp_dct_io_0+16*i+1, 15);
			}
		}
	#endif
	}else if (mb_info_ptr->i_cbp_luma != 0 || mb_info_ptr->i_cbp_chroma != 0)
	{
		cavlc_qp_delta (img_ptr, mb_info_ptr);
#ifdef TV_OUT
		mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;
		PrintfCavlcOffset(mb_info_ptr, "qp_delta");
		mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;
#endif

#if _CMODEL_
//		mb_info_ptr->cavlc_start_bits = g_bsm_reg_ptr->TOTAL_BITS;	// CAVLC ONLY
		macroblock_luma_write_cavlc (img_ptr, mb_info_ptr, 0, 3);
#endif
	}

	if (mb_info_ptr->i_cbp_chroma != 0)
	{
		 /* Chroma DC residual present */
		FPRINTF (g_hvlc_event_fp, "chroma dc, blk_id: %d\n", 0);
        block_residual_write_cavlc( img_ptr, mb_info_ptr, BLOCK_INDEX_CHROMA_DC, (int16*)(vsp_dct_io_0+HDCT_COEFF_CHROMA_DC_BASE), 4 );
		FPRINTF (g_hvlc_event_fp, "chroma dc, blk_id: %d\n", 1);
        block_residual_write_cavlc( img_ptr, mb_info_ptr, BLOCK_INDEX_CHROMA_DC, (int16*)(vsp_dct_io_0+HDCT_COEFF_CHROMA_DC_BASE+2), 4 );

        if( mb_info_ptr->i_cbp_chroma&0x02 ) /* Chroma AC residual present */
		{
            for( i = 0; i < 8; i++ )
			{
				FPRINTF (g_hvlc_event_fp, "chroma ac, blk_id: %d\n", i);
                block_residual_write_cavlc( img_ptr, mb_info_ptr, 16 + i, (int16*)(vsp_dct_io_0+HDCT_COEFF_CHROMA_AC_BASE)+16*i+1, 15 );
			}
		}
    }
	mb_info_ptr->cavlc_end_bits = g_bsm_reg_ptr->TOTAL_BITS;

//    if( IS_INTRA( i_mb_type ) )
//        h->stat.frame.i_itex_bits += /*bs_pos(s)*/s->bitcnt - i_mb_pos_tex;
//    else
//        h->stat.frame.i_ptex_bits += /*bs_pos(s)*/ s->bitcnt - i_mb_pos_tex;
}


void h264enc_macroblock_cache_save( ENC_IMAGE_PARAMS_T *img_ptr, ENC_MB_MODE_T *mb_info_ptr, ENC_MB_CACHE_T *mb_cache_ptr)
{
//     int32 i_mb_xy = h->i_mb_xy;
    int32 i_mb_type = mb_info_ptr->type;
    int i;

    if( mb_info_ptr->type != I_16x16 && mb_info_ptr->i_cbp_luma == 0 && mb_info_ptr->i_cbp_chroma == 0 )
	{
#ifdef RC_BU
		mb_info_ptr->qp = rc_pic_paras.curr_pic_qp;
#else
        mb_info_ptr->qp = img_ptr->qp;
#endif
	}

//    h->i_last_dqp = mb_info_ptr->i_qp - h->i_last_qp;
//    h->i_last_qp = mb_info_ptr->i_qp;

    /* save intra4x4 */
    if( i_mb_type == I_4x4 )
    {
//        mb_info_ptr->intra4x4_pred_mode[12] = mb_cache_ptr->intra4x4_pred_mode[x264_scan8[10] ];
//        mb_info_ptr->intra4x4_pred_mode[13] = mb_cache_ptr->intra4x4_pred_mode[x264_scan8[11] ];
//        mb_info_ptr->intra4x4_pred_mode[14] = mb_cache_ptr->intra4x4_pred_mode[x264_scan8[14] ];
//        mb_info_ptr->intra4x4_pred_mode[15] = mb_cache_ptr->intra4x4_pred_mode[x264_scan8[15] ];
//        mb_info_ptr->intra4x4_pred_mode[3] = mb_cache_ptr->intra4x4_pred_mode[x264_scan8[5] ];
//        mb_info_ptr->intra4x4_pred_mode[7] = mb_cache_ptr->intra4x4_pred_mode[x264_scan8[7] ];
//        mb_info_ptr->intra4x4_pred_mode[11] = mb_cache_ptr->intra4x4_pred_mode[x264_scan8[13] ];
    }
    else
    {
        mb_info_ptr->intra4x4_pred_mode[12] =
        mb_info_ptr->intra4x4_pred_mode[13] =
        mb_info_ptr->intra4x4_pred_mode[14] =
        mb_info_ptr->intra4x4_pred_mode[15] =
        mb_info_ptr->intra4x4_pred_mode[3] =
        mb_info_ptr->intra4x4_pred_mode[7] =
        mb_info_ptr->intra4x4_pred_mode[11] = 2;
    }

    if( i_mb_type == I_PCM )
    {
        mb_info_ptr->cbp = 0x72f;   /* all set */
        for( i = 0; i < 16 + 2*4; i++ )
        {
            mb_info_ptr->nnz[i] = 16;
        }
    }
    else
    {
        /* save non zero count */
        for( i = 0; i < 16 + 2*4; i++ )
        {
            mb_info_ptr->nnz[i] = mb_cache_ptr->nnz[x264_scan8[i]];
        }
    }

    if( !IS_INTRA( i_mb_type ) )
    {
        int i_list;
        for( i_list = 0; i_list < 1; i_list++ )
        {
            int y,x;

            mb_info_ptr->ref[0] = mb_cache_ptr->ref[x264_scan8[0]];
            mb_info_ptr->ref[1] = mb_cache_ptr->ref[x264_scan8[4]];
            mb_info_ptr->ref[2] = mb_cache_ptr->ref[x264_scan8[8]];
            mb_info_ptr->ref[3] = mb_cache_ptr->ref[x264_scan8[12]];

            for( y = 0; y < 4; y++ )
            {
                for( x = 0; x < 4; x++ )
                {
                    mb_info_ptr->mv[x+y*4][0] = mb_cache_ptr->mv[x264_scan8[0]+x+8*y][0];
                    mb_info_ptr->mv[x+y*4][1] = mb_cache_ptr->mv[x264_scan8[0]+x+8*y][1];
                }
            }
        }
    }
    else
    {
        int i_list;
        for( i_list = 0; i_list < 1; i_list++ )
        {
            int y,x;

            mb_info_ptr->ref[0] =
            mb_info_ptr->ref[1] =
            mb_info_ptr->ref[2] =
            mb_info_ptr->ref[3] = -1;

            for( y = 0; y < 4; y++ )
            {
                for( x = 0; x < 4; x++ )
                {
                    mb_info_ptr->mv[x+y*4][0] = 0;
                    mb_info_ptr->mv[x+y*4][1] = 0;
                }
            }
        }
    }
}

/**---------------------------------------------------------------------------*
**                         Compiler Flag                                      *
**---------------------------------------------------------------------------*/
#ifdef   __cplusplus
    }
#endif
/**---------------------------------------------------------------------------*/
// End 