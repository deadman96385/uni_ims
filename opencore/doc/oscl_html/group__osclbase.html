<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>oscl: OSCL Base</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>OSCL Base</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__OsclBasicAllocator.html">_OsclBasicAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Alloc.html">Oscl_Alloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Dealloc.html">Oscl_Dealloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__DefAlloc.html">Oscl_DefAlloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclDestructDealloc.html">OsclDestructDealloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclAllocDestructDealloc.html">OsclAllocDestructDealloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc&lt; T, Alloc &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclExclusivePtr.html">OsclExclusivePtr&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classOsclExclusivePtr.html" title="The OsclExclusivePtr class is a template class that defines a pointer like object...">OsclExclusivePtr</a> class is a template class that defines a pointer like object intended to be assigned an address obtanined (directly or or indirectly) by new. When the <a class="el" href="classOsclExclusivePtr.html" title="The OsclExclusivePtr class is a template class that defines a pointer like object...">OsclExclusivePtr</a> expires, its destructor uses delete to free the memory.  <a href="classOsclExclusivePtr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclExclusiveArrayPtr.html">OsclExclusiveArrayPtr&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classOsclExclusiveArrayPtr.html" title="The OsclExclusiveArrayPtr class is a template class that defines an array pointer...">OsclExclusiveArrayPtr</a> class is a template class that defines an array pointer like object intended to be assigned an address obtanined (directly or or indirectly) by new. When the <a class="el" href="classOsclExclusiveArrayPtr.html" title="The OsclExclusiveArrayPtr class is a template class that defines an array pointer...">OsclExclusiveArrayPtr</a> expires, its destructor uses delete to free the memory.  <a href="classOsclExclusiveArrayPtr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclExclusivePtrA.html">OsclExclusivePtrA&lt; T, Alloc &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classOsclExclusivePtrA.html" title="The OsclExclusivePtrA class is a template class that defines any pointer like object...">OsclExclusivePtrA</a> class is a template class that defines any pointer like object intended to be assigned an address obtanined (directly or or indirectly) through Alloc. When the <a class="el" href="classOsclExclusivePtrA.html" title="The OsclExclusivePtrA class is a template class that defines any pointer like object...">OsclExclusivePtrA</a> expires, Alloc is used to free the memory.  <a href="classOsclExclusivePtrA.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinkedListElement.html">LinkedListElement&lt; LLClass &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Linked__List__Base.html">Oscl_Linked_List_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Linked__List.html">Oscl_Linked_List&lt; LLClass, Alloc &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__MTLinked__List.html">Oscl_MTLinked_List&lt; LLClass, Alloc, TheLock &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclLockBase.html">OsclLockBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclNullLock.html">OsclNullLock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclScopedLock.html">OsclScopedLock&lt; LockClass &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classOsclScopedLock.html" title="The OsclScopedLock class is a template class that handles unlocking an abstract class...">OsclScopedLock</a> class is a template class that handles unlocking an abstract class on destruction. This is very useful for ensuring that the lock is released when the <a class="el" href="classOsclScopedLock.html" title="The OsclScopedLock class is a template class that handles unlocking an abstract class...">OsclScopedLock</a> goes out of scope.  <a href="classOsclScopedLock.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOscl__Less.html">Oscl_Less&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOscl__Select1st.html">Oscl_Select1st&lt; V, U &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Map.html">Oscl_Map&lt; Key, T, Alloc, Compare &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Opaque__Type__Alloc.html">Oscl_Opaque_Type_Alloc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Opaque__Type__Compare.html">Oscl_Opaque_Type_Compare</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Opaque__Type__Alloc__LL.html">Oscl_Opaque_Type_Alloc_LL</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Queue__Base.html">Oscl_Queue_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Queue.html">Oscl_Queue&lt; T, Alloc &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclRefCounter.html">OsclRefCounter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclRefCounterDA.html">OsclRefCounterDA</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclRefCounterSA.html">OsclRefCounterSA&lt; DeallocType &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclRefCounterMTDA.html">OsclRefCounterMTDA&lt; LockType &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclRefCounterMTSA.html">OsclRefCounterMTSA&lt; DeallocType, LockType &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__DefAllocWithRefCounter.html">Oscl_DefAllocWithRefCounter&lt; DefAlloc &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclRefCounterMemFrag.html">OsclRefCounterMemFrag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclSharedPtr.html">OsclSharedPtr&lt; TheClass &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parameterized smart pointer class.  <a href="classOsclSharedPtr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOscl__Tag__Base.html">Oscl_Tag_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOscl__Tag.html">Oscl_Tag&lt; Alloc &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__TagTree.html">Oscl_TagTree&lt; T, Alloc &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNTPTime.html">NTPTime</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classNTPTime.html" title="The NTPTime class represents a time value as the number of seconds since 0h (UTC)...">NTPTime</a> class represents a time value as the number of seconds since 0h (UTC) Jan. 1, 1900.  <a href="classNTPTime.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeValue.html">TimeValue</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classTimeValue.html" title="The TimeValue class represents a time value in a format native to the system.">TimeValue</a> class represents a time value in a format native to the system.  <a href="classTimeValue.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTLSStorageOps.html">TLSStorageOps</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclTLSRegistry.html">OsclTLSRegistry</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclTLS.html">OsclTLS&lt; T, ID, Registry &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOscl__Pair.html">Oscl_Pair&lt; T1, T2 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOscl__Rb__Tree__Node__Base.html">Oscl_Rb_Tree_Node_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOscl__Rb__Tree__Node.html">Oscl_Rb_Tree_Node&lt; Value &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOscl__Rb__Tree__Iterator.html">Oscl_Rb_Tree_Iterator&lt; Value &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOscl__Rb__Tree__Const__Iterator.html">Oscl_Rb_Tree_Const_Iterator&lt; Value &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Rb__Tree__Base.html">Oscl_Rb_Tree_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Rb__Tree.html">Oscl_Rb_Tree&lt; Key, Value, KeyOfValue, Compare, Alloc &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structOsclMemoryFragment.html">OsclMemoryFragment</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Vector__Base.html">Oscl_Vector_Base</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__Vector.html">Oscl_Vector&lt; T, Alloc &gt;</a></td></tr>
<tr><td colspan="2"><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__assert_8h.html">oscl_assert.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__assert_8h.html" title="The file oscl_assert.h provides an OSCL_ASSERT macro to document assumptions and...">oscl_assert.h</a> provides an OSCL_ASSERT macro to document assumptions and test them during development. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__base_8h.html">oscl_base.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__base_8h.html" title="The file oscl_base.h is the public header that should be included to pick up the...">oscl_base.h</a> is the public header that should be included to pick up the platform configuration, basic type definitions, and common macros. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__base__alloc_8h.html">oscl_base_alloc.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>A basic allocator that does not rely on other modules. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__base__macros_8h.html">oscl_base_macros.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file defines common macros and constants for basic compilation support. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__byte__order_8h.html">oscl_byte_order.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file defines functions providing byte ordering utility (e.g., switching between big and little endian orders). </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__defalloc_8h.html">oscl_defalloc.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file defines simple default memory allocator classes. These allocators are used by the <a class="el" href="classOscl__Vector.html">Oscl_Vector</a> and <a class="el" href="classOscl__Map.html">Oscl_Map</a> class, etc. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__dll_8h.html">oscl_dll.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Defines a DLL entry point. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__exclusive__ptr_8h.html">oscl_exclusive_ptr.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file defines the <a class="el" href="classOsclExclusivePtr.html" title="The OsclExclusivePtr class is a template class that defines a pointer like object...">OsclExclusivePtr</a> template class. This class is used to avoid any potential memory leaks that may arise while returning from methods in case of error. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__linked__list_8h.html">oscl_linked_list.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__linked__list_8h.html" title="The file oscl_linked_list.h defines the template class Oscl_Linked_List which has...">oscl_linked_list.h</a> defines the template class <a class="el" href="classOscl__Linked__List.html">Oscl_Linked_List</a> which has a very similar API as the STL Vector class (it basically provides a subset of the STL functionality). Memory allocation is abstracted through the use of an allocator template parameter. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__lock__base_8h.html">oscl_lock_base.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file defines an abstract lock class, <a class="el" href="classOsclLockBase.html">OsclLockBase</a>, that is used for APIs potentially requiring multi-thread safety. A null-lock implementation, <a class="el" href="classOsclNullLock.html">OsclNullLock</a>, is also provided for single-thread configurations (basically a noop for lock/unlock). Also provides the <a class="el" href="classOsclScopedLock.html" title="The OsclScopedLock class is a template class that handles unlocking an abstract class...">OsclScopedLock</a> class which is template class takes care of freeing the lock when the class goes out of scope. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__map_8h.html">oscl_map.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__map_8h.html" title="The file oscl_map.h defines the template class Oscl_Map which has a very similar...">oscl_map.h</a> defines the template class <a class="el" href="classOscl__Map.html">Oscl_Map</a> which has a very similar API as the STL Map class (it basically provides a subset of the STL functionality). Memory allocation is abstracted through the use of an allocator template parameter. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__mem__inst_8h.html">oscl_mem_inst.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file defines default memory instrumentation level. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__opaque__type_8h.html">oscl_opaque_type.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__opaque__type_8h.html" title="The file oscl_opaque_type.h defines pure virtual classes for working with opaque...">oscl_opaque_type.h</a> defines pure virtual classes for working with opaque types. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__queue_8h.html">oscl_queue.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__queue_8h.html" title="The file oscl_queue.h defines the template class Oscl_Queue. It is similar to the...">oscl_queue.h</a> defines the template class <a class="el" href="classOscl__Queue.html">Oscl_Queue</a>. It is similar to the STL::queue class, with some differences:</p>
<ul>
<li>less complete</li>
<li>based on array rather than a deque</li>
<li>some interfaces modeled on oscl_vector, for ease of transition Memory allocation is abstracted through the use of an allocator template parameter. </li>
</ul>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__refcounter_8h.html">oscl_refcounter.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>A general purpose reference counter to object lifetimes. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__refcounter__memfrag_8h.html">oscl_refcounter_memfrag.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file provides the definition of reference counted memory fragment, which provides access to a buffer and helps manage its manage its lifetime through the refcount. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__shared__ptr_8h.html">oscl_shared_ptr.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file defines a template class <a class="el" href="classOsclSharedPtr.html" title="A parameterized smart pointer class.">OsclSharedPtr</a> which is a "smart pointer" to the parameterized type. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__stdstring_8h.html">oscl_stdstring.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file provides standard string operations such as strlen, strncpy, etc. ANSI defines undefined behavior when the destination pointer is null for operations such as strncpy, strncat, etc. But, we chose to define one. In such cases, we return the destination as null. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__tagtree_8h.html">oscl_tagtree.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__tagtree_8h.html" title="The file oscl_tagtree.h ...">oscl_tagtree.h</a> ... </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__time_8h.html">oscl_time.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__time_8h.html" title="The file oscl_time.h defines to classes NTPTime and TimeValue for getting, manipulating...">oscl_time.h</a> defines to classes <a class="el" href="classNTPTime.html" title="The NTPTime class represents a time value as the number of seconds since 0h (UTC)...">NTPTime</a> and <a class="el" href="classTimeValue.html" title="The TimeValue class represents a time value in a format native to the system.">TimeValue</a> for getting, manipulating, and formatting time values. The <a class="el" href="classTimeValue.html" title="The TimeValue class represents a time value in a format native to the system.">TimeValue</a> class is based on the native system time format while <a class="el" href="classNTPTime.html" title="The NTPTime class represents a time value as the number of seconds since 0h (UTC)...">NTPTime</a> is used for the standard Network Time Protocol format. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__tree_8h.html">oscl_tree.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__tree_8h.html" title="The file oscl_tree.h defines the template class Oscl_Rb_Tree which has a very similar...">oscl_tree.h</a> defines the template class <a class="el" href="classOscl__Rb__Tree.html">Oscl_Rb_Tree</a> which has a very similar API as the STL Tree class. It is an implementation of a Red-Black Tree for use by the <a class="el" href="classOscl__Map.html">Oscl_Map</a> class. Memory allocation is abstracted through the use of an allocator template parameter. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__types_8h.html">oscl_types.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file contains basic type definitions for common use across platforms. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__vector_8h.html">oscl_vector.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__vector_8h.html" title="The file oscl_vector.h defines the template class Oscl_Vector which has a very similar...">oscl_vector.h</a> defines the template class <a class="el" href="classOscl__Vector.html">Oscl_Vector</a> which has a very similar API as the STL Vector class (it basically provides a subset of the STL functionality). Memory allocation is abstracted through the use of an allocator template parameter. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaf7c21e5b6e4fee4247225dd31f89c8ca">OSCL_ASSERT</a>(_expr)&nbsp;&nbsp;&nbsp;((_expr)?((void)0):OSCL_Assert(# _expr,__FILE__,__LINE__))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gab00ad11c34612b99a7cee70e9c1fe9fd">OSCL_HAS_SINGLETON_SUPPORT</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>&nbsp;&nbsp;&nbsp;(0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The NULL_TERM_CHAR is used to terminate c-style strings.  <a href="#ga070d2ce7b6bb7e5c05602aa8c308d0c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaf9da29085597a032c4dd2f3ef4c1b9e6">OSCL_INLINE</a>&nbsp;&nbsp;&nbsp;inline</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gae077275bef28134e570917ff468c8ff1">OSCL_COND_EXPORT_REF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaead960804cd6ebf1d776c7d58159ce91">OSCL_COND_IMPORT_REF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga6f367c891edd99381c917e6dafeff544">OSCL_CONST_CAST</a>(type, exp)&nbsp;&nbsp;&nbsp;((type)(exp))</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type casting macros.  <a href="#ga6f367c891edd99381c917e6dafeff544"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga6872259ca6fd7080c6299210e4b13a6f">OSCL_STATIC_CAST</a>(type, exp)&nbsp;&nbsp;&nbsp;((type)(exp))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga02b042a816d2157bbed1792b26604cd8">OSCL_REINTERPRET_CAST</a>(type, exp)&nbsp;&nbsp;&nbsp;((type)(exp))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gabbc39f0338f358ef4df50a75373749d0">OSCL_DYNAMIC_CAST</a>(type, exp)&nbsp;&nbsp;&nbsp;((type)(exp))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga4fd9dfc2eae26696c83cfba1fbc73448">OSCL_VIRTUAL_BASE</a>(type)&nbsp;&nbsp;&nbsp;type</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(vbl)&nbsp;&nbsp;&nbsp;(void)(vbl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga06bf2e405c0ab3a123fa20acc804dd3f">OSCL_UNUSED_RETURN</a>(value)&nbsp;&nbsp;&nbsp;return value</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga82593faa416c10b2f5c8cb542f61509c">OSCL_MIN</a>(a, b)&nbsp;&nbsp;&nbsp;((a) &lt; (b) ? (a) : (b))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga30ee9dc0d74e3248228cc6a24c0295bb">OSCL_MAX</a>(a, b)&nbsp;&nbsp;&nbsp;((a) &gt; (b) ? (a) : (b))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga5a5b28cd02cdf30b86facadca7c18a54">OSCL_ABS</a>(a)&nbsp;&nbsp;&nbsp;((a) &gt; (0) ? (a) : -(a))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga1aaad20bf2402f23ad9d1634f57a5a32">EPV_ARM_GNUC</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaf269da83bd3aa18a95dd69ee1850029b">EPV_ARM_RVCT</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga3d0754c087c9fee64c81795b3000c8df">EPV_ARM_MSEVC</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga9fcc278d0a7a8d1c95f95c3bd7067994">OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga9a6a685a04fb90ece237939b8d56780b">ALLOCATE</a>(n)&nbsp;&nbsp;&nbsp;allocate(n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga27169a7b4078321760bc56067f4d8669">ALLOC_AND_CONSTRUCT</a>(n)&nbsp;&nbsp;&nbsp;alloc_and_construct(n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga7ea1d74d79ab801aa00cf7e4f5e2aef3">OSCL_DLL_ENTRY_POINT</a>()&nbsp;&nbsp;&nbsp;void oscl_dll_entry_point() {}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga48b4fb2bd526d157e6197f4011bac7b9">OSCL_DLL_ENTRY_POINT_DEFAULT</a>()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga9fcc278d0a7a8d1c95f95c3bd7067994">OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gac0ae3f33e28f7852bd4ece979255a0f4">PVMEM_INST_LEVEL</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga52df9cd30fae914a27342a653bc56e37">OSCL_DISABLE_WARNING_RETURN_TYPE_NOT_UDT</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga9fcc278d0a7a8d1c95f95c3bd7067994">OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gad264e63e3eaaeff06fc893f6dc24c7be">OSCL_TLS_BASE_SLOTS</a>&nbsp;&nbsp;&nbsp;<a class="el" href="group__osclbase.html#ga0c23193ed013c5e4a67592281baf590d">OSCL_TLS_ID_BASE_LAST</a> +1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gab87cbf8399e2eab2a9f4de8e70c50815">OSCL_TLS_MAX_SLOTS</a>&nbsp;&nbsp;&nbsp;( OSCL_TLS_BASE_SLOTS + OSCL_TLS_EXTERNAL_SLOTS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga9fcc278d0a7a8d1c95f95c3bd7067994">OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</a></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga84d4ef38e5682881eb75ff4a64bc38b3">CtimeStrBuf</a> [<a class="el" href="group__osclbase.html#ga0cc83fd35f446400713d1d9f3b2dd4c6">CTIME_BUFFER_SIZE</a>]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gad13c32c10063619e00563a850f87b86a">PV8601timeStrBuf</a> [<a class="el" href="group__osclbase.html#ga141a5fd80c38f29950e7b7d67d4867b1">PV8601TIME_BUFFER_SIZE</a>]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga83f7b514c3cbe5977e2916ca10e11869">ISO8601timeStrBuf</a> [<a class="el" href="group__osclbase.html#ga4469595fff8ac9560ee57d6d9d841063">ISO8601TIME_BUFFER_SIZE</a>]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__osclbase.html#ga3bac54662348f5e6c08b97ca97066b89">OsclAny</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga723fadcc6e6137090da5371f44113941">TOsclTlsKey</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gab5ed9ea532eb401f23c866e4d55ee72e">c_bool</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The c_bool type is mapped to an integer to provide a bool type for C interfaces.  <a href="#gab5ed9ea532eb401f23c866e4d55ee72e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga3bac54662348f5e6c08b97ca97066b89">OsclAny</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The OsclAny is meant to be used the context of a generic pointer (i.e., no specific type).  <a href="#ga3bac54662348f5e6c08b97ca97066b89"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaf70fa576f0c9e5b026dfe82518c11b1e">mbchar</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">mbchar is multi-byte char (e.g., UTF-8) with null termination.  <a href="#gaf70fa576f0c9e5b026dfe82518c11b1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The uint type is a convenient abbreviation for unsigned int.  <a href="#ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gadc554e3aa0719a67a3c4b61c252e564c">octet</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The octet type is meant to be used for referring to a byte or collection bytes without suggesting anything about the underlying meaning of the bytes.  <a href="#gadc554e3aa0719a67a3c4b61c252e564c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gac5984c186a54bb7f5bd71246413166cf">OsclFloat</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Float type defined as OsclFloat.  <a href="#gac5984c186a54bb7f5bd71246413166cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga13a226153f56d45b50a162260dcd0e38">OsclSizeT</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef OSCL_NATIVE_INT64_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gad3ba4095e745890683ed3aa53c47384d">int64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef OSCL_NATIVE_UINT64_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef OSCL_NATIVE_WCHAR_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gad21ec41919dd47678bcbc107ace687c9">OSCL_TCHAR</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">define OSCL_TCHAR  <a href="#gad21ec41919dd47678bcbc107ace687c9"></a><br/></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga0423d00e0eb199de523a92031b5a1107">TimeUnits</a> { <a class="el" href="group__osclbase.html#gga0423d00e0eb199de523a92031b5a1107a70367ff8e866216e6a822a2c952abfc1">SECONDS</a> =  0, 
<a class="el" href="group__osclbase.html#gga0423d00e0eb199de523a92031b5a1107a1043c5211bc8c40b382a93bd238c9131">MILLISECONDS</a> =  1, 
<a class="el" href="group__osclbase.html#gga0423d00e0eb199de523a92031b5a1107ac9db1eab6da2865d20c916504baedc90">MICROSECONDS</a> =  2
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The TimeUnits enum can be used when constructing a <a class="el" href="classTimeValue.html" title="The TimeValue class represents a time value in a format native to the system.">TimeValue</a> class. </p>
 <a href="group__osclbase.html#ga0423d00e0eb199de523a92031b5a1107">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga97188d2c6248adc3fef36f483696a332">_OSCL_Abort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function terminates the current process abnormally.  <a href="#ga97188d2c6248adc3fef36f483696a332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga89f94c4160d32bcfc94fc215239ec5c7">OSCL_Assert</a> (const char *expr, const char *filename, int line_number)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">OSCL_ASSERT macro evaluates an expression and when the result is false, prints a diagnostic message and aborts the program.  <a href="#ga89f94c4160d32bcfc94fc215239ec5c7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gae420cafa320e40f84b5a46b32465296c">PVOsclBase_Init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga502be196b4670a35a7f5a345d105308d">PVOsclBase_Cleanup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga9d0c1c30ed9dc653b7e143689802048d">little_endian_to_host</a> (char *data, uint32 size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert little endian to host format.  <a href="#ga9d0c1c30ed9dc653b7e143689802048d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga3b010bdaf14e002a769b87df7efa9a0d">host_to_little_endian</a> (char *data, unsigned int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert host to little endian format.  <a href="#ga3b010bdaf14e002a769b87df7efa9a0d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga80781fa5b4da418f911f58732644f067">big_endian_to_host</a> (char *data, unsigned int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert big endian to host format.  <a href="#ga80781fa5b4da418f911f58732644f067"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gadb579872de1387b02fe73bc4fc0a576c">host_to_big_endian</a> (char *data, unsigned int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert host to big endian format.  <a href="#gadb579872de1387b02fe73bc4fc0a576c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gade51c7acffa07b9f8ba607b6d612e97c">OsclSharedPtr::OsclSharedPtr</a> (TheClass *inClassPtr, <a class="el" href="classOsclRefCounter.html">OsclRefCounter</a> *in_refcnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor.  <a href="#gade51c7acffa07b9f8ba607b6d612e97c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gab8cdae055fa3ab08039b0e022753b0d6">OsclSharedPtr::OsclSharedPtr</a> (const <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a> &amp;inSharedPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#gab8cdae055fa3ab08039b0e022753b0d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga6225904b5fa63a7379006e3f06c0b06a">OsclSharedPtr::~OsclSharedPtr</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#ga6225904b5fa63a7379006e3f06c0b06a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TheClass *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga9172a5f5333a2f3cd5b0666e4ca8f7d6">OsclSharedPtr::operator-&gt;</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TheClass &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gae933e3a791eedeb012c163d749ed814d">OsclSharedPtr::operator*</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The indirection operator returns a reference to an object of the parameterized type.  <a href="#gae933e3a791eedeb012c163d749ed814d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga15eac54f31b6df7fe5df004141ae7f43">OsclSharedPtr::operator TheClass *</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Casting operator.  <a href="#ga15eac54f31b6df7fe5df004141ae7f43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TheClass *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga16e5b2c74486acf9d5721e47dbeaa8d6">OsclSharedPtr::GetRep</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this function to get a pointer to the wrapped object.  <a href="#ga16e5b2c74486acf9d5721e47dbeaa8d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOsclRefCounter.html">OsclRefCounter</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga8de7359219d8c3c7991b0207b88a119f">OsclSharedPtr::GetRefCounter</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the refcount pointer. This should primarily be used for conversion operations.  <a href="#ga8de7359219d8c3c7991b0207b88a119f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaa2a06a6f82c42db5f18491805937508b">OsclSharedPtr::get_count</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a count of how many references to the object exist.  <a href="#gaa2a06a6f82c42db5f18491805937508b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga1d0584bc00294d8a38ed327de540dbb9">OsclSharedPtr::Bind</a> (const <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a> &amp;inHandle)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this function to bind an existing <a class="el" href="classOsclSharedPtr.html" title="A parameterized smart pointer class.">OsclSharedPtr</a> to a already-wrapped object.  <a href="#ga1d0584bc00294d8a38ed327de540dbb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga0f4eb250bf055b9f0b3210d99ae4c33f">OsclSharedPtr::Bind</a> (TheClass *ptr, <a class="el" href="classOsclRefCounter.html">OsclRefCounter</a> *in_refcnt)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this function to bind an existing <a class="el" href="classOsclSharedPtr.html" title="A parameterized smart pointer class.">OsclSharedPtr</a> to a new (unwrapped) object.  <a href="#ga0f4eb250bf055b9f0b3210d99ae4c33f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga8aad65d5c763ed07ec379b4f080c1899">OsclSharedPtr::Unbind</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this function of unbind an existing <a class="el" href="classOsclSharedPtr.html" title="A parameterized smart pointer class.">OsclSharedPtr</a>.  <a href="#ga8aad65d5c763ed07ec379b4f080c1899"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga10da41094264a26676f267f45a7e550a">OsclSharedPtr::operator=</a> (const <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a> &amp;inSharedPtr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#ga10da41094264a26676f267f45a7e550a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga948093bfeedab10a96d8fda172a85250">OsclSharedPtr::operator==</a> (const <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a> &amp;b) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Test for equality to see if two PVHandles wrap the same object.  <a href="#ga948093bfeedab10a96d8fda172a85250"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga7a69d1e37d0d89889020234ddab938a1">oscl_strlen</a> (const char *str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gadbc6ee7456522d3705ed148ec838c121">oscl_strlen</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaa8084d54811b0ca99f4969028165cfe8">oscl_strncpy</a> (char *dest, const char *src, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga78b42e99bf97f8dadb936a406cfd9cf1">oscl_strncpy</a> (<a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *dest, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *src, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga15ec89685a75ae571d1102641a0c95e6">oscl_strcmp</a> (const char *str1, const char *str2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gadf5ff51dd5a58a590fa4b27038160a10">oscl_strcmp</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str1, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gae20b63524fe9c0eecff8e2b64f142dfc">oscl_strncmp</a> (const char *str1, const char *str2, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga003f8210120c6ca4e7e3574320bdb807">oscl_strncmp</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str1, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str2, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga0f3176335ffe1ea119cbda2f5976263f">oscl_strncat</a> (char *dest, const char *src, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga10686c6102c0e0fa6ceaa54c009fde66">oscl_strncat</a> (<a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *dest, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *src, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga7f0d3c6aaa3e65089c6309770c40a138">oscl_strchr</a> (const char *str, int32 c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga0de98675f3aef3865fb37a3b1bbe3763">oscl_strchr</a> (char *str, int32 c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga82b93e86712d1e428280ae2876d3bcde">oscl_strchr</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str, int32 c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga2f9d4ee2409b1be4a7be89a7d19a2c9a">oscl_strchr</a> (<a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str, int32 c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga1107ef7fd1db4e1e4b75250625a0c454">oscl_strrchr</a> (const char *str, int32 c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gad2276b5abc9b4af25b09fb0b60730f58">oscl_strrchr</a> (char *str, int32 c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga3bdb5c4fa9fe0317156e238a3d97594e">oscl_strrchr</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str, int32 c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga406f262e3e587e389fb31b46beecd195">oscl_strrchr</a> (<a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str, int32 c)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaa33a556267a0619f456e4f2c2ee34e03">oscl_strset</a> (char *dest, char val, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gab6b31e6aed082d26e089c2cb32034a98">oscl_strset</a> (<a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *dest, <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> val, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gadee09c7a20c6adedd866948e300014f4">oscl_CIstrcmp</a> (const char *str1, const char *str2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gab30536ddedfb848781dd4570969a7b53">oscl_CIstrcmp</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str1, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga93ceefd80d819e0096361d543ee58af1">oscl_CIstrncmp</a> (const char *str1, const char *str2, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga644b3402319397b43dfec3392ac8ab47">oscl_CIstrncmp</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str1, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str2, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga07c241a9304ca88c49d816f0989b8f44">oscl_tolower</a> (const char car)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gadc65a229006403b77d89ebc1ef1ad951">oscl_tolower</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> car)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga342b76f918437c2c102f6be319c53070">oscl_isLetter</a> (const char car)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga5e178cf5663271a02a46dc3399219cfb">oscl_strstr</a> (const char *str1, const char *str2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gadc4c2b0f4da4fe223d0970f169f49ec6">oscl_strstr</a> (char *str1, const char *str2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gac506e504056be177354eda2b10f7ccac">oscl_strstr</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str1, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gab7d533d8649ec92303ac1103cdf9657a">oscl_strstr</a> (<a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str1, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *str2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga69b79637f0c04773d28d328682452fd2">oscl_strcat</a> (char *dest, const char *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gafe2b296f1f205e19f5763120eb637b46">oscl_strcat</a> (<a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *dest, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaf8168ec6b9c21c8e865b2aa298755545">PV8601ToRFC822</a> (<a class="el" href="group__osclbase.html#gad13c32c10063619e00563a850f87b86a">PV8601timeStrBuf</a> pv8601_buffer, <a class="el" href="group__osclbase.html#ga84d4ef38e5682881eb75ff4a64bc38b3">CtimeStrBuf</a> ctime_buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga1534c1d2b6f0d1a47339d6f83b7bbaff">ISO8601ToRFC822</a> (<a class="el" href="group__osclbase.html#ga83f7b514c3cbe5977e2916ca10e11869">ISO8601timeStrBuf</a> iso8601_buffer, <a class="el" href="group__osclbase.html#ga84d4ef38e5682881eb75ff4a64bc38b3">CtimeStrBuf</a> ctime_buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gab50d565fcef75fe4b35a2794a287c69b">RFC822ToPV8601</a> (<a class="el" href="group__osclbase.html#ga84d4ef38e5682881eb75ff4a64bc38b3">CtimeStrBuf</a> ctime_buffer, <a class="el" href="group__osclbase.html#gad13c32c10063619e00563a850f87b86a">PV8601timeStrBuf</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF <a class="el" href="classTimeValue.html">TimeValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga0160b519c243a5c4014441960c1a6513">operator-</a> (const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;a, const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF <a class="el" href="classTimeValue.html">TimeValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gac9801d8727210aa7b54eecb075928ddb">operator+</a> (const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;a, const int32 bSeconds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF <a class="el" href="classTimeValue.html">TimeValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaf95dddd28ac94a3f770ee5e21e3f651a">operator+</a> (const int32 aSeconds, const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF <a class="el" href="classTimeValue.html">TimeValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaad205c6ab5de6350a12169ad301ecb99">operator-</a> (const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;a, const int32 bSeconds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF <a class="el" href="classTimeValue.html">TimeValue</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga6149e8da543152f53ad88a79f4f407ee">operator-</a> (const int32 aSeconds, const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;b)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga0cc83fd35f446400713d1d9f3b2dd4c6">CTIME_BUFFER_SIZE</a> = 26</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga141a5fd80c38f29950e7b7d67d4867b1">PV8601TIME_BUFFER_SIZE</a> = 21</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga4469595fff8ac9560ee57d6d9d841063">ISO8601TIME_BUFFER_SIZE</a> = 21</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga47b0da9361952507ef28f0600d787aa4">USEC_PER_SEC</a> = 1000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga35f59c57e0e2b9e1b5eb78a8bed8160d">MSEC_PER_SEC</a> = 1000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga5ddea7a32bba8fc995966bc1dcc7a768">unix_ntp_offset</a> = 2208988800U</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gaf05abfcb99d7bb5fbd12a7e0c7c09896">OSCL_TLS_ID_MAGICNUM</a> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga8bff100b390508716ae12b5bf0412314">OSCL_TLS_ID_ERRORHOOK</a> = 1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga85fa72a03af9bc9e223676567cd80b80">OSCL_TLS_ID_PVLOGGER</a> = 2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gac1f0ea024ee0bc4eb7618fc97afb4fb3">OSCL_TLS_ID_TEST</a> = 3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga3b2de080edef7853c12aee984b8b7b87">OSCL_TLS_ID_PVSCHEDULER</a> = 4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga4cb20f79d59ec0ec4815d5da685b5d13">OSCL_TLS_ID_PVERRORTRAP</a> = 5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga969661abc3703a924f229b3381f619b8">OSCL_TLS_ID_SDPMEDIAPARSER</a> = 6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga22410997b5ef50aad7043a5f09970d0e">OSCL_TLS_ID_PAYLOADPARSER</a> = 7</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga7978d8f58faa5bb6f5518c87c9c40031">OSCL_TLS_ID_PVMFRECOGNIZER</a> = 8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#gab1a8e64f1f4762c8c0602ce17f3a5bff">OSCL_TLS_ID_WMDRM</a> = 9</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga08c2f3b8b4804ae19ae2e0969ce8b571">OSCL_TLS_ID_OSCLREGISTRY</a> = 10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga8e7abb2560ae4dd75467ab2e4259b931">OSCL_TLS_ID_SQLITE3</a> = 11</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclbase.html#ga0c23193ed013c5e4a67592281baf590d">OSCL_TLS_ID_BASE_LAST</a> = 11</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Additional osclbase comment </p>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga27169a7b4078321760bc56067f4d8669"></a><!-- doxytag: member="oscl_defalloc.h::ALLOC_AND_CONSTRUCT" ref="ga27169a7b4078321760bc56067f4d8669" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALLOC_AND_CONSTRUCT</td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;alloc_and_construct(n)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9a6a685a04fb90ece237939b8d56780b"></a><!-- doxytag: member="oscl_defalloc.h::ALLOCATE" ref="ga9a6a685a04fb90ece237939b8d56780b" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALLOCATE</td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;allocate(n)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1aaad20bf2402f23ad9d1634f57a5a32"></a><!-- doxytag: member="oscl_base_macros.h::EPV_ARM_GNUC" ref="ga1aaad20bf2402f23ad9d1634f57a5a32" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPV_ARM_GNUC&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3d0754c087c9fee64c81795b3000c8df"></a><!-- doxytag: member="oscl_base_macros.h::EPV_ARM_MSEVC" ref="ga3d0754c087c9fee64c81795b3000c8df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPV_ARM_MSEVC&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf269da83bd3aa18a95dd69ee1850029b"></a><!-- doxytag: member="oscl_base_macros.h::EPV_ARM_RVCT" ref="gaf269da83bd3aa18a95dd69ee1850029b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EPV_ARM_RVCT&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga070d2ce7b6bb7e5c05602aa8c308d0c4"></a><!-- doxytag: member="oscl_base_macros.h::NULL" ref="ga070d2ce7b6bb7e5c05602aa8c308d0c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NULL&nbsp;&nbsp;&nbsp;(0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The NULL_TERM_CHAR is used to terminate c-style strings. </p>
<p>if the NULL macro isn't already defined, then define it as zero. </p>

<p>Referenced by <a class="el" href="oscl__media__data_8h_source.html#l00196">BufFragGroup&lt; ChainClass, max_frags &gt;::AddFragment()</a>, <a class="el" href="oscl__media__data_8h_source.html#l00377">MediaData&lt; ChainClass, max_frags, local_bufsize &gt;::AddLocalFragment()</a>, <a class="el" href="oscl__defalloc_8h_source.html#l00146">Oscl_TAlloc&lt; node_type, Alloc &gt;::alloc_and_construct()</a>, <a class="el" href="oscl__mem_8h_source.html#l00847">OsclMemBasicAllocDestructDealloc&lt; T &gt;::allocate()</a>, <a class="el" href="oscl__mem_8h_source.html#l00813">OsclMemAllocDestructDealloc&lt; T &gt;::allocate()</a>, <a class="el" href="oscl__mem_8h_source.html#l00727">OsclMemAllocator::allocate()</a>, <a class="el" href="oscl__error__allocator_8h_source.html#l00064">OsclErrorAllocator::allocate()</a>, <a class="el" href="oscl__defalloc_8h_source.html#l00131">Oscl_TAlloc&lt; node_type, Alloc &gt;::allocate()</a>, <a class="el" href="oscl__shared__ptr_8h_source.html#l00149">OsclSharedPtr&lt; TheClass &gt;::Bind()</a>, <a class="el" href="oscl__error__allocator_8h_source.html#l00074">OsclErrorAllocator::deallocate()</a>, <a class="el" href="oscl__shared__ptr_8h_source.html#l00103">OsclSharedPtr&lt; TheClass &gt;::get_count()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l00868">OSCL_wHeapString&lt; Alloc &gt;::get_cstr()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l00860">OSCL_HeapString&lt; Alloc &gt;::get_cstr()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l00886">OSCL_wHeapString&lt; Alloc &gt;::get_str()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l00878">OSCL_HeapString&lt; Alloc &gt;::get_str()</a>, <a class="el" href="oscl__media__data_8h_source.html#l00256">BufFragGroup&lt; ChainClass, max_frags &gt;::GetBufferState()</a>, <a class="el" href="oscl__registry__client__impl_8h_source.html#l00066">OsclRegistryClientImpl::GetFactory()</a>, <a class="el" href="oscl__media__data_8h_source.html#l00244">BufFragGroup&lt; ChainClass, max_frags &gt;::GetFragment()</a>, <a class="el" href="oscl__media__data_8h_source.html#l00300">MediaData&lt; ChainClass, max_frags, local_bufsize &gt;::GetLocalFragment()</a>, <a class="el" href="oscl__media__data_8h_source.html#l00355">MediaData&lt; ChainClass, max_frags, local_bufsize &gt;::GetMediaFragment()</a>, <a class="el" href="oscl__tagtree_8h_source.html#l00402">Oscl_TagTree&lt; PVLogger *, alloc_type &gt;::insert()</a>, <a class="el" href="oscl__scheduler__aobase_8h_source.html#l00154">PVActiveBase::IsInAnyQ()</a>, <a class="el" href="oscl__media__data_8h_source.html#l00331">MediaData&lt; ChainClass, max_frags, local_bufsize &gt;::IsLocalData()</a>, <a class="el" href="oscl__linked__list_8h_source.html#l00051">LinkedListElement&lt; LLClass &gt;::LinkedListElement()</a>, <a class="el" href="oscl__double__list_8h_source.html#l00141">OsclDoubleRunner&lt; T &gt;::operator T *()</a>, <a class="el" href="oscl__double__list_8h_source.html#l00148">OsclDoubleRunner&lt; T &gt;::operator++()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l00910">OSCL_HeapString&lt; Alloc &gt;::OSCL_HeapString()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l01240">OSCL_StackString&lt; MaxBufSize &gt;::OSCL_StackString()</a>, <a class="el" href="oscl__tagtree_8h_source.html#l00291">Oscl_TagTree&lt; PVLogger *, alloc_type &gt;::Oscl_TagTree()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l00917">OSCL_wHeapString&lt; Alloc &gt;::OSCL_wHeapString()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l01247">OSCL_wStackString&lt; MaxBufSize &gt;::OSCL_wStackString()</a>, <a class="el" href="oscl__double__list_8h_source.html#l00127">OsclDoubleRunner&lt; T &gt;::OsclDoubleRunner()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00184">OsclMemStatsNode::OsclMemStatsNode()</a>, <a class="el" href="oscl__refcounter_8h_source.html#l00085">OsclRefCounterDA::OsclRefCounterDA()</a>, <a class="el" href="oscl__refcounter_8h_source.html#l00260">OsclRefCounterMTDA&lt; LockType &gt;::OsclRefCounterMTDA()</a>, <a class="el" href="oscl__refcounter_8h_source.html#l00353">OsclRefCounterMTSA&lt; DeallocType, LockType &gt;::OsclRefCounterMTSA()</a>, <a class="el" href="oscl__refcounter_8h_source.html#l00169">OsclRefCounterSA&lt; DeallocType &gt;::OsclRefCounterSA()</a>, <a class="el" href="oscl__socket__serv__imp__base_8h_source.html#l00025">OsclSocketServIBase::OsclSocketServIBase()</a>, <a class="el" href="oscl__error__trapcleanup_8h_source.html#l00040">OsclTrapStackItem::OsclTrapStackItem()</a>, <a class="el" href="oscl__exclusive__ptr_8h_source.html#l00427">OsclExclusivePtrA&lt; T, Alloc &gt;::release()</a>, <a class="el" href="oscl__exclusive__ptr_8h_source.html#l00288">OsclExclusiveArrayPtr&lt; T &gt;::release()</a>, <a class="el" href="oscl__exclusive__ptr_8h_source.html#l00149">OsclExclusivePtr&lt; T &gt;::release()</a>, <a class="el" href="oscl__socket__serv__imp__reqlist_8h_source.html#l00046">OsclSocketServRequestList::Remove()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l01293">OSCL_wStackString&lt; MaxBufSize &gt;::set()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l01287">OSCL_StackString&lt; MaxBufSize &gt;::set()</a>, <a class="el" href="oscl__exclusive__ptr_8h_source.html#l00440">OsclExclusivePtrA&lt; T, Alloc &gt;::set()</a>, <a class="el" href="oscl__exclusive__ptr_8h_source.html#l00301">OsclExclusiveArrayPtr&lt; T &gt;::set()</a>, <a class="el" href="oscl__exclusive__ptr_8h_source.html#l00162">OsclExclusivePtr&lt; T &gt;::set()</a>, <a class="el" href="oscl__scheduler__readyq_8h_source.html#l00152">TReadyQueLink::TReadyQueLink()</a>, <a class="el" href="oscl__shared__ptr_8h_source.html#l00115">OsclSharedPtr&lt; TheClass &gt;::Unbind()</a>, <a class="el" href="oscl__shared__ptr_8h_source.html#l00062">OsclSharedPtr&lt; TheClass &gt;::~OsclSharedPtr()</a>, and <a class="el" href="oscl__timer_8h_source.html#l00214">OsclTimer&lt; Alloc &gt;::~OsclTimer()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a5b28cd02cdf30b86facadca7c18a54"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_ABS" ref="ga5a5b28cd02cdf30b86facadca7c18a54" args="(a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_ABS</td>
          <td>(</td>
          <td class="paramtype">a&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((a) &gt; (0) ? (a) : -(a))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="oscl__timer_8h_source.html#l00329">OsclTimer&lt; Alloc &gt;::TimerBaseElapsed()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf7c21e5b6e4fee4247225dd31f89c8ca"></a><!-- doxytag: member="oscl_assert.h::OSCL_ASSERT" ref="gaf7c21e5b6e4fee4247225dd31f89c8ca" args="(_expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_ASSERT</td>
          <td>(</td>
          <td class="paramtype">_expr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((_expr)?((void)0):OSCL_Assert(# _expr,__FILE__,__LINE__))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="oscl__error__allocator_8h_source.html#l00064">OsclErrorAllocator::allocate()</a>, <a class="el" href="oscl__file__async__read_8h_source.html#l00122">OsclPtr::Append()</a>, <a class="el" href="oscl__queue_8h_source.html#l00250">Oscl_Queue&lt; T, Alloc &gt;::back()</a>, <a class="el" href="oscl__priqueue_8h_source.html#l00220">OsclPriorityQueue&lt; TOsclReady, OsclReadyAlloc, Oscl_Vector&lt; TOsclReady, OsclReadyAlloc &gt;, OsclTimerCompare &gt;::compare_EQ()</a>, <a class="el" href="oscl__priqueue_8h_source.html#l00212">OsclPriorityQueue&lt; TOsclReady, OsclReadyAlloc, Oscl_Vector&lt; TOsclReady, OsclReadyAlloc &gt;, OsclTimerCompare &gt;::compare_LT()</a>, <a class="el" href="oscl__error__allocator_8h_source.html#l00074">OsclErrorAllocator::deallocate()</a>, <a class="el" href="oscl__queue_8h_source.html#l00221">Oscl_Queue&lt; T, Alloc &gt;::front()</a>, <a class="el" href="oscl__error_8h_source.html#l00297">OsclTLSRegistryEx::getInstance()</a>, <a class="el" href="oscl__error_8h_source.html#l00158">OsclSingletonRegistryEx::getInstance()</a>, <a class="el" href="oscl__error__imp__jumps_8h_source.html#l00061">OsclJump::Jump()</a>, <a class="el" href="oscl__file__async__read_8h_source.html#l00073">OsclPtrC::Left()</a>, <a class="el" href="oscl__error_8h_source.html#l00199">OsclSingletonRegistryEx::lockAndGetInstance()</a>, <a class="el" href="oscl__refcounter_8h_source.html#l00085">OsclRefCounterDA::OsclRefCounterDA()</a>, <a class="el" href="oscl__refcounter_8h_source.html#l00260">OsclRefCounterMTDA&lt; LockType &gt;::OsclRefCounterMTDA()</a>, <a class="el" href="oscl__refcounter_8h_source.html#l00353">OsclRefCounterMTSA&lt; DeallocType, LockType &gt;::OsclRefCounterMTSA()</a>, <a class="el" href="oscl__refcounter_8h_source.html#l00169">OsclRefCounterSA&lt; DeallocType &gt;::OsclRefCounterSA()</a>, <a class="el" href="oscl__vector_8h_source.html#l00354">Oscl_Vector&lt; OsclNetworkAddress, OsclMemAllocator &gt;::pop_back()</a>, <a class="el" href="oscl__error_8h_source.html#l00314">OsclTLSRegistryEx::registerInstance()</a>, <a class="el" href="oscl__error_8h_source.html#l00176">OsclSingletonRegistryEx::registerInstance()</a>, <a class="el" href="oscl__error_8h_source.html#l00217">OsclSingletonRegistryEx::registerInstanceAndUnlock()</a>, <a class="el" href="oscl__file__async__read_8h_source.html#l00066">OsclPtrC::Right()</a>, <a class="el" href="oscl__file__async__read_8h_source.html#l00097">OsclPtr::SetLength()</a>, <a class="el" href="oscl__file__async__read_8h_source.html#l00040">OsclPtrC::SetLength()</a>, <a class="el" href="oscl__priqueue_8h_source.html#l00199">OsclPriorityQueue&lt; TOsclReady, OsclReadyAlloc, Oscl_Vector&lt; TOsclReady, OsclReadyAlloc &gt;, OsclTimerCompare &gt;::swap()</a>, <a class="el" href="oscl__error__imp__jumps_8h_source.html#l00075">OsclJump::Top()</a>, and <a class="el" href="oscl__error__imp__jumps_8h_source.html#l00081">OsclJump::~OsclJump()</a>.</p>

</div>
</div>
<a class="anchor" id="gae077275bef28134e570917ff468c8ff1"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_COND_EXPORT_REF" ref="gae077275bef28134e570917ff468c8ff1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_COND_EXPORT_REF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaead960804cd6ebf1d776c7d58159ce91"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_COND_IMPORT_REF" ref="gaead960804cd6ebf1d776c7d58159ce91" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_COND_IMPORT_REF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6f367c891edd99381c917e6dafeff544"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_CONST_CAST" ref="ga6f367c891edd99381c917e6dafeff544" args="(type, exp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_CONST_CAST</td>
          <td>(</td>
          <td class="paramtype">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exp&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((type)(exp))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type casting macros. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>Destination type of cast </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>exp</em>&nbsp;</td><td>Expression to cast </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52df9cd30fae914a27342a653bc56e37"></a><!-- doxytag: member="oscl_shared_ptr.h::OSCL_DISABLE_WARNING_RETURN_TYPE_NOT_UDT" ref="ga52df9cd30fae914a27342a653bc56e37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_RETURN_TYPE_NOT_UDT</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fcc278d0a7a8d1c95f95c3bd7067994"></a><!-- doxytag: member="oscl_tree.h::OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE" ref="ga9fcc278d0a7a8d1c95f95c3bd7067994" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fcc278d0a7a8d1c95f95c3bd7067994"></a><!-- doxytag: member="oscl_tagtree.h::OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE" ref="ga9fcc278d0a7a8d1c95f95c3bd7067994" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fcc278d0a7a8d1c95f95c3bd7067994"></a><!-- doxytag: member="oscl_map.h::OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE" ref="ga9fcc278d0a7a8d1c95f95c3bd7067994" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fcc278d0a7a8d1c95f95c3bd7067994"></a><!-- doxytag: member="oscl_defalloc.h::OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE" ref="ga9fcc278d0a7a8d1c95f95c3bd7067994" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7ea1d74d79ab801aa00cf7e4f5e2aef3"></a><!-- doxytag: member="oscl_dll.h::OSCL_DLL_ENTRY_POINT" ref="ga7ea1d74d79ab801aa00cf7e4f5e2aef3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DLL_ENTRY_POINT</td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;void oscl_dll_entry_point() {}</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DLL entry/exit point.</p>
<p>Allows you to define custom operations at the entry and exit of the DLL. Place this macro within one souce file for each DLL.</p>
<p>Functions with the custom commands for the DLL entry and exit point must also be defined. The entry point custom function is LocalDllEntry(), and the exit point custom function is LocalDllExit().</p>
<p>These functions will be called as a result of executing this macro.</p>
<p>Usage :</p>
<p>LocalDllEntry() { custom operations... }</p>
<p>LocalDllExit() { custom operations... }</p>
<p><a class="el" href="group__osclbase.html#ga7ea1d74d79ab801aa00cf7e4f5e2aef3">OSCL_DLL_ENTRY_POINT()</a> </p>

</div>
</div>
<a class="anchor" id="ga48b4fb2bd526d157e6197f4011bac7b9"></a><!-- doxytag: member="oscl_dll.h::OSCL_DLL_ENTRY_POINT_DEFAULT" ref="ga48b4fb2bd526d157e6197f4011bac7b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DLL_ENTRY_POINT_DEFAULT</td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default DLL entry/exit point function.</p>
<p>The body of the DLL entry point is given. The macro only needs to be declared within the source file.</p>
<p>Usage :</p>
<p><a class="el" href="group__osclbase.html#ga48b4fb2bd526d157e6197f4011bac7b9">OSCL_DLL_ENTRY_POINT_DEFAULT()</a> </p>

</div>
</div>
<a class="anchor" id="gabbc39f0338f358ef4df50a75373749d0"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_DYNAMIC_CAST" ref="gabbc39f0338f358ef4df50a75373749d0" args="(type, exp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DYNAMIC_CAST</td>
          <td>(</td>
          <td class="paramtype">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exp&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((type)(exp))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab00ad11c34612b99a7cee70e9c1fe9fd"></a><!-- doxytag: member="oscl_base.h::OSCL_HAS_SINGLETON_SUPPORT" ref="gab00ad11c34612b99a7cee70e9c1fe9fd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_HAS_SINGLETON_SUPPORT&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf9da29085597a032c4dd2f3ef4c1b9e6"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_INLINE" ref="gaf9da29085597a032c4dd2f3ef4c1b9e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_INLINE&nbsp;&nbsp;&nbsp;inline</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga30ee9dc0d74e3248228cc6a24c0295bb"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_MAX" ref="ga30ee9dc0d74e3248228cc6a24c0295bb" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_MAX</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((a) &gt; (b) ? (a) : (b))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="oscl__timer_8h_source.html#l00329">OsclTimer&lt; Alloc &gt;::TimerBaseElapsed()</a>.</p>

</div>
</div>
<a class="anchor" id="ga82593faa416c10b2f5c8cb542f61509c"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_MIN" ref="ga82593faa416c10b2f5c8cb542f61509c" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_MIN</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((a) &lt; (b) ? (a) : (b))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga02b042a816d2157bbed1792b26604cd8"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_REINTERPRET_CAST" ref="ga02b042a816d2157bbed1792b26604cd8" args="(type, exp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_REINTERPRET_CAST</td>
          <td>(</td>
          <td class="paramtype">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exp&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((type)(exp))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6872259ca6fd7080c6299210e4b13a6f"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_STATIC_CAST" ref="ga6872259ca6fd7080c6299210e4b13a6f" args="(type, exp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_STATIC_CAST</td>
          <td>(</td>
          <td class="paramtype">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">exp&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((type)(exp))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="oscl__defalloc_8h_source.html#l00146">Oscl_TAlloc&lt; node_type, Alloc &gt;::alloc_and_construct()</a>, <a class="el" href="oscl__defalloc_8h_source.html#l00139">Oscl_TAlloc&lt; node_type, Alloc &gt;::alloc_and_construct_fl()</a>, <a class="el" href="oscl__defalloc_8h_source.html#l00131">Oscl_TAlloc&lt; node_type, Alloc &gt;::allocate()</a>, <a class="el" href="oscl__defalloc_8h_source.html#l00125">Oscl_TAlloc&lt; node_type, Alloc &gt;::allocate_fl()</a>, <a class="el" href="oscl__dns__param_8h_source.html#l00096">GetHostByNameParam::canPersistMoreHostAddresses()</a>, <a class="el" href="oscl__defalloc_8h_source.html#l00166">Oscl_TAlloc&lt; node_type, Alloc &gt;::destruct_and_dealloc()</a>, <a class="el" href="oscl__tls_8h_source.html#l00135">OsclTLS&lt; T, ID, Registry &gt;::OsclTLS()</a>, <a class="el" href="oscl__dns__param_8h_source.html#l00085">GetHostByNameParam::PersistHostAddress()</a>, <a class="el" href="oscl__tls_8h_source.html#l00174">OsclTLS&lt; T, ID, Registry &gt;::set()</a>, <a class="el" href="oscl__error_8h_source.html#l00374">OsclTLSEx&lt; T, ID, Registry &gt;::set()</a>, and <a class="el" href="oscl__error_8h_source.html#l00277">OsclSingletonEx&lt; T, ID, Registry &gt;::set()</a>.</p>

</div>
</div>
<a class="anchor" id="gad264e63e3eaaeff06fc893f6dc24c7be"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_BASE_SLOTS" ref="gad264e63e3eaaeff06fc893f6dc24c7be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_TLS_BASE_SLOTS&nbsp;&nbsp;&nbsp;<a class="el" href="group__osclbase.html#ga0c23193ed013c5e4a67592281baf590d">OSCL_TLS_ID_BASE_LAST</a> +1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab87cbf8399e2eab2a9f4de8e70c50815"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_MAX_SLOTS" ref="gab87cbf8399e2eab2a9f4de8e70c50815" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_TLS_MAX_SLOTS&nbsp;&nbsp;&nbsp;( OSCL_TLS_BASE_SLOTS + OSCL_TLS_EXTERNAL_SLOTS)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0ac3a7c93a978fa6d04c2a5d810612dd"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_UNUSED_ARG" ref="ga0ac3a7c93a978fa6d04c2a5d810612dd" args="(vbl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_UNUSED_ARG</td>
          <td>(</td>
          <td class="paramtype">vbl&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(void)(vbl)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The following two macros are used to avoid compiler warnings.</p>
<p><a class="el" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG(vbl)</a> is used to "reference" an otherwise unused parameter or variable, often one which is used only in an OSCL_ASSERT and thus unreferenced in release mode <a class="el" href="group__osclbase.html#ga06bf2e405c0ab3a123fa20acc804dd3f">OSCL_UNUSED_RETURN(val)</a> provides a "return" of a value, in places which will not actually be executed, such as after an OSCL_LEAVE or Thread::exit or abort. The value needs to be of an appropriate type for the current function, though zero will usually suffice. Note that OSCL_UNUSED_RETURN will not be necessary for 'void' functions, as there is no requirement for a value-return operation. </p>

<p>Referenced by <a class="el" href="pvlogger_8h_source.html#l00467">PVLogger::AddAppender()</a>, <a class="el" href="pvlogger_8h_source.html#l00514">PVLogger::AddFilter()</a>, <a class="el" href="oscl__defalloc_8h_source.html#l00085">Oscl_DefAlloc::allocate_fl()</a>, <a class="el" href="oscl__defalloc_8h_source.html#l00059">Oscl_Alloc::allocate_fl()</a>, <a class="el" href="oscl__defalloc_8h_source.html#l00160">Oscl_TAlloc&lt; node_type, Alloc &gt;::deallocate()</a>, <a class="el" href="oscl__defalloc_8h_source.html#l00185">Oscl_TAlloc&lt; node_type, Alloc &gt;::destroy()</a>, <a class="el" href="oscl__mem_8h_source.html#l00859">OsclMemBasicAllocDestructDealloc&lt; T &gt;::destruct_and_dealloc()</a>, <a class="el" href="oscl__mem_8h_source.html#l00829">OsclMemAllocDestructDealloc&lt; T &gt;::destruct_and_dealloc()</a>, <a class="el" href="pvlogger__accessories_8h_source.html#l00085">AllPassFilter::FilterOpaqueMessge()</a>, <a class="el" href="pvlogger__accessories_8h_source.html#l00078">AllPassFilter::FilterString()</a>, <a class="el" href="oscl__error__allocator_8h_source.html#l00088">OsclErrorAllocator::operator delete()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00353">MM_AllocNode::operator new()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00308">MM_AllocInfo::operator new()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00244">MM_Stats_CB::operator new()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00205">OsclMemStatsNode::operator new()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00146">MM_FailInsertParam::operator new()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00102">MM_Stats_t::operator new()</a>, <a class="el" href="oscl__error__allocator_8h_source.html#l00081">OsclErrorAllocator::operator new()</a>, <a class="el" href="oscl__mem_8h_source.html#l00941">HeapBase::operator new[]()</a>, <a class="el" href="pvlogger_8h_source.html#l00485">PVLogger::RemoveAppender()</a>, <a class="el" href="pvlogger_8h_source.html#l00410">PVLogger::SetLogLevel()</a>, and <a class="el" href="oscl__file__async__read_8h_source.html#l00304">OsclAsyncFile::Write()</a>.</p>

</div>
</div>
<a class="anchor" id="ga06bf2e405c0ab3a123fa20acc804dd3f"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_UNUSED_RETURN" ref="ga06bf2e405c0ab3a123fa20acc804dd3f" args="(value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_UNUSED_RETURN</td>
          <td>(</td>
          <td class="paramtype">value&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;return value</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4fd9dfc2eae26696c83cfba1fbc73448"></a><!-- doxytag: member="oscl_base_macros.h::OSCL_VIRTUAL_BASE" ref="ga4fd9dfc2eae26696c83cfba1fbc73448" args="(type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_VIRTUAL_BASE</td>
          <td>(</td>
          <td class="paramtype">type&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;type</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac0ae3f33e28f7852bd4ece979255a0f4"></a><!-- doxytag: member="oscl_mem_inst.h::PVMEM_INST_LEVEL" ref="gac0ae3f33e28f7852bd4ece979255a0f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PVMEM_INST_LEVEL&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gab5ed9ea532eb401f23c866e4d55ee72e"></a><!-- doxytag: member="oscl_types.h::c_bool" ref="gab5ed9ea532eb401f23c866e4d55ee72e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="group__osclbase.html#gab5ed9ea532eb401f23c866e4d55ee72e">c_bool</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The c_bool type is mapped to an integer to provide a bool type for C interfaces. </p>

</div>
</div>
<a class="anchor" id="ga84d4ef38e5682881eb75ff4a64bc38b3"></a><!-- doxytag: member="oscl_time.h::CtimeStrBuf" ref="ga84d4ef38e5682881eb75ff4a64bc38b3" args="[CTIME_BUFFER_SIZE]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="group__osclbase.html#ga84d4ef38e5682881eb75ff4a64bc38b3">CtimeStrBuf</a>[<a class="el" href="group__osclbase.html#ga0cc83fd35f446400713d1d9f3b2dd4c6">CTIME_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad3ba4095e745890683ed3aa53c47384d"></a><!-- doxytag: member="oscl_types.h::int64" ref="gad3ba4095e745890683ed3aa53c47384d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef OSCL_NATIVE_INT64_TYPE <a class="el" href="group__osclbase.html#gad3ba4095e745890683ed3aa53c47384d">int64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga83f7b514c3cbe5977e2916ca10e11869"></a><!-- doxytag: member="oscl_time.h::ISO8601timeStrBuf" ref="ga83f7b514c3cbe5977e2916ca10e11869" args="[ISO8601TIME_BUFFER_SIZE]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="group__osclbase.html#ga83f7b514c3cbe5977e2916ca10e11869">ISO8601timeStrBuf</a>[<a class="el" href="group__osclbase.html#ga4469595fff8ac9560ee57d6d9d841063">ISO8601TIME_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf70fa576f0c9e5b026dfe82518c11b1e"></a><!-- doxytag: member="oscl_types.h::mbchar" ref="gaf70fa576f0c9e5b026dfe82518c11b1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="group__osclbase.html#gaf70fa576f0c9e5b026dfe82518c11b1e">mbchar</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>mbchar is multi-byte char (e.g., UTF-8) with null termination. </p>

</div>
</div>
<a class="anchor" id="gadc554e3aa0719a67a3c4b61c252e564c"></a><!-- doxytag: member="oscl_types.h::octet" ref="gadc554e3aa0719a67a3c4b61c252e564c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8 <a class="el" href="group__osclbase.html#gadc554e3aa0719a67a3c4b61c252e564c">octet</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The octet type is meant to be used for referring to a byte or collection bytes without suggesting anything about the underlying meaning of the bytes. </p>

</div>
</div>
<a class="anchor" id="gad21ec41919dd47678bcbc107ace687c9"></a><!-- doxytag: member="oscl_types.h::OSCL_TCHAR" ref="gad21ec41919dd47678bcbc107ace687c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> <a class="el" href="group__osclbase.html#gad21ec41919dd47678bcbc107ace687c9">OSCL_TCHAR</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>define OSCL_TCHAR </p>

</div>
</div>
<a class="anchor" id="gad3f9ec9db55ebd4760c877b17eb596ec"></a><!-- doxytag: member="oscl_types.h::oscl_wchar" ref="gad3f9ec9db55ebd4760c877b17eb596ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef OSCL_NATIVE_WCHAR_TYPE <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3bac54662348f5e6c08b97ca97066b89"></a><!-- doxytag: member="oscl_types.h::OsclAny" ref="ga3bac54662348f5e6c08b97ca97066b89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="group__osclbase.html#ga3bac54662348f5e6c08b97ca97066b89">OsclAny</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The OsclAny is meant to be used the context of a generic pointer (i.e., no specific type). </p>

</div>
</div>
<a class="anchor" id="gac5984c186a54bb7f5bd71246413166cf"></a><!-- doxytag: member="oscl_types.h::OsclFloat" ref="gac5984c186a54bb7f5bd71246413166cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float <a class="el" href="group__osclbase.html#gac5984c186a54bb7f5bd71246413166cf">OsclFloat</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Float type defined as OsclFloat. </p>

</div>
</div>
<a class="anchor" id="ga13a226153f56d45b50a162260dcd0e38"></a><!-- doxytag: member="oscl_types.h::OsclSizeT" ref="ga13a226153f56d45b50a162260dcd0e38" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="group__osclbase.html#ga13a226153f56d45b50a162260dcd0e38">OsclSizeT</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad13c32c10063619e00563a850f87b86a"></a><!-- doxytag: member="oscl_time.h::PV8601timeStrBuf" ref="gad13c32c10063619e00563a850f87b86a" args="[PV8601TIME_BUFFER_SIZE]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef char <a class="el" href="group__osclbase.html#gad13c32c10063619e00563a850f87b86a">PV8601timeStrBuf</a>[<a class="el" href="group__osclbase.html#ga141a5fd80c38f29950e7b7d67d4867b1">PV8601TIME_BUFFER_SIZE</a>]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga723fadcc6e6137090da5371f44113941"></a><!-- doxytag: member="oscl_tls.h::TOsclTlsKey" ref="ga723fadcc6e6137090da5371f44113941" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__osclbase.html#ga3bac54662348f5e6c08b97ca97066b89">OsclAny</a> <a class="el" href="group__osclbase.html#ga723fadcc6e6137090da5371f44113941">TOsclTlsKey</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga91ad9478d81a7aaf2593e8d9c3d06a14"></a><!-- doxytag: member="oscl_types.h::uint" ref="ga91ad9478d81a7aaf2593e8d9c3d06a14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="group__osclbase.html#ga91ad9478d81a7aaf2593e8d9c3d06a14">uint</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The uint type is a convenient abbreviation for unsigned int. </p>

</div>
</div>
<a class="anchor" id="gaeee93fd1c6230965ea7adc3e63fac06e"></a><!-- doxytag: member="oscl_types.h::uint64" ref="gaeee93fd1c6230965ea7adc3e63fac06e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef OSCL_NATIVE_UINT64_TYPE <a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga0423d00e0eb199de523a92031b5a1107"></a><!-- doxytag: member="oscl_time.h::TimeUnits" ref="ga0423d00e0eb199de523a92031b5a1107" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__osclbase.html#ga0423d00e0eb199de523a92031b5a1107">TimeUnits</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The TimeUnits enum can be used when constructing a <a class="el" href="classTimeValue.html" title="The TimeValue class represents a time value in a format native to the system.">TimeValue</a> class. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga0423d00e0eb199de523a92031b5a1107a70367ff8e866216e6a822a2c952abfc1"></a><!-- doxytag: member="SECONDS" ref="gga0423d00e0eb199de523a92031b5a1107a70367ff8e866216e6a822a2c952abfc1" args="" -->SECONDS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0423d00e0eb199de523a92031b5a1107a1043c5211bc8c40b382a93bd238c9131"></a><!-- doxytag: member="MILLISECONDS" ref="gga0423d00e0eb199de523a92031b5a1107a1043c5211bc8c40b382a93bd238c9131" args="" -->MILLISECONDS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0423d00e0eb199de523a92031b5a1107ac9db1eab6da2865d20c916504baedc90"></a><!-- doxytag: member="MICROSECONDS" ref="gga0423d00e0eb199de523a92031b5a1107ac9db1eab6da2865d20c916504baedc90" args="" -->MICROSECONDS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga97188d2c6248adc3fef36f483696a332"></a><!-- doxytag: member="oscl_assert.h::_OSCL_Abort" ref="ga97188d2c6248adc3fef36f483696a332" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF void _OSCL_Abort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function terminates the current process abnormally. </p>

<p>Referenced by <a class="el" href="oscl__error__imp__jumps_8h_source.html#l00061">OsclJump::Jump()</a>.</p>

</div>
</div>
<a class="anchor" id="ga80781fa5b4da418f911f58732644f067"></a><!-- doxytag: member="oscl_byte_order.h::big_endian_to_host" ref="ga80781fa5b4da418f911f58732644f067" args="(char *data, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void big_endian_to_host </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert big endian to host format. </p>
<p>This function takes a buffer of data which is assumed to be in big endian order and rearranges it to the native order of the machine running the code. If the machine is a big endian machine, nothing is done. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to the input/output buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The number of bytes in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f4eb250bf055b9f0b3210d99ae4c33f"></a><!-- doxytag: member="OsclSharedPtr::Bind" ref="ga0f4eb250bf055b9f0b3210d99ae4c33f" args="(TheClass *ptr, OsclRefCounter *in_refcnt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::Bind </td>
          <td>(</td>
          <td class="paramtype">TheClass *&nbsp;</td>
          <td class="paramname"> <em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOsclRefCounter.html">OsclRefCounter</a> *&nbsp;</td>
          <td class="paramname"> <em>in_refcnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this function to bind an existing <a class="el" href="classOsclSharedPtr.html" title="A parameterized smart pointer class.">OsclSharedPtr</a> to a new (unwrapped) object. </p>

<p>References <a class="el" href="oscl__base__macros_8h_source.html#l00042">NULL</a>, and <a class="el" href="classOsclRefCounter.html#aa7b138fd57f149a575356e51ee2d4451">OsclRefCounter::removeRef()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1d0584bc00294d8a38ed327de540dbb9"></a><!-- doxytag: member="OsclSharedPtr::Bind" ref="ga1d0584bc00294d8a38ed327de540dbb9" args="(const OsclSharedPtr &amp;inHandle)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::Bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>inHandle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this function to bind an existing <a class="el" href="classOsclSharedPtr.html" title="A parameterized smart pointer class.">OsclSharedPtr</a> to a already-wrapped object. </p>

<p>References <a class="el" href="classOsclRefCounter.html#a36656788a3ab2b554bc7e917bf6a4adb">OsclRefCounter::addRef()</a>, <a class="el" href="oscl__base__macros_8h_source.html#l00042">NULL</a>, and <a class="el" href="classOsclRefCounter.html#aa7b138fd57f149a575356e51ee2d4451">OsclRefCounter::removeRef()</a>.</p>

<p>Referenced by <a class="el" href="oscl__shared__ptr_8h_source.html#l00121">OsclSharedPtr&lt; TheClass &gt;::operator=()</a>, and <a class="el" href="oscl__shared__ptr_8h_source.html#l00115">OsclSharedPtr&lt; TheClass &gt;::Unbind()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa2a06a6f82c42db5f18491805937508b"></a><!-- doxytag: member="OsclSharedPtr::get_count" ref="gaa2a06a6f82c42db5f18491805937508b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::get_count </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a count of how many references to the object exist. </p>

<p>References <a class="el" href="classOsclRefCounter.html#a647a4b140b695ad7f8e68e41cb3cc137">OsclRefCounter::getCount()</a>, and <a class="el" href="oscl__base__macros_8h_source.html#l00042">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="ga8de7359219d8c3c7991b0207b88a119f"></a><!-- doxytag: member="OsclSharedPtr::GetRefCounter" ref="ga8de7359219d8c3c7991b0207b88a119f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOsclRefCounter.html">OsclRefCounter</a>* <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::GetRefCounter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the refcount pointer. This should primarily be used for conversion operations. </p>

</div>
</div>
<a class="anchor" id="ga16e5b2c74486acf9d5721e47dbeaa8d6"></a><!-- doxytag: member="OsclSharedPtr::GetRep" ref="ga16e5b2c74486acf9d5721e47dbeaa8d6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TheClass* <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::GetRep </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this function to get a pointer to the wrapped object. </p>

<p>Referenced by <a class="el" href="pvlogger_8h_source.html#l00485">PVLogger::RemoveAppender()</a>.</p>

</div>
</div>
<a class="anchor" id="gadb579872de1387b02fe73bc4fc0a576c"></a><!-- doxytag: member="oscl_byte_order.h::host_to_big_endian" ref="gadb579872de1387b02fe73bc4fc0a576c" args="(char *data, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void host_to_big_endian </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert host to big endian format. </p>
<p>This function takes a buffer of data which is assumed to be in native host order and rearranges it to big endian format. If the machine is a big endian machine, nothing is done. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to the input/output buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The number of bytes in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3b010bdaf14e002a769b87df7efa9a0d"></a><!-- doxytag: member="oscl_byte_order.h::host_to_little_endian" ref="ga3b010bdaf14e002a769b87df7efa9a0d" args="(char *data, unsigned int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void host_to_little_endian </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert host to little endian format. </p>
<p>This function takes a buffer of data which is assumed to be in the host's native order and rearranges it to the little endian format. If the machine is a little endian machine, nothing is done. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to the input/output buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The number of bytes in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1534c1d2b6f0d1a47339d6f83b7bbaff"></a><!-- doxytag: member="oscl_time.h::ISO8601ToRFC822" ref="ga1534c1d2b6f0d1a47339d6f83b7bbaff" args="(ISO8601timeStrBuf iso8601_buffer, CtimeStrBuf ctime_buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void ISO8601ToRFC822 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#ga83f7b514c3cbe5977e2916ca10e11869">ISO8601timeStrBuf</a>&nbsp;</td>
          <td class="paramname"> <em>iso8601_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#ga84d4ef38e5682881eb75ff4a64bc38b3">CtimeStrBuf</a>&nbsp;</td>
          <td class="paramname"> <em>ctime_buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9d0c1c30ed9dc653b7e143689802048d"></a><!-- doxytag: member="oscl_byte_order.h::little_endian_to_host" ref="ga9d0c1c30ed9dc653b7e143689802048d" args="(char *data, uint32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void little_endian_to_host </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert little endian to host format. </p>
<p>This function takes a buffer of data which is assumed to be in little endian order and rearranges it to the native order of the machine running the code. If the machine is a little endian machine, nothing is done. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to the input/output buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The number of bytes in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15eac54f31b6df7fe5df004141ae7f43"></a><!-- doxytag: member="OsclSharedPtr::operator TheClass *" ref="ga15eac54f31b6df7fe5df004141ae7f43" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::operator TheClass * </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Casting operator. </p>

</div>
</div>
<a class="anchor" id="gae933e3a791eedeb012c163d749ed814d"></a><!-- doxytag: member="OsclSharedPtr::operator*" ref="gae933e3a791eedeb012c163d749ed814d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TheClass&amp; <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The indirection operator returns a reference to an object of the parameterized type. </p>

</div>
</div>
<a class="anchor" id="gaf95dddd28ac94a3f770ee5e21e3f651a"></a><!-- doxytag: member="oscl_time.h::operator+" ref="gaf95dddd28ac94a3f770ee5e21e3f651a" args="(const int32 aSeconds, const TimeValue &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF <a class="el" href="classTimeValue.html">TimeValue</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const int32&nbsp;</td>
          <td class="paramname"> <em>aSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac9801d8727210aa7b54eecb075928ddb"></a><!-- doxytag: member="oscl_time.h::operator+" ref="gac9801d8727210aa7b54eecb075928ddb" args="(const TimeValue &amp;a, const int32 bSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF <a class="el" href="classTimeValue.html">TimeValue</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32&nbsp;</td>
          <td class="paramname"> <em>bSeconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6149e8da543152f53ad88a79f4f407ee"></a><!-- doxytag: member="oscl_time.h::operator&#45;" ref="ga6149e8da543152f53ad88a79f4f407ee" args="(const int32 aSeconds, const TimeValue &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF <a class="el" href="classTimeValue.html">TimeValue</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const int32&nbsp;</td>
          <td class="paramname"> <em>aSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaad205c6ab5de6350a12169ad301ecb99"></a><!-- doxytag: member="oscl_time.h::operator&#45;" ref="gaad205c6ab5de6350a12169ad301ecb99" args="(const TimeValue &amp;a, const int32 bSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF <a class="el" href="classTimeValue.html">TimeValue</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32&nbsp;</td>
          <td class="paramname"> <em>bSeconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0160b519c243a5c4014441960c1a6513"></a><!-- doxytag: member="oscl_time.h::operator&#45;" ref="ga0160b519c243a5c4014441960c1a6513" args="(const TimeValue &amp;a, const TimeValue &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF <a class="el" href="classTimeValue.html">TimeValue</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimeValue.html">TimeValue</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9172a5f5333a2f3cd5b0666e4ca8f7d6"></a><!-- doxytag: member="OsclSharedPtr::operator&#45;&gt;" ref="ga9172a5f5333a2f3cd5b0666e4ca8f7d6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TheClass* <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The dereferencing operator returns a pointer to the parameterized type and can be used to access member elements of TheClass. </p>

</div>
</div>
<a class="anchor" id="ga10da41094264a26676f267f45a7e550a"></a><!-- doxytag: member="OsclSharedPtr::operator=" ref="ga10da41094264a26676f267f45a7e550a" args="(const OsclSharedPtr &amp;inSharedPtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&amp; <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>inSharedPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>

<p>References <a class="el" href="oscl__shared__ptr_8h_source.html#l00149">OsclSharedPtr&lt; TheClass &gt;::Bind()</a>.</p>

</div>
</div>
<a class="anchor" id="ga948093bfeedab10a96d8fda172a85250"></a><!-- doxytag: member="OsclSharedPtr::operator==" ref="ga948093bfeedab10a96d8fda172a85250" args="(const OsclSharedPtr &amp;b) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Test for equality to see if two PVHandles wrap the same object. </p>

</div>
</div>
<a class="anchor" id="ga89f94c4160d32bcfc94fc215239ec5c7"></a><!-- doxytag: member="oscl_assert.h::OSCL_Assert" ref="ga89f94c4160d32bcfc94fc215239ec5c7" args="(const char *expr, const char *filename, int line_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OSCL_Assert </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>line_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>OSCL_ASSERT macro evaluates an expression and when the result is false, prints a diagnostic message and aborts the program. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expr</em>&nbsp;</td><td>is the expression to be evaluated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>is the name of the current source file </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>line_number</em>&nbsp;</td><td>is the line number in the current source file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab30536ddedfb848781dd4570969a7b53"></a><!-- doxytag: member="oscl_stdstring.h::oscl_CIstrcmp" ref="gab30536ddedfb848781dd4570969a7b53" args="(const oscl_wchar *str1, const oscl_wchar *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 oscl_CIstrcmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Case in-sensitive string comparision.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>string to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>string to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Negative if str1 &lt; str2 Positive if str1 &gt; str2 Zero if equal </dd></dl>

</div>
</div>
<a class="anchor" id="gadee09c7a20c6adedd866948e300014f4"></a><!-- doxytag: member="oscl_stdstring.h::oscl_CIstrcmp" ref="gadee09c7a20c6adedd866948e300014f4" args="(const char *str1, const char *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 oscl_CIstrcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Case in-sensitive string comparision.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>string to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>string to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Negative if str1 &lt; str2 Positive if str1 &gt; str2 Zero if equal </dd></dl>

</div>
</div>
<a class="anchor" id="ga644b3402319397b43dfec3392ac8ab47"></a><!-- doxytag: member="oscl_stdstring.h::oscl_CIstrncmp" ref="ga644b3402319397b43dfec3392ac8ab47" args="(const oscl_wchar *str1, const oscl_wchar *str2, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 oscl_CIstrncmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compares(case in-sensitive), at most, the first count characters in str1 and str2 and returns a value indicating the relationship between the substrings.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>string to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>string to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of characters to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Negative if str1 &lt; str2 Positive if str1 &gt; str2 Zero if equal </dd></dl>

</div>
</div>
<a class="anchor" id="ga93ceefd80d819e0096361d543ee58af1"></a><!-- doxytag: member="oscl_stdstring.h::oscl_CIstrncmp" ref="ga93ceefd80d819e0096361d543ee58af1" args="(const char *str1, const char *str2, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 oscl_CIstrncmp </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compares(case in-sensitive), at most, the first count characters in str1 and str2 and returns a value indicating the relationship between the substrings.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>string to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>string to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of characters to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Negative if str1 &lt; str2 Positive if str1 &gt; str2 Zero if equal </dd></dl>

</div>
</div>
<a class="anchor" id="ga342b76f918437c2c102f6be319c53070"></a><!-- doxytag: member="oscl_stdstring.h::oscl_isLetter" ref="ga342b76f918437c2c102f6be319c53070" args="(const char car)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF bool oscl_isLetter </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>car</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>check if supplied parameter is an alphabet (ASCII only).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>car</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>1 if car is an alphabet 0 if car is not an alphabet. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe2b296f1f205e19f5763120eb637b46"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strcat" ref="gafe2b296f1f205e19f5763120eb637b46" args="(oscl_wchar *dest, const oscl_wchar *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>* oscl_strcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Appends up to count characters from string src to string dest, and then appends a terminating null character. The initial character of src overwrites the null character at the end of dest. Subsequent characters in src are appended to dest until either the end of src is reached or count characters have been copied. If copying takes place between objects that overlap, the behavior is undefined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>null terminated destination string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of characters to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dest </dd></dl>

</div>
</div>
<a class="anchor" id="ga69b79637f0c04773d28d328682452fd2"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strcat" ref="ga69b79637f0c04773d28d328682452fd2" args="(char *dest, const char *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF char* oscl_strcat </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Appends string src to string dest, and then appends a terminating null character. The initial character of src overwrites the null character at the end of dest. Subsequent characters in src are appended to dest until the end of src is reached. If copying takes place between objects that overlap, the behavior is undefined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>null terminated destination string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>source string</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dest </dd></dl>

</div>
</div>
<a class="anchor" id="ga2f9d4ee2409b1be4a7be89a7d19a2c9a"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strchr" ref="ga2f9d4ee2409b1be4a7be89a7d19a2c9a" args="(oscl_wchar *str, int32 c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>* oscl_strchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga82b93e86712d1e428280ae2876d3bcde"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strchr" ref="ga82b93e86712d1e428280ae2876d3bcde" args="(const oscl_wchar *str, int32 c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>* oscl_strchr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the first occurrence of c in string, or it returns NULL if c is not found. The null-terminating character is included in the search.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>null terminated source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>character to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ga0de98675f3aef3865fb37a3b1bbe3763"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strchr" ref="ga0de98675f3aef3865fb37a3b1bbe3763" args="(char *str, int32 c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF char* oscl_strchr </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7f0d3c6aaa3e65089c6309770c40a138"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strchr" ref="ga7f0d3c6aaa3e65089c6309770c40a138" args="(const char *str, int32 c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF const char* oscl_strchr </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the first occurrence of c in string, or it returns NULL if c is not found. The null-terminating character is included in the search.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>null terminated source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>character to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gadf5ff51dd5a58a590fa4b27038160a10"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strcmp" ref="gadf5ff51dd5a58a590fa4b27038160a10" args="(const oscl_wchar *str1, const oscl_wchar *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 oscl_strcmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compares two NULL terminated strings, str1 and str2, and returns a value indicating the relationship between them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>String to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>String to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Negative if str1 &lt; str2 Positive if str1 &gt; str2 Zero if equal </dd></dl>

</div>
</div>
<a class="anchor" id="ga15ec89685a75ae571d1102641a0c95e6"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strcmp" ref="ga15ec89685a75ae571d1102641a0c95e6" args="(const char *str1, const char *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 oscl_strcmp </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compares two NULL terminated strings, str1 and str2, and returns a value indicating the relationship between them.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>String to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>String to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Negative if str1 &lt; str2 Positive if str1 &gt; str2 Zero if equal </dd></dl>

<p>Referenced by <a class="el" href="oscl__dns__param_8h_source.html#l00096">GetHostByNameParam::canPersistMoreHostAddresses()</a>, <a class="el" href="oscl__socket__types_8h_source.html#l00143">OsclNetworkAddress::operator==()</a>, and <a class="el" href="oscl__dns__param_8h_source.html#l00085">GetHostByNameParam::PersistHostAddress()</a>.</p>

</div>
</div>
<a class="anchor" id="gadbc6ee7456522d3705ed148ec838c121"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strlen" ref="gadbc6ee7456522d3705ed148ec838c121" args="(const oscl_wchar *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF uint32 oscl_strlen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the length of a wide char string</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>NULL terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of characters in string, excluding the terminal NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a69d1e37d0d89889020234ddab938a1"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strlen" ref="ga7a69d1e37d0d89889020234ddab938a1" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF uint32 oscl_strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the length of a string</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>NULL terminated string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of characters in string, excluding the terminal NULL. </dd></dl>

<p>Referenced by <a class="el" href="oscl__str__ptr__len_8h_source.html#l00252">WStrPtrLen::operator=()</a>, <a class="el" href="oscl__str__ptr__len_8h_source.html#l00153">StrPtrLen::operator=()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l01278">OSCL_wStackString&lt; MaxBufSize &gt;::set()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l01270">OSCL_StackString&lt; MaxBufSize &gt;::set()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l00950">OSCL_wHeapString&lt; Alloc &gt;::set()</a>, <a class="el" href="oscl__string__containers_8h_source.html#l00942">OSCL_HeapString&lt; Alloc &gt;::set()</a>, <a class="el" href="oscl__str__ptr__len_8h_source.html#l00060">StrPtrLen::StrPtrLen()</a>, <a class="el" href="oscl__tagtree_8h_source.html#l00059">Oscl_Tag_Base::tag_cmp()</a>, <a class="el" href="oscl__tagtree_8h_source.html#l00055">Oscl_Tag_Base::tag_copy()</a>, <a class="el" href="oscl__tagtree_8h_source.html#l00051">Oscl_Tag_Base::tag_len()</a>, and <a class="el" href="oscl__str__ptr__len_8h_source.html#l00174">WStrPtrLen::WStrPtrLen()</a>.</p>

</div>
</div>
<a class="anchor" id="ga10686c6102c0e0fa6ceaa54c009fde66"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strncat" ref="ga10686c6102c0e0fa6ceaa54c009fde66" args="(oscl_wchar *dest, const oscl_wchar *src, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>* oscl_strncat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Appends up to count characters from string src to string dest, and then appends a terminating null character. The initial character of src overwrites the null character at the end of dest. Subsequent characters in src are appended to dest until either the end of src is reached or count characters have been copied. If copying takes place between objects that overlap, the behavior is undefined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>null terminated destination string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of characters to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dest </dd></dl>

</div>
</div>
<a class="anchor" id="ga0f3176335ffe1ea119cbda2f5976263f"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strncat" ref="ga0f3176335ffe1ea119cbda2f5976263f" args="(char *dest, const char *src, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF char* oscl_strncat </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Appends up to count characters from string src to string dest, and then appends a terminating null character. The initial character of src overwrites the null character at the end of dest. Subsequent characters in src are appended to dest until either the end of src is reached or count characters have been copied. If copying takes place between objects that overlap, the behavior is undefined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>null terminated destination string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of characters to append.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>dest </dd></dl>

</div>
</div>
<a class="anchor" id="ga003f8210120c6ca4e7e3574320bdb807"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strncmp" ref="ga003f8210120c6ca4e7e3574320bdb807" args="(const oscl_wchar *str1, const oscl_wchar *str2, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 oscl_strncmp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compares, at most, the first count characters in str1 and str2 and returns a value indicating the relationship between the substrings.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>String to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>String to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of characters to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Negative if str1 &lt; str2 Positive if str1 &gt; str2 Zero if equal </dd></dl>

</div>
</div>
<a class="anchor" id="gae20b63524fe9c0eecff8e2b64f142dfc"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strncmp" ref="gae20b63524fe9c0eecff8e2b64f142dfc" args="(const char *str1, const char *str2, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 oscl_strncmp </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lexicographically compares, at most, the first count characters in str1 and str2 and returns a value indicating the relationship between the substrings.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>String to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>String to compare </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of characters to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Negative if str1 &lt; str2 Positive if str1 &gt; str2 Zero if equal </dd></dl>

<p>Referenced by <a class="el" href="oscl__str__ptr__len_8h_source.html#l00231">WStrPtrLen::operator==()</a>, <a class="el" href="oscl__str__ptr__len_8h_source.html#l00130">StrPtrLen::operator==()</a>, and <a class="el" href="oscl__tagtree_8h_source.html#l00059">Oscl_Tag_Base::tag_cmp()</a>.</p>

</div>
</div>
<a class="anchor" id="ga78b42e99bf97f8dadb936a406cfd9cf1"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strncpy" ref="ga78b42e99bf97f8dadb936a406cfd9cf1" args="(oscl_wchar *dest, const oscl_wchar *src, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>* oscl_strncpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies the chars of one string to another.</p>
<p>Copies the initial count characters of src to dest and returns dest. If count is less than or equal to the length of src, a null character is not appended automatically to the copied string. If count is greater than the length of src, the destination string is padded with null characters up to length count. The behavior of strncpy is undefined if the source and destination strings overlap.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Destination string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>NULL terminated source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of chars to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns dest. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa8084d54811b0ca99f4969028165cfe8"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strncpy" ref="gaa8084d54811b0ca99f4969028165cfe8" args="(char *dest, const char *src, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF char* oscl_strncpy </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies the chars of one string to another.</p>
<p>Copies the initial count characters of src to dest and returns dest. If count is less than or equal to the length of src, a null character is not appended automatically to the copied string. If count is greater than the length of src, the destination string is padded with null characters up to length count. The behavior of strncpy is undefined if the source and destination strings overlap.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>Destination string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>NULL terminated source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>Number of chars to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns dest. </dd></dl>

<p>Referenced by <a class="el" href="oscl__tagtree_8h_source.html#l00055">Oscl_Tag_Base::tag_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga406f262e3e587e389fb31b46beecd195"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strrchr" ref="ga406f262e3e587e389fb31b46beecd195" args="(oscl_wchar *str, int32 c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>* oscl_strrchr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3bdb5c4fa9fe0317156e238a3d97594e"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strrchr" ref="ga3bdb5c4fa9fe0317156e238a3d97594e" args="(const oscl_wchar *str, int32 c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>* oscl_strrchr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad2276b5abc9b4af25b09fb0b60730f58"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strrchr" ref="gad2276b5abc9b4af25b09fb0b60730f58" args="(char *str, int32 c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF char* oscl_strrchr </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1107ef7fd1db4e1e4b75250625a0c454"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strrchr" ref="ga1107ef7fd1db4e1e4b75250625a0c454" args="(const char *str, int32 c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF const char* oscl_strrchr </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>c</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the last occurrence of c in string, or it returns NULL if c is not found. The null-terminating character is included in the search.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>null terminated source string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>character to search for</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="gab6b31e6aed082d26e089c2cb32034a98"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strset" ref="gab6b31e6aed082d26e089c2cb32034a98" args="(oscl_wchar *dest, oscl_wchar val, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>* oscl_strset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the characters of a string to a specified character</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>buffer to modify </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>character to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of chars to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value of dest </dd></dl>

</div>
</div>
<a class="anchor" id="gaa33a556267a0619f456e4f2c2ee34e03"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strset" ref="gaa33a556267a0619f456e4f2c2ee34e03" args="(char *dest, char val, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF char* oscl_strset </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the characters of a string to a specified character</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>buffer to modify </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>character to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of chars to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value of dest </dd></dl>

</div>
</div>
<a class="anchor" id="gab7d533d8649ec92303ac1103cdf9657a"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strstr" ref="gab7d533d8649ec92303ac1103cdf9657a" args="(oscl_wchar *str1, const oscl_wchar *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>* oscl_strstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac506e504056be177354eda2b10f7ccac"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strstr" ref="gac506e504056be177354eda2b10f7ccac" args="(const oscl_wchar *str1, const oscl_wchar *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>* oscl_strstr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>find the occurrence of sub-string in a string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>sub-string</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the begining of sub-string. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc4c2b0f4da4fe223d0970f169f49ec6"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strstr" ref="gadc4c2b0f4da4fe223d0970f169f49ec6" args="(char *str1, const char *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF char* oscl_strstr </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5e178cf5663271a02a46dc3399219cfb"></a><!-- doxytag: member="oscl_stdstring.h::oscl_strstr" ref="ga5e178cf5663271a02a46dc3399219cfb" args="(const char *str1, const char *str2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF const char* oscl_strstr </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>find the occurrence of sub-string in a string.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str1</em>&nbsp;</td><td>string. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>str2</em>&nbsp;</td><td>sub-string</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the begining of sub-string. </dd></dl>

</div>
</div>
<a class="anchor" id="gadc65a229006403b77d89ebc1ef1ad951"></a><!-- doxytag: member="oscl_stdstring.h::oscl_tolower" ref="gadc65a229006403b77d89ebc1ef1ad951" args="(const oscl_wchar car)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> oscl_tolower </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a>&nbsp;</td>
          <td class="paramname"> <em>car</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>convert upper case ASCII character to lower case. behaviour of this function for non-ASCII characters is not defined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>car</em>&nbsp;</td><td>upper case character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>lower case character. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07c241a9304ca88c49d816f0989b8f44"></a><!-- doxytag: member="oscl_stdstring.h::oscl_tolower" ref="ga07c241a9304ca88c49d816f0989b8f44" args="(const char car)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF char oscl_tolower </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>car</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>convert upper case ASCII character to lower case. behaviour of this function for non-ASCII characters is not defined.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>car</em>&nbsp;</td><td>upper case character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>lower case character. </dd></dl>

</div>
</div>
<a class="anchor" id="gab8cdae055fa3ab08039b0e022753b0d6"></a><!-- doxytag: member="OsclSharedPtr::OsclSharedPtr" ref="gab8cdae055fa3ab08039b0e022753b0d6" args="(const OsclSharedPtr &amp;inSharedPtr)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::<a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>inSharedPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>References <a class="el" href="classOsclRefCounter.html#a36656788a3ab2b554bc7e917bf6a4adb">OsclRefCounter::addRef()</a>.</p>

</div>
</div>
<a class="anchor" id="gade51c7acffa07b9f8ba607b6d612e97c"></a><!-- doxytag: member="OsclSharedPtr::OsclSharedPtr" ref="gade51c7acffa07b9f8ba607b6d612e97c" args="(TheClass *inClassPtr, OsclRefCounter *in_refcnt)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::<a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">TheClass *&nbsp;</td>
          <td class="paramname"> <em>inClassPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOsclRefCounter.html">OsclRefCounter</a> *&nbsp;</td>
          <td class="paramname"> <em>in_refcnt</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inClassPtr</em>&nbsp;</td><td>A pointer to an instance of the parameterized type that the new <a class="el" href="classOsclSharedPtr.html" title="A parameterized smart pointer class.">OsclSharedPtr</a> will wrap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf8168ec6b9c21c8e865b2aa298755545"></a><!-- doxytag: member="oscl_time.h::PV8601ToRFC822" ref="gaf8168ec6b9c21c8e865b2aa298755545" args="(PV8601timeStrBuf pv8601_buffer, CtimeStrBuf ctime_buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void PV8601ToRFC822 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad13c32c10063619e00563a850f87b86a">PV8601timeStrBuf</a>&nbsp;</td>
          <td class="paramname"> <em>pv8601_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#ga84d4ef38e5682881eb75ff4a64bc38b3">CtimeStrBuf</a>&nbsp;</td>
          <td class="paramname"> <em>ctime_buffer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga502be196b4670a35a7f5a345d105308d"></a><!-- doxytag: member="oscl_base.h::PVOsclBase_Cleanup" ref="ga502be196b4670a35a7f5a345d105308d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PVOsclBase_Cleanup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cleanup OsclBase functionality OsclBase should be cleaned once OsclBase functions are no longer needed </p>

</div>
</div>
<a class="anchor" id="gae420cafa320e40f84b5a46b32465296c"></a><!-- doxytag: member="oscl_base.h::PVOsclBase_Init" ref="gae420cafa320e40f84b5a46b32465296c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PVOsclBase_Init </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes OsclBase functionality. OsclBase must be initialized before any OsclBase functionality can be used.</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leaves</em>&nbsp;</td><td>if out-of-memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab50d565fcef75fe4b35a2794a287c69b"></a><!-- doxytag: member="oscl_time.h::RFC822ToPV8601" ref="gab50d565fcef75fe4b35a2794a287c69b" args="(CtimeStrBuf ctime_buffer, PV8601timeStrBuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void RFC822ToPV8601 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#ga84d4ef38e5682881eb75ff4a64bc38b3">CtimeStrBuf</a>&nbsp;</td>
          <td class="paramname"> <em>ctime_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad13c32c10063619e00563a850f87b86a">PV8601timeStrBuf</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8aad65d5c763ed07ec379b4f080c1899"></a><!-- doxytag: member="OsclSharedPtr::Unbind" ref="ga8aad65d5c763ed07ec379b4f080c1899" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::Unbind </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use this function of unbind an existing <a class="el" href="classOsclSharedPtr.html" title="A parameterized smart pointer class.">OsclSharedPtr</a>. </p>

<p>References <a class="el" href="oscl__shared__ptr_8h_source.html#l00149">OsclSharedPtr&lt; TheClass &gt;::Bind()</a>, and <a class="el" href="oscl__base__macros_8h_source.html#l00042">NULL</a>.</p>

</div>
</div>
<a class="anchor" id="ga6225904b5fa63a7379006e3f06c0b06a"></a><!-- doxytag: member="OsclSharedPtr::~OsclSharedPtr" ref="ga6225904b5fa63a7379006e3f06c0b06a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TheClass&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a>&lt; TheClass &gt;::~<a class="el" href="classOsclSharedPtr.html">OsclSharedPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>References <a class="el" href="oscl__base__macros_8h_source.html#l00042">NULL</a>, and <a class="el" href="classOsclRefCounter.html#aa7b138fd57f149a575356e51ee2d4451">OsclRefCounter::removeRef()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga0cc83fd35f446400713d1d9f3b2dd4c6"></a><!-- doxytag: member="oscl_time.h::CTIME_BUFFER_SIZE" ref="ga0cc83fd35f446400713d1d9f3b2dd4c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="group__osclbase.html#ga0cc83fd35f446400713d1d9f3b2dd4c6">CTIME_BUFFER_SIZE</a> = 26</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4469595fff8ac9560ee57d6d9d841063"></a><!-- doxytag: member="oscl_time.h::ISO8601TIME_BUFFER_SIZE" ref="ga4469595fff8ac9560ee57d6d9d841063" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="group__osclbase.html#ga4469595fff8ac9560ee57d6d9d841063">ISO8601TIME_BUFFER_SIZE</a> = 21</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga35f59c57e0e2b9e1b5eb78a8bed8160d"></a><!-- doxytag: member="oscl_time.h::MSEC_PER_SEC" ref="ga35f59c57e0e2b9e1b5eb78a8bed8160d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long <a class="el" href="group__osclbase.html#ga35f59c57e0e2b9e1b5eb78a8bed8160d">MSEC_PER_SEC</a> = 1000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0c23193ed013c5e4a67592281baf590d"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_BASE_LAST" ref="ga0c23193ed013c5e4a67592281baf590d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga0c23193ed013c5e4a67592281baf590d">OSCL_TLS_ID_BASE_LAST</a> = 11</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8bff100b390508716ae12b5bf0412314"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_ERRORHOOK" ref="ga8bff100b390508716ae12b5bf0412314" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga8bff100b390508716ae12b5bf0412314">OSCL_TLS_ID_ERRORHOOK</a> = 1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf05abfcb99d7bb5fbd12a7e0c7c09896"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_MAGICNUM" ref="gaf05abfcb99d7bb5fbd12a7e0c7c09896" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#gaf05abfcb99d7bb5fbd12a7e0c7c09896">OSCL_TLS_ID_MAGICNUM</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga08c2f3b8b4804ae19ae2e0969ce8b571"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_OSCLREGISTRY" ref="ga08c2f3b8b4804ae19ae2e0969ce8b571" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga08c2f3b8b4804ae19ae2e0969ce8b571">OSCL_TLS_ID_OSCLREGISTRY</a> = 10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga22410997b5ef50aad7043a5f09970d0e"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_PAYLOADPARSER" ref="ga22410997b5ef50aad7043a5f09970d0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga22410997b5ef50aad7043a5f09970d0e">OSCL_TLS_ID_PAYLOADPARSER</a> = 7</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4cb20f79d59ec0ec4815d5da685b5d13"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_PVERRORTRAP" ref="ga4cb20f79d59ec0ec4815d5da685b5d13" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga4cb20f79d59ec0ec4815d5da685b5d13">OSCL_TLS_ID_PVERRORTRAP</a> = 5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga85fa72a03af9bc9e223676567cd80b80"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_PVLOGGER" ref="ga85fa72a03af9bc9e223676567cd80b80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga85fa72a03af9bc9e223676567cd80b80">OSCL_TLS_ID_PVLOGGER</a> = 2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7978d8f58faa5bb6f5518c87c9c40031"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_PVMFRECOGNIZER" ref="ga7978d8f58faa5bb6f5518c87c9c40031" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga7978d8f58faa5bb6f5518c87c9c40031">OSCL_TLS_ID_PVMFRECOGNIZER</a> = 8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3b2de080edef7853c12aee984b8b7b87"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_PVSCHEDULER" ref="ga3b2de080edef7853c12aee984b8b7b87" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga3b2de080edef7853c12aee984b8b7b87">OSCL_TLS_ID_PVSCHEDULER</a> = 4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga969661abc3703a924f229b3381f619b8"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_SDPMEDIAPARSER" ref="ga969661abc3703a924f229b3381f619b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga969661abc3703a924f229b3381f619b8">OSCL_TLS_ID_SDPMEDIAPARSER</a> = 6</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8e7abb2560ae4dd75467ab2e4259b931"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_SQLITE3" ref="ga8e7abb2560ae4dd75467ab2e4259b931" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga8e7abb2560ae4dd75467ab2e4259b931">OSCL_TLS_ID_SQLITE3</a> = 11</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac1f0ea024ee0bc4eb7618fc97afb4fb3"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_TEST" ref="gac1f0ea024ee0bc4eb7618fc97afb4fb3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#gac1f0ea024ee0bc4eb7618fc97afb4fb3">OSCL_TLS_ID_TEST</a> = 3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab1a8e64f1f4762c8c0602ce17f3a5bff"></a><!-- doxytag: member="oscl_tls.h::OSCL_TLS_ID_WMDRM" ref="gab1a8e64f1f4762c8c0602ce17f3a5bff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#gab1a8e64f1f4762c8c0602ce17f3a5bff">OSCL_TLS_ID_WMDRM</a> = 9</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga141a5fd80c38f29950e7b7d67d4867b1"></a><!-- doxytag: member="oscl_time.h::PV8601TIME_BUFFER_SIZE" ref="ga141a5fd80c38f29950e7b7d67d4867b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="group__osclbase.html#ga141a5fd80c38f29950e7b7d67d4867b1">PV8601TIME_BUFFER_SIZE</a> = 21</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5ddea7a32bba8fc995966bc1dcc7a768"></a><!-- doxytag: member="oscl_time.h::unix_ntp_offset" ref="ga5ddea7a32bba8fc995966bc1dcc7a768" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclbase.html#ga5ddea7a32bba8fc995966bc1dcc7a768">unix_ntp_offset</a> = 2208988800U</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga47b0da9361952507ef28f0600d787aa4"></a><!-- doxytag: member="oscl_time.h::USEC_PER_SEC" ref="ga47b0da9361952507ef28f0600d787aa4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const long <a class="el" href="group__osclbase.html#ga47b0da9361952507ef28f0600d787aa4">USEC_PER_SEC</a> = 1000000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: CORE_9.005.1.1 </small>
</small></address>
</body>
</html>
