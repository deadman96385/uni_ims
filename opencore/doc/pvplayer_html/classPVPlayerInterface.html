<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pvplayer_engine: PVPlayerInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>PVPlayerInterface Class Reference</h1><!-- doxytag: class="PVPlayerInterface" -->
<p><code>#include &lt;<a class="el" href="pv__player__interface_8h_source.html">pv_player_interface.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a675501e8969781fb71c0736c6315de8f">~PVPlayerInterface</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#acfc31ff9055f7cfaad4a0da976afd1d6">GetSDKModuleInfo</a> (PVSDKModuleInfo &amp;aSDKModuleInfo, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a814cf3ec39f5780da14acafa379b0900">SetLogAppender</a> (const char *aTag, OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;aAppender, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a53125b6f10a6ae2e14f5dcf1b1aa222d">RemoveLogAppender</a> (const char *aTag, OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;aAppender, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a4e1846a075d63a140cfe470aa8f532a6">SetLogLevel</a> (const char *aTag, int32 aLevel, bool aSetSubtree=false, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#aa89568064eb62c675b44d7dc0c5f7ff3">GetLogLevel</a> (const char *aTag, PVLogLevelInfo &amp;aLogInfo, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#ac7c54fc8feadf1a59b7827870ebbf4c0">QueryInterface</a> (const PVUuid &amp;aUuid, PVInterface *&amp;aInterfacePtr, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#ad3f18906ca6895a8ff42858ef3d47a27">CancelCommand</a> (PVCommandId aCancelCmdId, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a3c097b05283b38b49ce2a3fac79d8128">CancelAllCommands</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#afc17bf49f411edf4820d7fca327d6172">GetPVPlayerState</a> (PVPlayerState &amp;aState, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a2aee1c69bb2265379aecd05787a4dd02">GetPVPlayerStateSync</a> (PVPlayerState &amp;aState)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a204d0c4b0cbe2827c3ed929f964c9d74">AddDataSource</a> (PVPlayerDataSource &amp;aDataSource, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#ad915478a764d1e24ee20e5cc1abdf099">UpdateDataSource</a> (PVPlayerDataSource &amp;aDataSource, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#ab1102ea132c162fe16c619323ff6cc3a">Init</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#af766cc88b9e9a4a2e41aea3ce178e380">GetMetadataValues</a> (PVPMetadataList &amp;aKeyList, int32 aStartingValueIndex, int32 aMaxValueEntries, int32 &amp;aNumAvailableValueEntries, Oscl_Vector&lt; PvmiKvp, OsclMemAllocator &gt; &amp;aValueList, const OsclAny *aContextData=NULL, bool aMetadataValuesCopiedInCallBack=true, uint32 aClipIndex=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#ac8f1d4922feac7e27c69ea321d113f6b">ReleaseMetadataValues</a> (Oscl_Vector&lt; PvmiKvp, OsclMemAllocator &gt; &amp;aValueList, const OsclAny *aContextData=NULL, uint32 aClipIndex=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a6850c85b53e85fbf29cef0656d507456">AddDataSink</a> (PVPlayerDataSink &amp;aDataSink, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a4dd4a15e7391482c5bb9b393565f299e">SetPlaybackRange</a> (PVPPlaybackPosition aBeginPos, PVPPlaybackPosition aEndPos, bool aQueueRange, const OsclAny *aContextData=NULL, bool aSkipToRequestedPosition=true, bool aSeekToSyncPoint=true)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#aed395e031598d2d787ee285a9ada76f2">GetPlaybackRange</a> (PVPPlaybackPosition &amp;aBeginPos, PVPPlaybackPosition &amp;aEndPos, bool aQueued, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a343571f3fc8eb3b9e89a8b799f2c54b5">GetCurrentPosition</a> (PVPPlaybackPosition &amp;aPos, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#af2a760aaf363a66b7c3d4fb3938d340b">SetPlaybackRate</a> (int32 aRate, PVMFTimebase *aTimebase=NULL, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a05260638e26c1d9ec7a7a2d602dcfad0">GetPlaybackRate</a> (int32 &amp;aRate, PVMFTimebase *&amp;aTimebase, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a89a7c418c51ea79c6fe6ef8e44793eea">GetPlaybackMinMaxRate</a> (int32 &amp;aMinRate, int32 &amp;aMaxRate, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#acb29a1feb906013757abc6e0234113ff">GetCurrentPositionSync</a> (PVPPlaybackPosition &amp;aPos)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#afa06b1de938025013ef372a6bce9732f">Prepare</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#af0022fc7c9df8f9451f316daf65339fb">Start</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a67edb06be32a790e2fa9658870d5ee2a">Pause</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a9df7ed528024aee6279f20f04148b8be">Resume</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a3fc658912aea50c69727d622ee36232a">Stop</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#ab2e2e2ce5cefa1549309a1bfb1e58d92">RemoveDataSink</a> (PVPlayerDataSink &amp;aDataSink, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a6884207fbe3193bb35518860cbe97f4a">Reset</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#a3cd5e208c9cf9c37f31b1653dcec3eac">RemoveDataSource</a> (PVPlayerDataSource &amp;aDataSource, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVPlayerInterface.html#afbd3c1afd05a530c484f4276fd65d400">GetSDKInfo</a> (PVSDKInfo &amp;aSDKInfo)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classPVPlayerInterface.html">PVPlayerInterface</a> is the interface to the pvPlayer SDK, which allows control of a multimedia playback engine. The PVPlayerFactory factory class is to be used to create and delete instances of this object </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a675501e8969781fb71c0736c6315de8f"></a><!-- doxytag: member="PVPlayerInterface::~PVPlayerInterface" ref="a675501e8969781fb71c0736c6315de8f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVPlayerInterface::~PVPlayerInterface </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Object destructor function Releases all resources prior to destruction </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6850c85b53e85fbf29cef0656d507456"></a><!-- doxytag: member="PVPlayerInterface::AddDataSink" ref="a6850c85b53e85fbf29cef0656d507456" args="(PVPlayerDataSink &amp;aDataSink, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::AddDataSink </td>
          <td>(</td>
          <td class="paramtype">PVPlayerDataSink &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function allows a player data sink to be specified for playback. This function must be called when pvPlayer is in PVP_STATE_INITIALIZED state. The specified data sink must be a valid PVPlayerDataSink to be accepted for use in playback. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSink</em>&nbsp;</td><td>The player data sink to be used for playback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrNotSupported if the format of the sink is incompatible with what the SDK can handle OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a204d0c4b0cbe2827c3ed929f964c9d74"></a><!-- doxytag: member="PVPlayerInterface::AddDataSource" ref="a204d0c4b0cbe2827c3ed929f964c9d74" args="(PVPlayerDataSource &amp;aDataSource, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::AddDataSource </td>
          <td>(</td>
          <td class="paramtype">PVPlayerDataSource &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function allows a player data source to be specified for playback. This function must be called when pvPlayer is in PVP_STATE_IDLE state and before calling Init. The specified data source must be a valid PVPlayerDataSource to be accepted for use in playback. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSource</em>&nbsp;</td><td>Reference to the player data source to be used for playback </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrNotSupported if the format of the source is incompatible with what the SDK can handle OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a3c097b05283b38b49ce2a3fac79d8128"></a><!-- doxytag: member="PVPlayerInterface::CancelAllCommands" ref="a3c097b05283b38b49ce2a3fac79d8128" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::CancelAllCommands </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is to allow the user to cancel all pending requests in pvPlayer. The current request being processed, if any, will also be aborted. The user of PV-SDK should get the state of PVPlayer Engine after the command completes and before issuing any other command. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ad3f18906ca6895a8ff42858ef3d47a27"></a><!-- doxytag: member="PVPlayerInterface::CancelCommand" ref="ad3f18906ca6895a8ff42858ef3d47a27" args="(PVCommandId aCancelCmdId, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::CancelCommand </td>
          <td>(</td>
          <td class="paramtype">PVCommandId&nbsp;</td>
          <td class="paramname"> <em>aCancelCmdId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is to allow user of the SDK to cancel any specific command which is pending on pvPlayer. If the request is to cancel a command which still has to be processed pvPlayer will just remove the command from its queue of commands to be processed. If the request is to cancel a command that is ongoing then player will attempt to interrupt the ongoing command. The state of player after a cancel can vary. So the user of pvPlayerSDK must always query for state before issuing any subsequent commands. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aCancelCmdId</em>&nbsp;</td><td>Command Id to be cancelled. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a343571f3fc8eb3b9e89a8b799f2c54b5"></a><!-- doxytag: member="PVPlayerInterface::GetCurrentPosition" ref="a343571f3fc8eb3b9e89a8b799f2c54b5" args="(PVPPlaybackPosition &amp;aPos, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::GetCurrentPosition </td>
          <td>(</td>
          <td class="paramtype">PVPPlaybackPosition &amp;&nbsp;</td>
          <td class="paramname"> <em>aPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function allows querying of the current playback position. The playback position units will be in the one specified by the passed-in reference to PVPPlaybackPosition. Currently only milliseconds units is supported. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aPos</em>&nbsp;</td><td>Reference to place the current playback position </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="acb29a1feb906013757abc6e0234113ff"></a><!-- doxytag: member="PVPlayerInterface::GetCurrentPositionSync" ref="acb29a1feb906013757abc6e0234113ff" args="(PVPPlaybackPosition &amp;aPos)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFStatus PVPlayerInterface::GetCurrentPositionSync </td>
          <td>(</td>
          <td class="paramtype">PVPPlaybackPosition &amp;&nbsp;</td>
          <td class="paramname"> <em>aPos</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function allows querying of the current playback position as a synchronous command. The playback position units will be in the one specified by the passed-in reference to PVPPlaybackPosition. Currently only millisecond units is supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aPos</em>&nbsp;</td><td>Reference to place the current playback position  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status indicating whether the command succeeded or not. </dd></dl>

</div>
</div>
<a class="anchor" id="aa89568064eb62c675b44d7dc0c5f7ff3"></a><!-- doxytag: member="PVPlayerInterface::GetLogLevel" ref="aa89568064eb62c675b44d7dc0c5f7ff3" args="(const char *aTag, PVLogLevelInfo &amp;aLogInfo, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::GetLogLevel </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVLogLevelInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>aLogInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the logging level to be queried for a particular logging tag. A larger log level will result in more messages being logged. In the asynchronous response, this should return the log level along with an indication of where the level was inherited (i.e., the ancestor tag). This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the log level should be retrieved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aLogInfo</em>&nbsp;</td><td>An output parameter which will be filled in with the log level information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>method can leave with one of the following error codes OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command ID for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="af766cc88b9e9a4a2e41aea3ce178e380"></a><!-- doxytag: member="PVPlayerInterface::GetMetadataValues" ref="af766cc88b9e9a4a2e41aea3ce178e380" args="(PVPMetadataList &amp;aKeyList, int32 aStartingValueIndex, int32 aMaxValueEntries, int32 &amp;aNumAvailableValueEntries, Oscl_Vector&lt; PvmiKvp, OsclMemAllocator &gt; &amp;aValueList, const OsclAny *aContextData=NULL, bool aMetadataValuesCopiedInCallBack=true, uint32 aClipIndex=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::GetMetadataValues </td>
          <td>(</td>
          <td class="paramtype">PVPMetadataList &amp;&nbsp;</td>
          <td class="paramname"> <em>aKeyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aStartingValueIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aMaxValueEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 &amp;&nbsp;</td>
          <td class="paramname"> <em>aNumAvailableValueEntries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Oscl_Vector&lt; PvmiKvp, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aValueList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aMetadataValuesCopiedInCallBack</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aClipIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function makes a request to return the metadata value(s) specified by the passed in metadata key list. If the requeted metadata value is unavailable or the metadata key is invalid, the returned list will not contain a KVP entry for the key. Note that value indexed in the returned aValueList does not necessary match the same index into the specified aKeyList since this command can return none or more than one KVP for a specified key. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aKeyList</em>&nbsp;</td><td>Reference to a list of metadata keys for which metadata values are requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aStartingValueIndex</em>&nbsp;</td><td>The starting index refers to the an index into the whole value list specified by the keys in aKeyList. This command would populate the aValueList starting from the specified index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aMaxValueEntries</em>&nbsp;</td><td>Input parameter to specify the maximum number of entries to be added to aValueList. If there is no limit, set to -1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aNumAvailableValueEntries</em>&nbsp;</td><td>Output parameter which will be filled with number of available values for the specified key list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aValueList</em>&nbsp;</td><td>Reference to a vector of KVP to place the specified metadata values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aMetadataValuesCopiedInCallBack</em>&nbsp;</td><td>Boolean to let engine know if metadata values are copied by User of SDK in command complete callback. By default the SDK assumes this to be the case. If this argument is set to false by the caller, then SDK assumes that user will call ReleaseMetaDataValues at a later point. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aClipIndex,:</em>&nbsp;</td><td>an optional parameter for use with playlists to select the clip of interest.  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a89a7c418c51ea79c6fe6ef8e44793eea"></a><!-- doxytag: member="PVPlayerInterface::GetPlaybackMinMaxRate" ref="a89a7c418c51ea79c6fe6ef8e44793eea" args="(int32 &amp;aMinRate, int32 &amp;aMaxRate, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::GetPlaybackMinMaxRate </td>
          <td>(</td>
          <td class="paramtype">int32 &amp;&nbsp;</td>
          <td class="paramname"> <em>aMinRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 &amp;&nbsp;</td>
          <td class="paramname"> <em>aMaxRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the minimum and maximum playback rate expressed as a millipercent of "real-time" playback rate. This function can be called anytime between pvPlayer instantiation and destruction. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aMinRate</em>&nbsp;</td><td>A reference to an integer which will be filled in with the minimum playback rate allowed expressed as millipercent of "real-time" playback rate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aMaxRate</em>&nbsp;</td><td>A reference to an integer which will be filled in with the maximum playback rate allowed expressed as millipercent of "real-time" playback rate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="aed395e031598d2d787ee285a9ada76f2"></a><!-- doxytag: member="PVPlayerInterface::GetPlaybackRange" ref="aed395e031598d2d787ee285a9ada76f2" args="(PVPPlaybackPosition &amp;aBeginPos, PVPPlaybackPosition &amp;aEndPos, bool aQueued, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::GetPlaybackRange </td>
          <td>(</td>
          <td class="paramtype">PVPPlaybackPosition &amp;&nbsp;</td>
          <td class="paramname"> <em>aBeginPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVPPlaybackPosition &amp;&nbsp;</td>
          <td class="paramname"> <em>aEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aQueued</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the playback range information for the current or queued playback range. The user can choose which playback range by the aQueued flag. This function can be called when pvPlayer is in PVP_STATE_INITIALIZED, PVP_STATE_PREPARED, PVP_STATE_STARTED, or PVP_STATE_PAUSED state. The units of position is specified in the passed-in PVPlaybackPosition parameters which will be filled in when the command completes. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aBeginPos</em>&nbsp;</td><td>Reference to place the begin position for the playback range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aEndPos</em>&nbsp;</td><td>Reference to place the end position for the playback range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aQueued</em>&nbsp;</td><td>Input flag to choose inof of which playback range to return. Set(true)for queued range. Reset(false) for current range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a05260638e26c1d9ec7a7a2d602dcfad0"></a><!-- doxytag: member="PVPlayerInterface::GetPlaybackRate" ref="a05260638e26c1d9ec7a7a2d602dcfad0" args="(int32 &amp;aRate, PVMFTimebase *&amp;aTimebase, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::GetPlaybackRate </td>
          <td>(</td>
          <td class="paramtype">int32 &amp;&nbsp;</td>
          <td class="paramname"> <em>aRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVMFTimebase *&amp;&nbsp;</td>
          <td class="paramname"> <em>aTimebase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function retrieves the current playback rate setting. If the playback rate is set as a millipercent of "real-time" playback rate, then aRate will be filled in with the milliperecent value when this command completes successfully. If the playback rate is set by an outside timebase, aRate will be set to 0 and aTimebase pointer will point to the PVMFTimebase being used when the command completes successfully. This function can be called when pvPlayer is in PVP_STATE_PREPARED, PVP_STATE_STARTED, or PVP_STATE_PAUSED state. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aRate</em>&nbsp;</td><td>A reference to an integer which will be filled in with the current playback rate expressed as millipercent of "real-time" playback rate. If an outside timebase is being used, aRate would be set to 0. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimebase</em>&nbsp;</td><td>Reference to an PVMFTimebase pointer which will be valid if an outside timebase is being used for the playback clock. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="afc17bf49f411edf4820d7fca327d6172"></a><!-- doxytag: member="PVPlayerInterface::GetPVPlayerState" ref="afc17bf49f411edf4820d7fca327d6172" args="(PVPlayerState &amp;aState, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::GetPVPlayerState </td>
          <td>(</td>
          <td class="paramtype">PVPlayerState &amp;&nbsp;</td>
          <td class="paramname"> <em>aState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the current state of pvPlayer. Application may use this info for updating display or determine if the pvPlayer is ready for the next request. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aState</em>&nbsp;</td><td>A reference to a PVPlayerState. Upon successful completion of this command, it will contain the current state of pvPlayer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a2aee1c69bb2265379aecd05787a4dd02"></a><!-- doxytag: member="PVPlayerInterface::GetPVPlayerStateSync" ref="a2aee1c69bb2265379aecd05787a4dd02" args="(PVPlayerState &amp;aState)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFStatus PVPlayerInterface::GetPVPlayerStateSync </td>
          <td>(</td>
          <td class="paramtype">PVPlayerState &amp;&nbsp;</td>
          <td class="paramname"> <em>aState</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the current state of pvPlayer as a synchronous command. Application may use this info for updating display or determine if the pvPlayer is ready for the next request.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aState</em>&nbsp;</td><td>A reference to a PVPlayerState. Upon successful completion of this command, it will contain the current state of pvPlayer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status indicating whether the command succeeded or not. </dd></dl>

</div>
</div>
<a class="anchor" id="afbd3c1afd05a530c484f4276fd65d400"></a><!-- doxytag: member="PVPlayerInterface::GetSDKInfo" ref="afbd3c1afd05a530c484f4276fd65d400" args="(PVSDKInfo &amp;aSDKInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF void PVPlayerInterface::GetSDKInfo </td>
          <td>(</td>
          <td class="paramtype">PVSDKInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>aSDKInfo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns SDK version information about pvPlayer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aSDKInfo</em>&nbsp;</td><td>A reference to a PVSDKInfo structure which contains product name, supported hardware platform, supported software platform, version, part number, and PV UUID. These fields will contain info .for the currently instantiated pvPlayer engine when this function returns success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfc31ff9055f7cfaad4a0da976afd1d6"></a><!-- doxytag: member="PVPlayerInterface::GetSDKModuleInfo" ref="acfc31ff9055f7cfaad4a0da976afd1d6" args="(PVSDKModuleInfo &amp;aSDKModuleInfo, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::GetSDKModuleInfo </td>
          <td>(</td>
          <td class="paramtype">PVSDKModuleInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>aSDKModuleInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns information about all modules currently used by pvPlayer SDK. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aSDKModuleInfo</em>&nbsp;</td><td>A reference to a PVSDKModuleInfo structure which contains the number of modules currently used by pvPlayer SDK and the PV UUID and description string for each module. The PV UUID and description string for modules will be returned in one string buffer allocated by the client. If the string buffer is not large enough to hold the all the module's information, the information will be written up to the length of the buffer and truncated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command ID for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ab1102ea132c162fe16c619323ff6cc3a"></a><!-- doxytag: member="PVPlayerInterface::Init" ref="ab1102ea132c162fe16c619323ff6cc3a" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::Init </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function switches pvPlayer from PVP_STATE_IDLE state to the PVP_STATE_INITIALIZED state. During the transition, pvPlayer is in the PVP_STATE_INITIALIZING transitional state and the data source is being initialized to obtain metadata and track information of the source media. If initialization fails, pvPlayer will revert to PVP_STATE_IDLE state and the data source will be closed. The Command should only be called in PVP_STATE_IDLE. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a67edb06be32a790e2fa9658870d5ee2a"></a><!-- doxytag: member="PVPlayerInterface::Pause" ref="a67edb06be32a790e2fa9658870d5ee2a" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::Pause </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function pauses the currently ongoing playback. pvPlayer must be in PVP_STATE_STARTED state to call this function. When pause successfully completes, pvPlayer will be in PVP_STATE_PAUSED state. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="afa06b1de938025013ef372a6bce9732f"></a><!-- doxytag: member="PVPlayerInterface::Prepare" ref="afa06b1de938025013ef372a6bce9732f" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::Prepare </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions prepares pvPlayer for playback. pvPlayer connects the data source with the data sinks and starts the data source to queue the media data for playback(e.g. for 3GPP streaming, fills the jitter buffer). pvPlayer also checks to make sure each component needed for playback is ready and capable. When successful, pvPlayer will be in PVP_STATE_PREPARED state, The command should be called only in PVP_STATE_INITIALISED. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ac7c54fc8feadf1a59b7827870ebbf4c0"></a><!-- doxytag: member="PVPlayerInterface::QueryInterface" ref="ac7c54fc8feadf1a59b7827870ebbf4c0" args="(const PVUuid &amp;aUuid, PVInterface *&amp;aInterfacePtr, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::QueryInterface </td>
          <td>(</td>
          <td class="paramtype">const PVUuid &amp;&nbsp;</td>
          <td class="paramname"> <em>aUuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVInterface *&amp;&nbsp;</td>
          <td class="paramname"> <em>aInterfacePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is to allow for extensibility of the pvPlayer interface. It allows a caller to ask for an instance of a particular interface object to be returned. The mechanism is analogous to the COM IUnknown method. The interfaces are identified with an interface ID that is a UUID as in DCE and a pointer to the interface object is returned if it is supported. Otherwise the returned pointer is NULL. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aUuid</em>&nbsp;</td><td>The UUID of the desired interface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aInterfacePtr</em>&nbsp;</td><td>A reference to the output pointer to the desired interface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>method can leave with one of the following error codes OsclErrNotSupported if the specified interface UUID is not supported </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command ID for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ac8f1d4922feac7e27c69ea321d113f6b"></a><!-- doxytag: member="PVPlayerInterface::ReleaseMetadataValues" ref="ac8f1d4922feac7e27c69ea321d113f6b" args="(Oscl_Vector&lt; PvmiKvp, OsclMemAllocator &gt; &amp;aValueList, const OsclAny *aContextData=NULL, uint32 aClipIndex=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::ReleaseMetadataValues </td>
          <td>(</td>
          <td class="paramtype">Oscl_Vector&lt; PvmiKvp, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aValueList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aClipIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function makes a request to release the metadata value(s) specified by the passed in metadata value list. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.If a GetMetaDataValues were called in PVP_STATE_INITIALIZED state, then corresponding ReleaseMetaDataValues must be called before Reset. If a GetMetaDataValues were called in PVP_STATE_PREPARED, PVP_STATE_STARTED, PVP_STATE_PAUSED states, then corresponding ReleaseMetaDataValues must be called before Stop.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aValueList</em>&nbsp;</td><td>Reference to a vector of KVP to place the specified metadata values </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aClipIndex,:</em>&nbsp;</td><td>an optional parameter for use with playlists to select the clip of interest.  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ab2e2e2ce5cefa1549309a1bfb1e58d92"></a><!-- doxytag: member="PVPlayerInterface::RemoveDataSink" ref="ab2e2e2ce5cefa1549309a1bfb1e58d92" args="(PVPlayerDataSink &amp;aDataSink, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::RemoveDataSink </td>
          <td>(</td>
          <td class="paramtype">PVPlayerDataSink &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function may be used to close and unbind a data sink that has been previously added. This function must be called when pvPlayer is in PVP_STATE_INITIALIZED state. If the data sink is in use for playback, Stop must be called first to stop the playback and free the data sink. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSink</em>&nbsp;</td><td>Reference to the data sink to be removed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrBadHandle if the passed in sink parameter is invalid OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a3cd5e208c9cf9c37f31b1653dcec3eac"></a><!-- doxytag: member="PVPlayerInterface::RemoveDataSource" ref="a3cd5e208c9cf9c37f31b1653dcec3eac" args="(PVPlayerDataSource &amp;aDataSource, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::RemoveDataSource </td>
          <td>(</td>
          <td class="paramtype">PVPlayerDataSource &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function may be used to close and unbind a data source that has been previously added. This function must be called when pvPlayer is in PVP_STATE_IDLE state. If the data source has already been initialized, Reset must be called first. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSource</em>&nbsp;</td><td>Reference to the data source to be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrBadHandle if the passed in sink parameter is invalid OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a53125b6f10a6ae2e14f5dcf1b1aa222d"></a><!-- doxytag: member="PVPlayerInterface::RemoveLogAppender" ref="a53125b6f10a6ae2e14f5dcf1b1aa222d" args="(const char *aTag, OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;aAppender, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::RemoveLogAppender </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aAppender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows a logging appender to be removed from the logger tree at the point specified by the input tag. If the input tag is NULL then the appender will be removed from locations in the tree. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the appender should be removed. Can be NULL to remove at all locations. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aAppender</em>&nbsp;</td><td>The log appender to remove. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>method can leave with one of the following error codes OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command ID for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a6884207fbe3193bb35518860cbe97f4a"></a><!-- doxytag: member="PVPlayerInterface::Reset" ref="a6884207fbe3193bb35518860cbe97f4a" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::Reset </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function cleans up resources used for playback to transition pvPlayer to PVP_STATE_IDLE state. While processing this command, pvPlayer is in the PVP_STATE_RESETTING state. If any data sinks are still referenced by pvPlayer when this function is called, the data sinks will be closed and removed from pvPlayer during the Reset. If already in PVP_STATE_IDLE state, then nothing will occur. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a9df7ed528024aee6279f20f04148b8be"></a><!-- doxytag: member="PVPlayerInterface::Resume" ref="a9df7ed528024aee6279f20f04148b8be" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::Resume </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resumes the currently paused playback. pvPlayer must be in PVP_STATE_PAUSED state to call this function. When resume successfully completes, pvPlayer will be in PVP_STATE_STARTED state. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a814cf3ec39f5780da14acafa379b0900"></a><!-- doxytag: member="PVPlayerInterface::SetLogAppender" ref="a814cf3ec39f5780da14acafa379b0900" args="(const char *aTag, OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;aAppender, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::SetLogAppender </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aAppender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows a logging appender to be attached at some point in the logger tag tree. The location in the tag tree is specified by the input tag string. A single appender can be attached multiple times in the tree, but it may result in duplicate copies of log messages if the appender is not attached in disjoint portions of the tree. A logging appender is responsible for actually writing the log message to its final location (e.g., memory, file, network, etc). This API can be called anytime after creation of pvPlayer. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the appender should be attached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aAppender</em>&nbsp;</td><td>The log appender to attach. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>method can leave with one of the following error codes OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command ID for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a4e1846a075d63a140cfe470aa8f532a6"></a><!-- doxytag: member="PVPlayerInterface::SetLogLevel" ref="a4e1846a075d63a140cfe470aa8f532a6" args="(const char *aTag, int32 aLevel, bool aSetSubtree=false, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::SetLogLevel </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aSetSubtree</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the logging level to be set for the logging node specified by the tag. A larger log level will result in more messages being logged. A message will only be logged if its level is LESS THAN or equal to the current log level. The aSetSubtree flag will allow an entire subtree, with the specified tag as the root, to be reset to the specified value. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the log level should be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aLevel</em>&nbsp;</td><td>Specifies the log level to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aSetSubtree</em>&nbsp;</td><td>Specifies whether the entire subtree with aTag as the root should be reset to the log level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>This</em>&nbsp;</td><td>method can leave with one of the following error codes OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command ID for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a4dd4a15e7391482c5bb9b393565f299e"></a><!-- doxytag: member="PVPlayerInterface::SetPlaybackRange" ref="a4dd4a15e7391482c5bb9b393565f299e" args="(PVPPlaybackPosition aBeginPos, PVPPlaybackPosition aEndPos, bool aQueueRange, const OsclAny *aContextData=NULL, bool aSkipToRequestedPosition=true, bool aSeekToSyncPoint=true)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::SetPlaybackRange </td>
          <td>(</td>
          <td class="paramtype">PVPPlaybackPosition&nbsp;</td>
          <td class="paramname"> <em>aBeginPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVPPlaybackPosition&nbsp;</td>
          <td class="paramname"> <em>aEndPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aQueueRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aSkipToRequestedPosition</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aSeekToSyncPoint</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the begin and end positions for the new playback range or changes the end position of the current playback range. This function must be called when pvPlayer is in PVP_STATE_INITIALIZED, PVP_STATE_PREPARED, PVP_STATE_STARTED, or PVP_STATE_PAUSED state. The specified positions must be between beginning of clip and clip duration. The units of position is specified in the passed-in parameter PVPPlaybackPosition. If either of the positions is indeterminate, use the indeterminate flag in PVPPlaybackPosition structure. The queued playback range can be done using aQueueRange flag which is Not Supported as of now by PV-SDK. This function will overwrite any previous playback range info. The only exception is the changing of end position for the current playback range during playback. Command if called in player state as PVP_STATE_INITIALISED or PVP_STATE_PAUSED, will complete in one Engine AO run without actually changing the position. The change in position will come into affect when Prepare or Resume respectively is called on Engine by the app. If reposition request is not honored by the source node during Prepare or Resume, engine will continue to complete Prepare or Resume but will send an informational event "PVMFInfoChangePlaybackPositionNotSupported" to the app informing that the SetPlaybackRange request could not be honored. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aBeginPos</em>&nbsp;</td><td>Beginning position for the new playback range </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aEndPos</em>&nbsp;</td><td>Ending position for the new playback range. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aQueueRange</em>&nbsp;</td><td>Input flag to tell pvPlayer to queue the new playback range (Set/true) or use the new playback range right away (Reset/false) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aSkipToRequestedPosition</em>&nbsp;</td><td>Boolean value to indicate whether or not the display should start exactly from the requested position Default is set to 'true'. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aSeekToSyncPoint</em>&nbsp;</td><td>Boolean value to indicate whether or not the source should seek to a sync point. true - Means that the decoder will be fed from a key-frame thereby promising that there are no artefacts false - Means that the decoder will be fed the nearest frame from the requested seek point, which can be a non-sync frame, with a possibility of causing artefacts Default is set to 'true'  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="af2a760aaf363a66b7c3d4fb3938d340b"></a><!-- doxytag: member="PVPlayerInterface::SetPlaybackRate" ref="af2a760aaf363a66b7c3d4fb3938d340b" args="(int32 aRate, PVMFTimebase *aTimebase=NULL, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::SetPlaybackRate </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aRate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVMFTimebase *&nbsp;</td>
          <td class="paramname"> <em>aTimebase</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function allows the setting of the playback rate. The playback rate can be set as millipercent of "real-time" playback rate. For example, 100000 means 1X "real-time", 400000 means 4X, 25000 means 0.25X, and -100000 means 1X backward. The playback rate can also be modified by specifying the timebase to use for the playback clock. This is accomplished by setting the aRate parameter to 0 and passing in a pointer to an PVMFTimebase. This function can be called when pvPlayer is in PVP_STATE_PREPARED, PVP_STATE_STARTED, or PVP_STATE_PAUSED state. Changing to or from an outside timebase is only allowed in PVP_STATE_PREPARED. Command if called in player state PVP_STATE_PAUSED with a direction change, will complete in one Engine AO run without actually changing the direction. The change in direction will come into affect when Resume is called on Engine by the app. If the request is not honored by the source node during Resume, engine will continue to complete Resume but will send an informational event "PVMFInfoChangePlaybackPositionNotSupported" to the app informing that the SetPlaybackRate request could not be honored. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aRate</em>&nbsp;</td><td>The playback rate specified as millipercent of "real-time". A millipercent is 1/1000 of a percent. So 2X = 200% of realtime is 200,000 millipercent. The motivation is to povide precision with an integer parameter. Negative rates specify backward playback. The valid range of absolute value of playback rates will be limited to the minimum and maximum returned by <a class="el" href="classPVPlayerInterface.html#a89a7c418c51ea79c6fe6ef8e44793eea">GetPlaybackMinMaxRate()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimebase</em>&nbsp;</td><td>Reference to an PVMFTimebase which will be used to drive the playback clock. aRate must be set to 0, 1X, or -1X to use the timebase. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrArgument if rate or timebase is invalid </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="af0022fc7c9df8f9451f316daf65339fb"></a><!-- doxytag: member="PVPlayerInterface::Start" ref="af0022fc7c9df8f9451f316daf65339fb" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::Start </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function kicks off the actual playback. Media data are sent out from the data source to the data sink(s). pvPlayer will transition to PVP_STATE_STARTED state after playback starts successfully. The command should be called only in PVP_STATE_PREPARED. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a3fc658912aea50c69727d622ee36232a"></a><!-- doxytag: member="PVPlayerInterface::Stop" ref="a3fc658912aea50c69727d622ee36232a" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::Stop </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function stops the current playback and transitions pvPlayer to the PVP_STATE_INITIALIZED state. During the transition, data transmission from data source to all data sinks are terminated. Also all connections between data source and data sinks are torn down. This command request is asynchronous. PVCommandStatusObserver's CommandCompleted() callback handler will be called when this command request completes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrInvalidState if invoked in the incorrect state OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ad915478a764d1e24ee20e5cc1abdf099"></a><!-- doxytag: member="PVPlayerInterface::UpdateDataSource" ref="ad915478a764d1e24ee20e5cc1abdf099" args="(PVPlayerDataSource &amp;aDataSource, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVCommandId PVPlayerInterface::UpdateDataSource </td>
          <td>(</td>
          <td class="paramtype">PVPlayerDataSource &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function allows extending or updating a track list during playback. Changes can be applied prior to beginning initialization for any track.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSource</em>&nbsp;</td><td>aDataSource contains an updated version of the data source previously provided in AddDataSource command. The updated data source can contain modifications to existing clips in the list, or new clips added to the end of the list. This API cannot be used to update data for clips that have already been initialized, or to delete clips from the clip list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes OsclErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="pv__player__interface_8h_source.html">pv_player_interface.h</a></li>
</ul>
</div>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>PV Player Engine</small>
<address style="align: left;"><small>Posting Version: CORE_9.005.1.1 </small>
</small></address>
</body>
</html>
