<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pv2way_engine: H324MConfigInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>H324MConfigInterface Class Reference</h1><!-- doxytag: class="H324MConfigInterface" -->
<p><code>#include &lt;<a class="el" href="tsc__h324m__config__interface_8h_source.html">tsc_h324m_config_interface.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#ab968ad945017b64326b5f7dbedf7d9f6">SetObserver</a> (<a class="el" href="classH324MConfigObserver.html">H324MConfigObserver</a> *aObserver)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#aa3c60d6e0cb07b46cfa49bb5151487dc">SetMultiplexLevel</a> (TPVH223Level aLevel, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#ac7612b7b575a771050e6ded2e5c92820">SetMaxSduSize</a> (TPVAdaptationLayer aLayer, int32 aSize, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a5cd680f349194228c43504c02438e75d">SetMaxSduSizeR</a> (TPVAdaptationLayer aLayer, int32 aSize, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a68e9dcfd81664b9fd5a50643a0ec6bca">SetCodecPreference</a> (Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aIncomingAudio, Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aIncomingVideo, Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aOutGoingAudio, Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aOutGoingVideo, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#aa5b44e5952672117ec71ab3ef97cac40">SetFormatSpecificInfo</a> (PVMFFormatType aMediaFormat, const uint8 *apFormatSpecificInfo, uint32 aFormatSpecificInfoLen, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a7f8b8631e722052e181fcf23b34be8cf">SetAl2SequenceNumbers</a> (int32 aSeqNumWidth, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#aee943443772d9d65c292caba8da6adde">SetAl3ControlFieldOctets</a> (int32 aCfo, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a55cad622e924e65f8647631f3646fbaf">SetMaxPduSize</a> (int32 aMaxPduSize, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#af381da913b4a589135424eddd675a364">SetTerminalType</a> (uint8 aTerminalType, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a38d8daa6a6ef075b9ed19f35cc69d965">SetALConfiguration</a> (<a class="el" href="pv__2way__basic__types_8h.html#af4551e1a20a6ab7cfc828dae30f4e918">TPVMediaType_t</a> aMediaType, TPVAdaptationLayer aLayer, bool aAllow, bool aUse=true, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a4b74d4df026bef88f54abc5778c9da71">SendRme</a> (OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a9ee9d9c32434b008ebd2f7828869c235">SetMaxMuxPduSize</a> (int32 aRequestMaxMuxPduSize, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#add70ea9bd47690b9fc8d8c3b27400ac3">SetMaxMuxCcsrlSduSize</a> (int32 aMaxCcsrlSduSize, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a0077d9356fd59f980edeff797917ce75">FastUpdate</a> (PVMFNodeInterface &amp;aTrack, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a56f603ea9c90cc49163b72ba9199ec04">SendRtd</a> (OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#aa3f7bb32c9d937a514438c87ad8429e2">SetVendor</a> (uint8 cc, uint8 ext, uint32 mc, const uint8 *aProduct, uint16 aProductLen, const uint8 *aVersion, uint16 aVersionLen, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#aa47ae8fca751f879a7b785160a52f9c3">SendEndSession</a> (OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#ad3673a30d294505c9dbd0049b11607e7">SetEndSessionTimeout</a> (uint32 aTimeout, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a546743e8bc76f6d48d8ec48921f86f59">SetTimerCounter</a> (TPVH324TimerCounter aTimerCounter, uint8 aSeries, uint32 aSeriesOffset, uint32 aValue, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a5ebf56ff34ea8c6b1c12b9c60ba09c73">SetVideoResolutions</a> (<a class="el" href="pv__2way__basic__types_8h.html#a5cb9071bcf8f11ba40a1ae878607005b">TPVDirection</a> aDirection, Oscl_Vector&lt; PVMFVideoResolutionRange, OsclMemAllocator &gt; &amp;aResolutions, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a2f56d97f625c941ee7fc42ee2d0cf603">SendVendorId</a> (OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a52bb3054d63d46894481b80d2ce40980">SendVideoTemporalSpatialTradeoffCommand</a> (TPVChannelId aLogicalChannel, uint8 aTradeoff, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a8341e5d66ac995f318f00704e77b7213">SendVideoTemporalSpatialTradeoffIndication</a> (TPVChannelId aLogicalChannel, uint8 aTradeoff, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a736d5ca6d4be74a4ac9f1a52b187bbe2">SendLogicalChannelActiveIndication</a> (TPVChannelId aLogicalChannel, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a3ca18d2fb8356ef37b5a3d1ac79ae834">SendLogicalChannelInactiveIndication</a> (TPVChannelId aLogicalChannel, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a5d2b169fc25f962fedb1df82c7c73e4c">SendSkewIndication</a> (TPVChannelId aLogicalChannel1, TPVChannelId aLogicalChannel2, uint16 aSkew, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a518cbfffe0353a41efbae82ee492c1b9">SetLogicalChannelBufferingMs</a> (uint32 aInBufferingMs, uint32 aOutBufferingMs, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a8e69d4bfab66431337616153ec199dde">SendUserInput</a> (<a class="el" href="classCPVUserInput.html">CPVUserInput</a> *user_input, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual PVMFCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classH324MConfigInterface.html#a85b0d12f53bf9c13381ca3dde7102808">SetWnsrp</a> (const bool aEnableWnsrp, OsclAny *aContextData=NULL)=0</td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0077d9356fd59f980edeff797917ce75"></a><!-- doxytag: member="H324MConfigInterface::FastUpdate" ref="a0077d9356fd59f980edeff797917ce75" args="(PVMFNodeInterface &amp;aTrack, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::FastUpdate </td>
          <td>(</td>
          <td class="paramtype">PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aTrack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API may be called only after the media source has been successfully added to the pv2way engine. It causes the 2way engine to immediately send out a fast update frame specific to the media type identified by the aTrack parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTrack</em>&nbsp;</td><td>The identifier for the track </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="aa47ae8fca751f879a7b785160a52f9c3"></a><!-- doxytag: member="H324MConfigInterface::SendEndSession" ref="aa47ae8fca751f879a7b785160a52f9c3" args="(OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SendEndSession </td>
          <td>(</td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends an end session command to the peer. Only to be used for testing purposes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a736d5ca6d4be74a4ac9f1a52b187bbe2"></a><!-- doxytag: member="H324MConfigInterface::SendLogicalChannelActiveIndication" ref="a736d5ca6d4be74a4ac9f1a52b187bbe2" args="(TPVChannelId aLogicalChannel, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SendLogicalChannelActiveIndication </td>
          <td>(</td>
          <td class="paramtype">TPVChannelId&nbsp;</td>
          <td class="paramname"> <em>aLogicalChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to send a logicalChannelActive indication to the peer. It is an indication to the peer that the channel that was paused and for which it received logicalChannelInactive indication is now ready to send data on the channel defined by Logical channel Id </p>

</div>
</div>
<a class="anchor" id="a3ca18d2fb8356ef37b5a3d1ac79ae834"></a><!-- doxytag: member="H324MConfigInterface::SendLogicalChannelInactiveIndication" ref="a3ca18d2fb8356ef37b5a3d1ac79ae834" args="(TPVChannelId aLogicalChannel, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SendLogicalChannelInactiveIndication </td>
          <td>(</td>
          <td class="paramtype">TPVChannelId&nbsp;</td>
          <td class="paramname"> <em>aLogicalChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to send a logicalChannelInactive indication to the peer. It is an indication to the peer that the channel has been paused the channel and will not send any data on the channel defined by Logical channel Id </p>

</div>
</div>
<a class="anchor" id="a4b74d4df026bef88f54abc5778c9da71"></a><!-- doxytag: member="H324MConfigInterface::SendRme" ref="a4b74d4df026bef88f54abc5778c9da71" args="(OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SendRme </td>
          <td>(</td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify whether Request Multiplex Entry is sent to the remote terminal after TCS</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aSendRme</em>&nbsp;</td><td>If true, RME is sent to the peer after TCS </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a56f603ea9c90cc49163b72ba9199ec04"></a><!-- doxytag: member="H324MConfigInterface::SendRtd" ref="a56f603ea9c90cc49163b72ba9199ec04" args="(OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SendRtd </td>
          <td>(</td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sends a Round Trip Determination message to the peer and indicates the round trip delay to the caller on completion of the command. The round trip delay is stored in 4 bytes in the local buffer of the completion event in network byte order.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a5d2b169fc25f962fedb1df82c7c73e4c"></a><!-- doxytag: member="H324MConfigInterface::SendSkewIndication" ref="a5d2b169fc25f962fedb1df82c7c73e4c" args="(TPVChannelId aLogicalChannel1, TPVChannelId aLogicalChannel2, uint16 aSkew, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SendSkewIndication </td>
          <td>(</td>
          <td class="paramtype">TPVChannelId&nbsp;</td>
          <td class="paramname"> <em>aLogicalChannel1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPVChannelId&nbsp;</td>
          <td class="paramname"> <em>aLogicalChannel2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&nbsp;</td>
          <td class="paramname"> <em>aSkew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to send a SkewIndication to the peer. Skew is measured in milliseconds, and indicates the maximum number of milliseconds that the data on logicalChannel2 is delayed from the data on logicalChannel1 as delivered to the network transport. </p>

</div>
</div>
<a class="anchor" id="a8e69d4bfab66431337616153ec199dde"></a><!-- doxytag: member="H324MConfigInterface::SendUserInput" ref="a8e69d4bfab66431337616153ec199dde" args="(CPVUserInput *user_input, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SendUserInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCPVUserInput.html">CPVUserInput</a> *&nbsp;</td>
          <td class="paramname"> <em>user_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Causes the pv2way to send the specified user input to the remote terminal using control channel. The user input can be either DTMF ot Alphanumeric </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>user_input</em>&nbsp;</td><td>A pointer to either <a class="el" href="classCPVUserInputDtmf.html">CPVUserInputDtmf</a> or <a class="el" href="classCPVUserInputAlphanumeric.html">CPVUserInputAlphanumeric</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a2f56d97f625c941ee7fc42ee2d0cf603"></a><!-- doxytag: member="H324MConfigInterface::SendVendorId" ref="a2f56d97f625c941ee7fc42ee2d0cf603" args="(OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SendVendorId </td>
          <td>(</td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to send the vendor id info to the peer. Note: Calling this API during call-setup negotiations can affect the time for call-setup adversely. </p>

</div>
</div>
<a class="anchor" id="a52bb3054d63d46894481b80d2ce40980"></a><!-- doxytag: member="H324MConfigInterface::SendVideoTemporalSpatialTradeoffCommand" ref="a52bb3054d63d46894481b80d2ce40980" args="(TPVChannelId aLogicalChannel, uint8 aTradeoff, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SendVideoTemporalSpatialTradeoffCommand </td>
          <td>(</td>
          <td class="paramtype">TPVChannelId&nbsp;</td>
          <td class="paramname"> <em>aLogicalChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&nbsp;</td>
          <td class="paramname"> <em>aTradeoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to send a videoTemporalSpatialTradeOff command to the peer. It is a request to the remote encoder to adjust its encoding in accordance with the tradeoff value. A value of 0 indicates a high spatial resolution and a value of 31 indicates a high frame rate. The values from 0 to 31 indicate monotonically a higher frame rate. Actual values do not correspond to precise values of spatial resolution or frame rate. </p>

</div>
</div>
<a class="anchor" id="a8341e5d66ac995f318f00704e77b7213"></a><!-- doxytag: member="H324MConfigInterface::SendVideoTemporalSpatialTradeoffIndication" ref="a8341e5d66ac995f318f00704e77b7213" args="(TPVChannelId aLogicalChannel, uint8 aTradeoff, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SendVideoTemporalSpatialTradeoffIndication </td>
          <td>(</td>
          <td class="paramtype">TPVChannelId&nbsp;</td>
          <td class="paramname"> <em>aLogicalChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&nbsp;</td>
          <td class="paramname"> <em>aTradeoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to send a videoTemporalSpatialTradeOff command to the peer. It is an indication to the remote decoder that the local encoder has adjusted its encoding parameters according to the tradeoff value. A value of 0 indicates a high spatial resolution and a value of 31 indicates a high frame rate. The values from 0 to 31 indicate monotonically a higher frame rate. Actual values do not correspond to precise values of spatial resolution or frame rate. </p>

</div>
</div>
<a class="anchor" id="a7f8b8631e722052e181fcf23b34be8cf"></a><!-- doxytag: member="H324MConfigInterface::SetAl2SequenceNumbers" ref="a7f8b8631e722052e181fcf23b34be8cf" args="(int32 aSeqNumWidth, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetAl2SequenceNumbers </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aSeqNumWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify the sequence number field for AL2</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aSeqNumWidth</em>&nbsp;</td><td>The number of octets to use for AL2 sequence numbers. Allowed values are 0, 1.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="aee943443772d9d65c292caba8da6adde"></a><!-- doxytag: member="H324MConfigInterface::SetAl3ControlFieldOctets" ref="aee943443772d9d65c292caba8da6adde" args="(int32 aCfo, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetAl3ControlFieldOctets </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aCfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify the control field octets field for AL3</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aCfo</em>&nbsp;</td><td>The number of octets to use for AL3 CFO. Allowed values are 0, 1, 2.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a38d8daa6a6ef075b9ed19f35cc69d965"></a><!-- doxytag: member="H324MConfigInterface::SetALConfiguration" ref="a38d8daa6a6ef075b9ed19f35cc69d965" args="(TPVMediaType_t aMediaType, TPVAdaptationLayer aLayer, bool aAllow, bool aUse=true, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetALConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pv__2way__basic__types_8h.html#af4551e1a20a6ab7cfc828dae30f4e918">TPVMediaType_t</a>&nbsp;</td>
          <td class="paramname"> <em>aMediaType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPVAdaptationLayer&nbsp;</td>
          <td class="paramname"> <em>aLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aAllow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aUse</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify the allowable adaptation layers for audio and video. By default AL2 is allowed for audio and AL2, AL3 are allowed for video</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aMediaType</em>&nbsp;</td><td>The media type, i.e audio, video, data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aLayer</em>&nbsp;</td><td>The adaptation layer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aAllow</em>&nbsp;</td><td>Is this adaptation layer allowed for this media type ? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aUse</em>&nbsp;</td><td>Is this adaptation layer used for video media type ? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a68e9dcfd81664b9fd5a50643a0ec6bca"></a><!-- doxytag: member="H324MConfigInterface::SetCodecPreference" ref="a68e9dcfd81664b9fd5a50643a0ec6bca" args="(Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aIncomingAudio, Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aIncomingVideo, Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aOutGoingAudio, Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;aOutGoingVideo, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetCodecPreference </td>
          <td>(</td>
          <td class="paramtype">Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aIncomingAudio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aIncomingVideo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aOutGoingAudio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Oscl_Vector&lt; PVMFFormatType, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aOutGoingVideo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify the preference order for supported media codecs. If input vector has elements, then only these elements are used in terminal capabilities exchange.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aIncomingAudio</em>&nbsp;</td><td>The incoming audio decoder preference order </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aIncomingVideo</em>&nbsp;</td><td>The incoming video decoder preference order </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aOutgoingAudio</em>&nbsp;</td><td>The outgoing audio encoder preference order </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aOutgoingVideo</em>&nbsp;</td><td>The outgoing video decoder preference order </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ad3673a30d294505c9dbd0049b11607e7"></a><!-- doxytag: member="H324MConfigInterface::SetEndSessionTimeout" ref="ad3673a30d294505c9dbd0049b11607e7" args="(uint32 aTimeout, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetEndSessionTimeout </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aTimeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the disconnect timeout interval.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimeout</em>&nbsp;</td><td>The timeout value in seconds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="aa5b44e5952672117ec71ab3ef97cac40"></a><!-- doxytag: member="H324MConfigInterface::SetFormatSpecificInfo" ref="aa5b44e5952672117ec71ab3ef97cac40" args="(PVMFFormatType aMediaFormat, const uint8 *apFormatSpecificInfo, uint32 aFormatSpecificInfoLen, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetFormatSpecificInfo </td>
          <td>(</td>
          <td class="paramtype">PVMFFormatType&nbsp;</td>
          <td class="paramname"> <em>aMediaFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&nbsp;</td>
          <td class="paramname"> <em>apFormatSpecificInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aFormatSpecificInfoLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify the format specific info for supported media encoders.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aMediaFormat</em>&nbsp;</td><td>The outgoing media format </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>apFormatSpecificInfo</em>&nbsp;</td><td>The format specific info </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aFormatSpecificInfoLen</em>&nbsp;</td><td>The length of the format specific info in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a518cbfffe0353a41efbae82ee492c1b9"></a><!-- doxytag: member="H324MConfigInterface::SetLogicalChannelBufferingMs" ref="a518cbfffe0353a41efbae82ee492c1b9" args="(uint32 aInBufferingMs, uint32 aOutBufferingMs, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetLogicalChannelBufferingMs </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aInBufferingMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aOutBufferingMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to configure the logical channel buffer sizes for incoming and outgoing logical channels. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDirection</em>&nbsp;</td><td>The direction (Rx or Tx). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aBufferingMs</em>&nbsp;</td><td>The amount of buffering in milliseconds. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add70ea9bd47690b9fc8d8c3b27400ac3"></a><!-- doxytag: member="H324MConfigInterface::SetMaxMuxCcsrlSduSize" ref="add70ea9bd47690b9fc8d8c3b27400ac3" args="(int32 aMaxCcsrlSduSize, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetMaxMuxCcsrlSduSize </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aMaxCcsrlSduSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API sets the max ccsrl sdu size</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aMaxCcsrlSduSize</em>&nbsp;</td><td>The max ccsrl sdu size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a9ee9d9c32434b008ebd2f7828869c235"></a><!-- doxytag: member="H324MConfigInterface::SetMaxMuxPduSize" ref="a9ee9d9c32434b008ebd2f7828869c235" args="(int32 aRequestMaxMuxPduSize, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetMaxMuxPduSize </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aRequestMaxMuxPduSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API causes a maxMuxPduSize request to be sent to the remote terminal if set to a valid value (64 - 255). This is done after TCS if the remote terminal supports the maxMuxPduCapability</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aRequestMaxMuxPduSize</em>&nbsp;</td><td>The max mux pdu size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a55cad622e924e65f8647631f3646fbaf"></a><!-- doxytag: member="H324MConfigInterface::SetMaxPduSize" ref="a55cad622e924e65f8647631f3646fbaf" args="(int32 aMaxPduSize, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetMaxPduSize </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aMaxPduSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to limit the size of the outgoing h223 pdus</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aMaxPduSize</em>&nbsp;</td><td>The max pdu size</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ac7612b7b575a771050e6ded2e5c92820"></a><!-- doxytag: member="H324MConfigInterface::SetMaxSduSize" ref="ac7612b7b575a771050e6ded2e5c92820" args="(TPVAdaptationLayer aLayer, int32 aSize, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetMaxSduSize </td>
          <td>(</td>
          <td class="paramtype">TPVAdaptationLayer&nbsp;</td>
          <td class="paramname"> <em>aLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify maximum outgoing sdu sizes for each adaptation layer</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aLayer</em>&nbsp;</td><td>The h223 adaptation layer type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aSize</em>&nbsp;</td><td>The sdu size</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a5cd680f349194228c43504c02438e75d"></a><!-- doxytag: member="H324MConfigInterface::SetMaxSduSizeR" ref="a5cd680f349194228c43504c02438e75d" args="(TPVAdaptationLayer aLayer, int32 aSize, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetMaxSduSizeR </td>
          <td>(</td>
          <td class="paramtype">TPVAdaptationLayer&nbsp;</td>
          <td class="paramname"> <em>aLayer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify maximum incoming sdu sizes for each adaptation layer. This is indicated to the peer via the TCS</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aLayer</em>&nbsp;</td><td>The h223 adaptation layer type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aSize</em>&nbsp;</td><td>The sdu size</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="aa3c60d6e0cb07b46cfa49bb5151487dc"></a><!-- doxytag: member="H324MConfigInterface::SetMultiplexLevel" ref="aa3c60d6e0cb07b46cfa49bb5151487dc" args="(TPVH223Level aLevel, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetMultiplexLevel </td>
          <td>(</td>
          <td class="paramtype">TPVH223Level&nbsp;</td>
          <td class="paramname"> <em>aLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify the starting H223 multiplex level</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aLevel</em>&nbsp;</td><td>The starting H223 multiplex level. Note that the final level that is neotiated will depend on the starting level of the peer</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ab968ad945017b64326b5f7dbedf7d9f6"></a><!-- doxytag: member="H324MConfigInterface::SetObserver" ref="ab968ad945017b64326b5f7dbedf7d9f6" args="(H324MConfigObserver *aObserver)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void H324MConfigInterface::SetObserver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classH324MConfigObserver.html">H324MConfigObserver</a> *&nbsp;</td>
          <td class="paramname"> <em>aObserver</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify separate observers for the 324m interface. Otherwise, the default observers will be used</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aObserver</em>&nbsp;</td><td>the observer for command status and for unsolicited informational events </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af381da913b4a589135424eddd675a364"></a><!-- doxytag: member="H324MConfigInterface::SetTerminalType" ref="af381da913b4a589135424eddd675a364" args="(uint8 aTerminalType, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetTerminalType </td>
          <td>(</td>
          <td class="paramtype">uint8&nbsp;</td>
          <td class="paramname"> <em>aTerminalType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify the terminal type that is advertized to the peer. This can be used to force the local terminal to be master/slave when communicating with a peer 324m terminal for testing purposes.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTerminalType</em>&nbsp;</td><td>The terminal type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a546743e8bc76f6d48d8ec48921f86f59"></a><!-- doxytag: member="H324MConfigInterface::SetTimerCounter" ref="a546743e8bc76f6d48d8ec48921f86f59" args="(TPVH324TimerCounter aTimerCounter, uint8 aSeries, uint32 aSeriesOffset, uint32 aValue, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetTimerCounter </td>
          <td>(</td>
          <td class="paramtype">TPVH324TimerCounter&nbsp;</td>
          <td class="paramname"> <em>aTimerCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&nbsp;</td>
          <td class="paramname"> <em>aSeries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aSeriesOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets an H.324 timer/counter value. This should be called before ConnectL is invoked. The supported timers are: T106 Master Slave Determination (in units of 1s) T101 Capability Exchange (in units of 1s) T103 Uni-directional and Bi-directional Logical Channel Signalling (in units of 1s) T108 Close Logical Channel (in units of 1s) T104 H.223 Multiplex Table (in units of 1s) T109 Mode Request (in units of 1s) T105 Round Trip Delay (in units of 1s) T107 Request Multiplex Entry (in units of 100ms) T401 SRP retransmission (in units of 100ms) The supported counters are: N100 H245 (TCS, MSD) N401 SRP retransmission </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimerCounter</em>&nbsp;</td><td>Identifies whether a timer or counter is being set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aSeries</em>&nbsp;</td><td>Identifies the H.324 timer/counter series. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aSeriesOffset</em>&nbsp;</td><td>Specifies the offset within a particular series. E.g. aTimerCounter=EH324Timer, aSeries=1, aSeriesOffset=1 indicates T101. aTimerCounter=EH324Timer, aSeries=4, aSeriesOffset=1 indicates T401. aTimerCounter=EH324Counter, aSeries=4, aSeriesOffset=1 indicates T401. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aValue</em>&nbsp;</td><td>The new value for the H.324 timer/counter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3f7bb32c9d937a514438c87ad8429e2"></a><!-- doxytag: member="H324MConfigInterface::SetVendor" ref="aa3f7bb32c9d937a514438c87ad8429e2" args="(uint8 cc, uint8 ext, uint32 mc, const uint8 *aProduct, uint16 aProductLen, const uint8 *aVersion, uint16 aVersionLen, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetVendor </td>
          <td>(</td>
          <td class="paramtype">uint8&nbsp;</td>
          <td class="paramname"> <em>cc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&nbsp;</td>
          <td class="paramname"> <em>ext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&nbsp;</td>
          <td class="paramname"> <em>aProduct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&nbsp;</td>
          <td class="paramname"> <em>aProductLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&nbsp;</td>
          <td class="paramname"> <em>aVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&nbsp;</td>
          <td class="paramname"> <em>aVersionLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the vendor identification data. This does not cause the stack to issue a vendor identifiation request. Set to NULL to disable sending vendor id. If set to a valid parameter before Connect, it will cause the stack to automatically send it along with the TCS message. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cc</em>&nbsp;</td><td>T35 Country code </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ext</em>&nbsp;</td><td>T35 Extension </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mc</em>&nbsp;</td><td>T35 Manufacturer code </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aProduct</em>&nbsp;</td><td>Product number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aVersion</em>&nbsp;</td><td>Version number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a5ebf56ff34ea8c6b1c12b9c60ba09c73"></a><!-- doxytag: member="H324MConfigInterface::SetVideoResolutions" ref="a5ebf56ff34ea8c6b1c12b9c60ba09c73" args="(TPVDirection aDirection, Oscl_Vector&lt; PVMFVideoResolutionRange, OsclMemAllocator &gt; &amp;aResolutions, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetVideoResolutions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pv__2way__basic__types_8h.html#a5cb9071bcf8f11ba40a1ae878607005b">TPVDirection</a>&nbsp;</td>
          <td class="paramname"> <em>aDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Oscl_Vector&lt; PVMFVideoResolutionRange, OsclMemAllocator &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aResolutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API allows the user to specify the supported resolutions for video for transmit and receive.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDirection</em>&nbsp;</td><td>The direction (Tx/Rx) for which the capability is specified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aResolutions</em>&nbsp;</td><td>An array of resolutions. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85b0d12f53bf9c13381ca3dde7102808"></a><!-- doxytag: member="H324MConfigInterface::SetWnsrp" ref="a85b0d12f53bf9c13381ca3dde7102808" args="(const bool aEnableWnsrp, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVMFCommandId H324MConfigInterface::SetWnsrp </td>
          <td>(</td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>aEnableWnsrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Causes the pv2way to send the specified user input to the remote terminal using control channel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aEnableWnsrp</em>&nbsp;</td><td>Boolean whether to enable Wnsrp or not </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="tsc__h324m__config__interface_8h_source.html">tsc_h324m_config_interface.h</a></li>
</ul>
</div>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>PV2Way Engine</small>
<address style="align: left;"><small>Posting Version: CORE_9.005.1.1 </small>
</small></address>
</body>
</html>
