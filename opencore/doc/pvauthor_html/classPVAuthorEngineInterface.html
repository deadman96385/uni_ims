<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pvauthor_engine: PVAuthorEngineInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>PVAuthorEngineInterface Class Reference</h1><!-- doxytag: class="PVAuthorEngineInterface" -->
<p><code>#include &lt;<a class="el" href="pvauthorengineinterface_8h_source.html">pvauthorengineinterface.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a09443d26ec730fc32e59eb4556cdf6d1">~PVAuthorEngineInterface</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a5ae7b9ddcf84a87ceeb74885c12c8de0">SetLogAppender</a> (const char *aTag, PVLoggerAppender &amp;aAppender, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#aaa0a44a07ea2dbb866687366f2111856">RemoveLogAppender</a> (const char *aTag, PVLoggerAppender &amp;aAppender, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a51fc903479d98f1f4e81bb9929434f88">SetLogLevel</a> (const char *aTag, int32 aLevel, bool aSetSubtree=false, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a8c76414ab737968ba80844841aa0c387">GetLogLevel</a> (const char *aTag, <a class="el" href="pv__engine__types_8h.html#af588fccba2056bd9f60fa0fde9b7722e">PVLogLevelInfo</a> &amp;aLogInfo, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#abdbf6fe7185ac42f6936b20cbb0ac865">Open</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a3ea76dd182c597135b8eccae63b0c4dd">Close</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a74e4849fdc4ad6053c7eade1351befb8">AddDataSource</a> (const PVMFNodeInterface &amp;aDataSource, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a0acd9b5a4a58df3d0b99650087a97f33">RemoveDataSource</a> (const PVMFNodeInterface &amp;aDataSource, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a009f975cc71d09ce7ae4ab6e936753b0">SelectComposer</a> (const PvmfMimeString &amp;aComposerType, PVInterface *&amp;aConfigInterface, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#aa0e063065217b5087485726f50f8fcc8">SelectComposer</a> (const PVUuid &amp;aComposerUuid, PVInterface *&amp;aConfigInterface, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a009301f258d90699d45f57a1b778c0dc">AddMediaTrack</a> (const PVMFNodeInterface &amp;aDataSource, const PvmfMimeString &amp;aEncoderType, const OsclAny *aComposer, PVInterface *&amp;aConfigInterface, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a8aeb434080dac2dc8dbd2ce417265aaa">AddMediaTrack</a> (const PVMFNodeInterface &amp;aDataSource, const PVUuid &amp;aEncoderUuid, const OsclAny *aComposer, PVInterface *&amp;aConfigInterface, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#ad2896a092239a63f8e45c490ee57df72">AddDataSink</a> (const PVMFNodeInterface &amp;aDataSink, const OsclAny *aComposer, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a45f1eba84964d896f37a8d90c9f88846">RemoveDataSink</a> (const PVMFNodeInterface &amp;aDataSink, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a60a2699e2fa2c519ed9886204a000452">Init</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a80c3345f577d63a534adf197acc21bef">Reset</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a9318eb7b9359beb09029ee74590a8edb">Start</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a0f2df3077f714ef2552315c3c0c508fa">Pause</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a38a3b65ca6ea2dc79b64202be9c05e73">Resume</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a82cd0527ba01db46e6ce517914ef9f37">Stop</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pvauthorengineinterface_8h.html#a26d016a81d853ae9bcc76750700942a3">PVAEState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a08972f7870408489a76cbae247bd0b5c">GetPVAuthorState</a> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#ae7202114710fa1ac3fe3f38bbdf73e2a">QueryInterface</a> (const PVUuid &amp;aUuid, PVInterface *&amp;aInterfacePtr, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#af28d4a85f4af22c537d2ba8000ef001f">GetSDKModuleInfo</a> (<a class="el" href="pv__engine__types_8h.html#a9456e080ab1e16c2fdc52ccf3853f8cc">PVSDKModuleInfo</a> &amp;aSDKModuleInfo, const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#a31f55504a7d2a72a67a7959290851d51">CancelAllCommands</a> (const OsclAny *aContextData=NULL)=0</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPVAuthorEngineInterface.html#ac71bd0c3a96aaa92faa7371e1321232f">GetSDKInfo</a> (<a class="el" href="structPVSDKInfo.html">PVSDKInfo</a> &amp;aSDKInfo)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classPVAuthorEngineInterface.html">PVAuthorEngineInterface</a> </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a09443d26ec730fc32e59eb4556cdf6d1"></a><!-- doxytag: member="PVAuthorEngineInterface::~PVAuthorEngineInterface" ref="a09443d26ec730fc32e59eb4556cdf6d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual PVAuthorEngineInterface::~PVAuthorEngineInterface </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad2896a092239a63f8e45c490ee57df72"></a><!-- doxytag: member="PVAuthorEngineInterface::AddDataSink" ref="ad2896a092239a63f8e45c490ee57df72" args="(const PVMFNodeInterface &amp;aDataSink, const OsclAny *aComposer, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::AddDataSink </td>
          <td>(</td>
          <td class="paramtype">const PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aComposer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a media sink where output data from the specified composer will be written to. Currently this API does not cause any action as it is not relevant.</p>
<p>This command is valid only when pvAuthor Engine is in PVAE_STATE_OPENED state. The referenced composer must be previously selected.</p>
<p>This command does not change the pvAuthor Engine engine state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSink</em>&nbsp;</td><td>Reference to the data sink to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aComposer</em>&nbsp;</td><td>Opaque data identifying the composer to which the data sink will connect to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a74e4849fdc4ad6053c7eade1351befb8"></a><!-- doxytag: member="PVAuthorEngineInterface::AddDataSource" ref="a74e4849fdc4ad6053c7eade1351befb8" args="(const PVMFNodeInterface &amp;aDataSource, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::AddDataSource </td>
          <td>(</td>
          <td class="paramtype">const PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds a media source to be used as input to an authoring session.</p>
<p>This command is valid only when pvAuthor Engine is in PVAE_STATE_OPENED state. This command does not change the pvAuthor Engine engine state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSource</em>&nbsp;</td><td>Reference to the data source </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unique command ID to identify this command in command response </dd></dl>

</div>
</div>
<a class="anchor" id="a8aeb434080dac2dc8dbd2ce417265aaa"></a><!-- doxytag: member="PVAuthorEngineInterface::AddMediaTrack" ref="a8aeb434080dac2dc8dbd2ce417265aaa" args="(const PVMFNodeInterface &amp;aDataSource, const PVUuid &amp;aEncoderUuid, const OsclAny *aComposer, PVInterface *&amp;aConfigInterface, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::AddMediaTrack </td>
          <td>(</td>
          <td class="paramtype">const PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PVUuid &amp;&nbsp;</td>
          <td class="paramname"> <em>aEncoderUuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aComposer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVInterface *&amp;&nbsp;</td>
          <td class="paramname"> <em>aConfigInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a media track to the specified composer.</p>
<p>The source data of this media track will come from the specified data source. pvAuthor engine will encoder of the specified Uuid to encode the source data. A media track will be added to the specified composer, and encoded data will be written to the composer during the authoring session.</p>
<p>A configuration object for the selected composer will be saved to the PVInterface pointer provided in aConfigInterface parameter. User should call queryInterface to query for the configuration interfaces supported by the encoder. Before calling <a class="el" href="classPVAuthorEngineInterface.html#a80c3345f577d63a534adf197acc21bef">Reset()</a>, user must call removeRef on the PVInterface object to remove its reference to the object.</p>
<p>This command is valid only when pvAuthor Engine is in PVAE_STATE_OPENED state. The referenced data source and composer must be already added before this method is called. This command does not change the pvAuthor Engine engine state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSource</em>&nbsp;</td><td>Data source node to provide input data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aEncoderUuid</em>&nbsp;</td><td>Uuid of encoder to encode the source data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aComposer</em>&nbsp;</td><td>Opaque data to identify the composer in which a media track will be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aConfigInterface</em>&nbsp;</td><td>Pointer to configuration object for the selected encoder will be saved to this parameter upon completion of this call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a009301f258d90699d45f57a1b778c0dc"></a><!-- doxytag: member="PVAuthorEngineInterface::AddMediaTrack" ref="a009301f258d90699d45f57a1b778c0dc" args="(const PVMFNodeInterface &amp;aDataSource, const PvmfMimeString &amp;aEncoderType, const OsclAny *aComposer, PVInterface *&amp;aConfigInterface, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::AddMediaTrack </td>
          <td>(</td>
          <td class="paramtype">const PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PvmfMimeString &amp;&nbsp;</td>
          <td class="paramname"> <em>aEncoderType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aComposer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVInterface *&amp;&nbsp;</td>
          <td class="paramname"> <em>aConfigInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a media track to the specified composer.</p>
<p>The source data of this media track will come from the specified data source. pvAuthor engine will select the most suitable available encoder of the specified type. A media track will be added to the specified composer, and encoded data will be written to the composer during the authoring session.</p>
<p>A configuration object for the selected composer will be saved to the PVInterface pointer provided in aConfigInterface parameter. User should call queryInterface to query for the configuration interfaces supported by the encoder. Before calling <a class="el" href="classPVAuthorEngineInterface.html#a80c3345f577d63a534adf197acc21bef">Reset()</a>, user must call removeRef on the PVInterface object to remove its reference to the object.</p>
<p>This command is valid only when pvAuthor Engine is in PVAE_STATE_OPENED state. The referenced data source and composer must be already added before this method is called. This command does not change the pvAuthor Engine engine state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSource</em>&nbsp;</td><td>Data source node to provide input data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aEncoderType</em>&nbsp;</td><td>MIME type of encoder to encode the source data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aComposer</em>&nbsp;</td><td>Opaque data to identify the composer in which a media track will be added. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aConfigInterface</em>&nbsp;</td><td>Pointer to configuration object for the selected encoder will be saved to this parameter upon completion of this call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a31f55504a7d2a72a67a7959290851d51"></a><!-- doxytag: member="PVAuthorEngineInterface::CancelAllCommands" ref="a31f55504a7d2a72a67a7959290851d51" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::CancelAllCommands </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel all pending requests. The current request being processed, if any, will also be aborted. PVAE_CMD_CANCEL_ALL_COMMANDS will be passed to the command observer on completion. Currently this API is NOT SUPPORTED.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a3ea76dd182c597135b8eccae63b0c4dd"></a><!-- doxytag: member="PVAuthorEngineInterface::Close" ref="a3ea76dd182c597135b8eccae63b0c4dd" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::Close </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes an authoring session.</p>
<p>All resources added and allocated to the authoring session will be released.</p>
<p>This command is valid only when pvAuthor engine is in PVAE_STATE_OPENED state and Upon completion of this command, pvAuthor Engine will be in PVAE_STATE_IDLE state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unique command ID to identify this command in command response </dd></dl>

</div>
</div>
<a class="anchor" id="a8c76414ab737968ba80844841aa0c387"></a><!-- doxytag: member="PVAuthorEngineInterface::GetLogLevel" ref="a8c76414ab737968ba80844841aa0c387" args="(const char *aTag, PVLogLevelInfo &amp;aLogInfo, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::GetLogLevel </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pv__engine__types_8h.html#af588fccba2056bd9f60fa0fde9b7722e">PVLogLevelInfo</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aLogInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the logging level to be queried for a particular logging tag. A larger log level will result in more messages being logged.</p>
<p>In the asynchronous response, this should return the log level along with an indication of where the level was inherited (i.e., the ancestor tag). Currently this API is NOT SUPPORTED.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the log level should be retrieved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aLogInfo</em>&nbsp;</td><td>An output parameter which will be filled in with the log level information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memory_error</em>&nbsp;</td><td>leaves on memory allocation error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a08972f7870408489a76cbae247bd0b5c"></a><!-- doxytag: member="PVAuthorEngineInterface::GetPVAuthorState" ref="a08972f7870408489a76cbae247bd0b5c" args="()=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pvauthorengineinterface_8h.html#a26d016a81d853ae9bcc76750700942a3">PVAEState</a> PVAuthorEngineInterface::GetPVAuthorState </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the current state of the pvAuthor Engine. Application may use this info for updating display or determine if the pvAuthor Engine is ready for the next command.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aState</em>&nbsp;</td><td>Output parameter to hold state information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for synchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ac71bd0c3a96aaa92faa7371e1321232f"></a><!-- doxytag: member="PVAuthorEngineInterface::GetSDKInfo" ref="ac71bd0c3a96aaa92faa7371e1321232f" args="(PVSDKInfo &amp;aSDKInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF void PVAuthorEngineInterface::GetSDKInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPVSDKInfo.html">PVSDKInfo</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aSDKInfo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns SDK version information about author engine.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aSDKInfo</em>&nbsp;</td><td>A reference to a <a class="el" href="structPVSDKInfo.html">PVSDKInfo</a> structure which contains product name, supported hardware platform, supported software platform, version, part number, and PV UUID. These fields will contain info .for the currently instantiated pvPlayer engine when this function returns success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af28d4a85f4af22c537d2ba8000ef001f"></a><!-- doxytag: member="PVAuthorEngineInterface::GetSDKModuleInfo" ref="af28d4a85f4af22c537d2ba8000ef001f" args="(PVSDKModuleInfo &amp;aSDKModuleInfo, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::GetSDKModuleInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pv__engine__types_8h.html#a9456e080ab1e16c2fdc52ccf3853f8cc">PVSDKModuleInfo</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aSDKModuleInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns information about all modules currently used by the SDK. Currently this API is NOT SUPPORTED.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aSDKModuleInfo</em>&nbsp;</td><td>A reference to a PVSDKModuleInfo structure which contains the number of modules currently used by pvAuthor Engine and the PV UID and description string for each module. The PV UID and description string for modules will be returned in one string buffer allocated by the client. If the string buffer is not large enough to hold the all the module's information, the information will be written up to the length of the buffer and truncated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a60a2699e2fa2c519ed9886204a000452"></a><!-- doxytag: member="PVAuthorEngineInterface::Init" ref="a60a2699e2fa2c519ed9886204a000452" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::Init </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize an authoring session.</p>
<p>Upon calling this method, no more data sources and sinks can be added to the session. Also, all configuration settings will be locked and cannot be modified until the session is reset by calling <a class="el" href="classPVAuthorEngineInterface.html#a80c3345f577d63a534adf197acc21bef">Reset()</a>. Resources for the session will allocated and initialized to the configuration settings specified. This command is valid only when pvAuthor Engine is in PVAE_STATE_OPENED state.</p>
<p>Upon completion of this command, pvAuthor Engine will be in PVAE_STATE_INITIALIZED state, and the authoring session is ready to start.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="abdbf6fe7185ac42f6936b20cbb0ac865"></a><!-- doxytag: member="PVAuthorEngineInterface::Open" ref="abdbf6fe7185ac42f6936b20cbb0ac865" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::Open </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Opens an authoring session.</p>
<p>This command is valid only when pvAuthor engine is in PVAE_STATE_IDLE state. Upon completion of this method, pvAuthor engine will be in PVAE_STATE_OPENED state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unique command ID to identify this command in command response </dd></dl>

</div>
</div>
<a class="anchor" id="a0f2df3077f714ef2552315c3c0c508fa"></a><!-- doxytag: member="PVAuthorEngineInterface::Pause" ref="a0f2df3077f714ef2552315c3c0c508fa" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::Pause </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pause the authoring session.</p>
<p>The authoring session will be paused and no encoded output data will be sent to the data sink. This function is valid only in the PVAE_STATE_RECORDING state.</p>
<p>Upon completion of this command, pvAuthor Engine will be in PVAE_STATE_PAUSED state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ae7202114710fa1ac3fe3f38bbdf73e2a"></a><!-- doxytag: member="PVAuthorEngineInterface::QueryInterface" ref="ae7202114710fa1ac3fe3f38bbdf73e2a" args="(const PVUuid &amp;aUuid, PVInterface *&amp;aInterfacePtr, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::QueryInterface </td>
          <td>(</td>
          <td class="paramtype">const PVUuid &amp;&nbsp;</td>
          <td class="paramname"> <em>aUuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVInterface *&amp;&nbsp;</td>
          <td class="paramname"> <em>aInterfacePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is to allow for extensibility of the pvAuthor engine interface. It allows a caller to ask for an instance of a particular interface object to be returned. The mechanism is analogous to the COM IUnknown method. The interfaces are identified with an interface ID that is a UUID as in DCE and a pointer to the interface object is returned if it is supported. Otherwise the returned pointer is NULL. TBD: Define the UIID, InterfacePtr structures</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aUuid</em>&nbsp;</td><td>The UUID of the desired interface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aInterfacePtr</em>&nbsp;</td><td>The output pointer to the desired interface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a45f1eba84964d896f37a8d90c9f88846"></a><!-- doxytag: member="PVAuthorEngineInterface::RemoveDataSink" ref="a45f1eba84964d896f37a8d90c9f88846" args="(const PVMFNodeInterface &amp;aDataSink, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::RemoveDataSink </td>
          <td>(</td>
          <td class="paramtype">const PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes a previously added data sink. Currently this API does not cause any action as it is not relevant.</p>
<p>This command is valid only when pvAuthor Engine is in PVAE_STATE_OPENED state. This command does not change the pvAuthor Engine engine state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSink</em>&nbsp;</td><td>Reference to the data sink to be removed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a0acd9b5a4a58df3d0b99650087a97f33"></a><!-- doxytag: member="PVAuthorEngineInterface::RemoveDataSource" ref="a0acd9b5a4a58df3d0b99650087a97f33" args="(const PVMFNodeInterface &amp;aDataSource, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::RemoveDataSource </td>
          <td>(</td>
          <td class="paramtype">const PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unbinds a previously added data source.</p>
<p>This command is valid only when pvAuthor Engine is in PVAE_STATE_OPENED state. This command does not change the pvAuthor Engine engine state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSource</em>&nbsp;</td><td>Reference to the data source to be removed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="aaa0a44a07ea2dbb866687366f2111856"></a><!-- doxytag: member="PVAuthorEngineInterface::RemoveLogAppender" ref="aaa0a44a07ea2dbb866687366f2111856" args="(const char *aTag, PVLoggerAppender &amp;aAppender, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::RemoveLogAppender </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVLoggerAppender &amp;&nbsp;</td>
          <td class="paramname"> <em>aAppender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows a logging appender to be removed from the logger tree at the point specified by the input tag. If the input tag is NULL then the appender will be removed from locations in the tree. Currently this API is NOT SUPPORTED.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the appender should be removed. Can be NULL to remove at all locations. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aAppender</em>&nbsp;</td><td>The log appender to remove. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memory_error</em>&nbsp;</td><td>leaves on memory allocation error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a80c3345f577d63a534adf197acc21bef"></a><!-- doxytag: member="PVAuthorEngineInterface::Reset" ref="a80c3345f577d63a534adf197acc21bef" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::Reset </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset an initialized authoring session.</p>
<p>The authoring session will be stopped and all composers and encoders selected for the session will be removed. All data sources and sinks will be reset but will continue to be available for authoring the next output clip.</p>
<p>User must call removeRef() to remove its reference to any PVInterface objects received from <a class="el" href="classPVAuthorEngineInterface.html#a009f975cc71d09ce7ae4ab6e936753b0">SelectComposer()</a> or <a class="el" href="classPVAuthorEngineInterface.html#a009301f258d90699d45f57a1b778c0dc">AddMediaTrack()</a> or <a class="el" href="classPVAuthorEngineInterface.html#ae7202114710fa1ac3fe3f38bbdf73e2a">QueryInterface()</a> APIs before calling this method. This method would fail otherwise.</p>
<p>This method can be called from ANY state but PVAE_STATE_IDLE. Upon completion of this command, pvAuthor Engine will be in PVAE_STATE_OPENED state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a38a3b65ca6ea2dc79b64202be9c05e73"></a><!-- doxytag: member="PVAuthorEngineInterface::Resume" ref="a38a3b65ca6ea2dc79b64202be9c05e73" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::Resume </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resume a paused authoring session.</p>
<p>The authoring session will be resumed and pvAuthor Engine will resume sending encoded output data to the data sinks. This function is valid only in the PVAE_STATE_PAUSED state.</p>
<p>Upon completion of this command, pvAuthor Engine will be in PVAE_STATE_RECORDING state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="aa0e063065217b5087485726f50f8fcc8"></a><!-- doxytag: member="PVAuthorEngineInterface::SelectComposer" ref="aa0e063065217b5087485726f50f8fcc8" args="(const PVUuid &amp;aComposerUuid, PVInterface *&amp;aConfigInterface, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::SelectComposer </td>
          <td>(</td>
          <td class="paramtype">const PVUuid &amp;&nbsp;</td>
          <td class="paramname"> <em>aComposerUuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVInterface *&amp;&nbsp;</td>
          <td class="paramname"> <em>aConfigInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects an output composer by specifying its Uuid.</p>
<p>pvAuthor engine the composer of the specified Uuid in the authoring session. This command is valid only when pvAuthor Engine is in PVAE_STATE_OPENED state. This command does not change the pvAuthor Engine state.</p>
<p>Upon completion of this command, opaque data to indentify the selected composer is provided in the callback. The user needs to use this opaque data to identify the composer when calling <a class="el" href="classPVAuthorEngineInterface.html#a009301f258d90699d45f57a1b778c0dc">AddMediaTrack()</a>, <a class="el" href="classPVAuthorEngineInterface.html#ad2896a092239a63f8e45c490ee57df72">AddDataSink()</a>. A configuration interface for the selected composer will be saved to the PVInterface pointer provided in aConfigInterface parameter. User should call queryInterface to query for the configuration interfaces supported by the composer. When configuration is complete or before calling <a class="el" href="classPVAuthorEngineInterface.html#a80c3345f577d63a534adf197acc21bef">Reset()</a>, user must call removeRef on the PVInterface object to remove its reference to the object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aComposerUuid</em>&nbsp;</td><td>Uuid of output composer to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aConfigInterface</em>&nbsp;</td><td>Pointer to configuration object for the selected composer will be saved to this parameter upon completion of this call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a009f975cc71d09ce7ae4ab6e936753b0"></a><!-- doxytag: member="PVAuthorEngineInterface::SelectComposer" ref="a009f975cc71d09ce7ae4ab6e936753b0" args="(const PvmfMimeString &amp;aComposerType, PVInterface *&amp;aConfigInterface, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::SelectComposer </td>
          <td>(</td>
          <td class="paramtype">const PvmfMimeString &amp;&nbsp;</td>
          <td class="paramname"> <em>aComposerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVInterface *&amp;&nbsp;</td>
          <td class="paramname"> <em>aConfigInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects an output composer by specifying its MIME type.</p>
<p>pvAuthor engine will use the most suitable output composer of the specified MIME type available in the authoring session. This command is valid only when pvAuthor Engine is in PVAE_STATE_OPENED state. This command does not change the pvAuthor Engine state.</p>
<p>Upon completion of this command, opaque data to indentify the selected composer is provided in the callback. The user needs to use this opaque data to identify the composer when calling <a class="el" href="classPVAuthorEngineInterface.html#a009301f258d90699d45f57a1b778c0dc">AddMediaTrack()</a>, <a class="el" href="classPVAuthorEngineInterface.html#ad2896a092239a63f8e45c490ee57df72">AddDataSink()</a>. A configuration interface for the selected composer will be saved to the PVInterface pointer provided in aConfigInterface parameter. User should call queryInterface to query for the configuration interfaces supported by the composer. When configuration is complete or before calling <a class="el" href="classPVAuthorEngineInterface.html#a80c3345f577d63a534adf197acc21bef">Reset()</a>, user must call removeRef on the PVInterface object to remove its reference to the object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aComposerType</em>&nbsp;</td><td>MIME type of output composer to be used </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aConfigInterface</em>&nbsp;</td><td>Pointer to configuration object for the selected composer will be saved to this parameter upon completion of this call </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a5ae7b9ddcf84a87ceeb74885c12c8de0"></a><!-- doxytag: member="PVAuthorEngineInterface::SetLogAppender" ref="a5ae7b9ddcf84a87ceeb74885c12c8de0" args="(const char *aTag, PVLoggerAppender &amp;aAppender, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::SetLogAppender </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVLoggerAppender &amp;&nbsp;</td>
          <td class="paramname"> <em>aAppender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows a logging appender to be attached at some point in the logger tag tree. The location in the tag tree is specified by the input tag string. A single appender can be attached multiple times in the tree, but it may result in duplicate copies of log messages if the appender is not attached in disjoint portions of the tree. A logging appender is responsible for actually writing the log message to its final location (e.g., memory, file, network, etc). Currently this API is NOT SUPPORTED.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the appender should be attached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aAppender</em>&nbsp;</td><td>The log appender to attach. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memory_error</em>&nbsp;</td><td>leaves on memory allocation error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a51fc903479d98f1f4e81bb9929434f88"></a><!-- doxytag: member="PVAuthorEngineInterface::SetLogLevel" ref="a51fc903479d98f1f4e81bb9929434f88" args="(const char *aTag, int32 aLevel, bool aSetSubtree=false, const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::SetLogLevel </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aSetSubtree</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the logging level to be set for the logging node specified by the tag. A larger log level will result in more messages being logged. A message will only be logged if its level is LESS THAN or equal to the current log level. The set_subtree flag will allow an entire subtree, with the specified tag as the root, to be reset to the specified value. Currently this API is NOT SUPPORTED.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the log level should be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aLevel</em>&nbsp;</td><td>Specifies the log level to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aSetSubtree</em>&nbsp;</td><td>Specifies whether the entire subtree with aTag as the root should be reset to the log level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memory_error</em>&nbsp;</td><td>leaves on memory allocation error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a9318eb7b9359beb09029ee74590a8edb"></a><!-- doxytag: member="PVAuthorEngineInterface::Start" ref="a9318eb7b9359beb09029ee74590a8edb" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::Start </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start the authoring session.</p>
<p>pvAuthor Engine will begin to receive source data, encode them to the specified format and quality, and send the output data to the specified data sinks. This function is valid only in the PVAE_STATE_INITIALIZED state.</p>
<p>Upon completion of this command, pvAuthor Engine will be in PVAE_STATE_RECORDING state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a82cd0527ba01db46e6ce517914ef9f37"></a><!-- doxytag: member="PVAuthorEngineInterface::Stop" ref="a82cd0527ba01db46e6ce517914ef9f37" args="(const OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="pv__engine__types_8h.html#a92105868008db33057f5edd977e95f1e">PVCommandId</a> PVAuthorEngineInterface::Stop </td>
          <td>(</td>
          <td class="paramtype">const OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stops an authoring session.</p>
<p>The authoring session will be stopped and pvAuthor Engine will stop receiving source data from the data sources, and no further encoded data will be sent to the data sinks. This function is valid only in the PVAE_STATE_RECORDING and PVAE_STATE_PAUSED states.</p>
<p>Upon completion of this command, pvAuthor Engine will be in PVAE_STATE_INITIALIZED state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data to be passed back to user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="pvauthorengineinterface_8h_source.html">pvauthorengineinterface.h</a></li>
</ul>
</div>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>PV Author Engine</small>
<address style="align: left;"><small>Posting Version: CORE_9.005.1.1 </small>
</small></address>
</body>
</html>
