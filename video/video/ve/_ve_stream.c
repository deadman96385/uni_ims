/*
 * THIS IS AN UNPUBLISHED WORK CONTAINING D2 TECHNOLOGIES, INC. CONFIDENTIAL
 * AND PROPRIETARY INFORMATION.  IF PUBLICATION OCCURS, THE FOLLOWING NOTICE
 * APPLIES: "COPYRIGHT 2006-2010 D2 TECHNOLOGIES, INC. ALL RIGHTS RESERVED"
 *
 * $D2Tech$ $Rev: 12522 $ $Date: 2010-07-13 18:52:44 -0400 (Tue, 13 Jul 2010) $
 *
 */
#include "_ve_private.h"

/*
 * ======== _VE_videoStreamIsActive() ========
 *
 * Check if there are any active streams.
 */
vint _VE_videoStreamIsActive(
    _VE_Dsp *dsp_ptr)
{
    _VE_StreamObj *stream_ptr;
    vint            infc;
    vint            streamId;

    /*
     * Encode for all physical infc.
     */
    for (infc = VTSP_INFC_VIDEO; infc == VTSP_INFC_VIDEO; infc++) {
        /*
         * Do for all streams on infc.
         */
        for (streamId = _VTSP_STREAM_PER_INFC - 1; streamId >= 0; streamId--) {
            stream_ptr = _VE_streamIdToStreamPtr(dsp_ptr, infc, streamId);
            if (1 == stream_ptr->curActive) {
                return (1);
            }
        }
    }
    return (0);
}

/*
 * ======== _VE_setBlockHdr() ========
 *
 * Set block header information for RTP for packing and sending out blocks
 * generated by the video coders.
 */
void _VE_setBlockHdr(
    _VE_StreamObj    *stream_ptr,
    VTSP_BlockHeader   *hdr_ptr,
    uvint               encType)
{

    hdr_ptr->extension  &= ~(VTSP_MASK_EXT_SEND);

    switch (encType) {
        case VTSP_CODER_VIDEO_H263:
            hdr_ptr->extension |= VTSP_MASK_EXT_SEND;
            if (1 == stream_ptr->enc.marker) {
                hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                stream_ptr->enc.marker = 0;
            }
            return;
        case VTSP_CODER_VIDEO_H264:
            hdr_ptr->extension |= VTSP_MASK_EXT_SEND;
            if (1 == stream_ptr->enc.marker) {
                hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                stream_ptr->enc.marker = 0;
            }
            return;

        case VTSP_CODER_UNAVAIL:
            /* Fall-through */
        default:
            /*
             * May get here if application sets improper encoder.
             * Don't send anything.
             */
            break;
    }
}

/*
 * ======== _VE_videoStreamDecodeDrawData() ========
 *
 * Process audio payload from peer end on stream
 * H.263
 * H.264
 * MUTE
 */
void _VE_videoStreamDecodeDrawData(
    _VE_Obj    *ve_ptr,
    _VE_Queues *q_ptr,
    _VE_Dsp    *dsp_ptr)
{
    _VE_StreamObj   *stream_ptr;
    uint32           streamMask;
    vint             streamId;
    vint             infc;           /* Must be signed */
    vint             streamActive;
    Video_Picture   *pic_ptr;

    for (infc = VTSP_INFC_VIDEO; infc == VTSP_INFC_VIDEO; infc++) {
        /*
         * Set stream active by default.
         */
        streamActive = 1;
        /*
         * Do for all streams on infc.
         */
        for (streamId = _VTSP_STREAM_PER_INFC - 1; streamId >= 0; streamId--) {
            stream_ptr = _VE_streamIdToStreamPtr(dsp_ptr, infc, streamId);
            streamMask = stream_ptr->algStreamState;

            if ((VTSP_STREAM_DIR_RECVONLY != stream_ptr->streamParam.dir) &&
                    (VTSP_STREAM_DIR_SENDRECV != stream_ptr->streamParam.dir)) {
                /*
                 * Skip stream if not receiving.
                 */
                continue;
            }

            if (VTSP_CODER_UNAVAIL == stream_ptr->dec.decoderType) {
                /*
                 * Packets are not being received yet.
                 */
                continue;
            }

            /*
             * If the stream is active, get a new pic from decoder
             */
            pic_ptr = &stream_ptr->dec.streamDecPic;
            pic_ptr->size = 0;
            if (streamActive != 0) {
                if (0 != (_VE_ALG_STREAM_JB & streamMask)) {
                    while (_VE_videoGetRawData(stream_ptr, pic_ptr,
                            stream_ptr->dec.decoderType, infc)) {
                        pic_ptr->id = streamId;
                        /*
                         * Draw
                         */
                        VDD_videoOut(pic_ptr);
                    }
                }
                else {
                    continue;
                }
            }
        }
    }
}


/*
 * ======== _VE_videoStreamShutdownDecoders() ========
 *
 * H.263
 * H.264
 */
void _VE_videoStreamShutdownDecoders(
    _VE_Obj    *ve_ptr,
    _VE_Queues *q_ptr,
    _VE_Dsp    *dsp_ptr)
{
    _VE_StreamObj   *stream_ptr;
    vint             streamId;
    vint             infc;           /* Must be signed */
    vint             decType;

    /*
     * Decode for all physical infc.
     */
    for (infc = VTSP_INFC_VIDEO; infc == VTSP_INFC_VIDEO; infc++) {
        /*
         * Do for all streams on infc.
         */
        for (streamId = _VTSP_STREAM_PER_INFC - 1; streamId >= 0; streamId--) {
            stream_ptr = _VE_streamIdToStreamPtr(dsp_ptr, infc, streamId);
            decType    = stream_ptr->dec.decoderType;
            _VE_shutDecoder(dsp_ptr, stream_ptr, decType);
        }
    }
}

/*
 * ======== _VE_videoStreamShutdownEncoders() ========
 * This is called in encoder task context only
 *
 * H.263
 * H.264
 */
void _VE_videoStreamShutdownEncoders(
    _VE_Obj    *ve_ptr,
    _VE_Queues *q_ptr,
    _VE_Dsp    *dsp_ptr)
{
    _VE_StreamObj   *stream_ptr;
    vint             streamId;
    vint             infc;           /* Must be signed */
    vint             encType;

    _VE_TRACE(__FILE__, __LINE__);

    /*
     * Decode for all physical infc.
     */
    for (infc = VTSP_INFC_VIDEO; infc == VTSP_INFC_VIDEO; infc++) {
        /*
         * Do for all streams on infc.
         */
        for (streamId = _VTSP_STREAM_PER_INFC - 1; streamId >= 0; streamId--) {
            stream_ptr = _VE_streamIdToStreamPtr(dsp_ptr, infc, streamId);
            encType    = stream_ptr->enc.lastEncoder;
            _VE_shutEncoder(dsp_ptr, stream_ptr, encType);
        }
    }
}


/*
 * ======== _VE_videoStreamDecode() ========
 *
 * Process audio payload from peer end on stream
 * H.263
 * H.264
 * MUTE
 */
void _VE_videoStreamDecode(
    _VE_Obj    *ve_ptr,
    _VE_Queues *q_ptr,
    _VE_Dsp    *dsp_ptr)
{
    _VE_StreamObj   *stream_ptr;
    vint            *decIn_ptr;
    uint32           streamMask;
    vint             streamId;
    vint             infc;           /* Must be signed */
    vint             pSize;
    vint             decType;
    vint             streamActive;
    Video_Packet     pkt;

    /*
     * Decode for all physical infc.
     */
    for (infc = VTSP_INFC_VIDEO; infc == VTSP_INFC_VIDEO; infc++) {
        /*
         * Set stream active by default.
         */
        streamActive = 1;
        /*
         * Do for all streams on infc.
         */
        for (streamId = _VTSP_STREAM_PER_INFC - 1; streamId >= 0; streamId--) {
            stream_ptr = _VE_streamIdToStreamPtr(dsp_ptr, infc, streamId);
            streamMask = stream_ptr->algStreamState;

            /*
             * RTCP packets are sent whenever the network is active. They are
             * not sent if the stream peer is local.
             */
            if (VTSP_STREAM_PEER_NETWORK == stream_ptr->streamParam.peer) {
                _VE_rtcpSend(ve_ptr, q_ptr, dsp_ptr,
                        stream_ptr, infc, streamId);
            }

            if ((VTSP_STREAM_DIR_RECVONLY != stream_ptr->streamParam.dir) &&
                    (VTSP_STREAM_DIR_SENDRECV != stream_ptr->streamParam.dir)) {
                /*
                 * Skip stream if not receiving.
                 */
                continue;
            }

            /*
             * If the stream is active, get the current packet from jitter
             * buffer.
             */
            if (streamActive != 0) {
                if (0 != (_VE_ALG_STREAM_JB & streamMask)) {
                    JBV_getPkt(&stream_ptr->dec.jbObj, &dsp_ptr->jbPkt);

                    /*
                     * After adding JB, move the source pointer from RTP.
                     */
                    if ((0 == dsp_ptr->jbPkt.valid)
                            || (0 == dsp_ptr->jbPkt.pSize)) {
                        continue;
                    }
                    decIn_ptr  = (vint  *)dsp_ptr->jbPkt.data_ptr;
                    pSize      = dsp_ptr->jbPkt.pSize;
                    decType    = dsp_ptr->jbPkt.type;
                }
                else {
                    continue;
                }
            }

            /*
             * Decode far end data and place in proper stream array.
             * Get a pointer decOut_ptr for writing data into audio
             */
            if (pSize > 0) {
                /*
                 * Payload size must be greater than zero to change coder
                 * type.  Check if coder type has changed, init old coder
                 * type.  Set new decoder type in object.
                 */
                if (decType != stream_ptr->dec.decoderType) {
                    /*
                     * Init the coder if there was a change.
                     */
                    _VE_shutDecoder(dsp_ptr, stream_ptr, 
                            stream_ptr->dec.decoderType);
                    _VE_initDecoder(dsp_ptr, stream_ptr, decType);
                    stream_ptr->dec.decoderType = decType;
                    stream_ptr->dec.width = 0;
                    stream_ptr->dec.height = 0;
                }
                pkt.buf_ptr = decIn_ptr;
                pkt.ts = dsp_ptr->jbPkt.ts;
                pkt.seqn = dsp_ptr->jbPkt.seqn;
                pkt.sz = pSize;
                pkt.mark = dsp_ptr->jbPkt.mark;
                _VE_videoCodedToRaw(stream_ptr, &pkt, decType, infc);
            }
        }
    }
}

/*
 * ======== _VE_videoStreamEncode() ========
 *
 * Process audio to peer end on stream
 * This is called in encoder task context only
 *
 * H263
 * H264
 *
 */
void _VE_videoStreamEncode(
    _VE_Obj    *ve_ptr,
    _VE_Queues *q_ptr,
    _VE_Dsp    *dsp_ptr)
{
    _VE_StreamObj *stream_ptr;
    vint            encType;
    vint            infc;
    vint            streamId;

    /*
     * Encode for all physical infc.
     */
    for (infc = VTSP_INFC_VIDEO; infc == VTSP_INFC_VIDEO; infc++) {

        /*
         * Do for all streams on infc.
         */
        for (streamId = _VTSP_STREAM_PER_INFC - 1; streamId >= 0; streamId--) {
            stream_ptr = _VE_streamIdToStreamPtr(dsp_ptr, infc, streamId);

            /*
             * Check for SEND stream direction.
             */
            if ((VTSP_STREAM_DIR_SENDONLY != stream_ptr->streamParam.dir) &&
                    (VTSP_STREAM_DIR_SENDRECV != stream_ptr->streamParam.dir)) {
                /*
                 * Not sending; skip encode
                 *
                 * Should never get here
                 */
                continue;
            }

            /*
             * Check encoder type.
             */
            encType = stream_ptr->streamParam.encoder;

            /*
             * If encoder type or camera width/height/format changed,
             * reinit or init the new encoder
             */
            if (encType != stream_ptr->enc.lastEncoder) {
                _VE_TRACE(__FILE__, __LINE__);        
                /*
                 * Init
                 */
                _VE_shutEncoder(dsp_ptr, stream_ptr, 
                        stream_ptr->enc.lastEncoder);
                _VE_initEncoder(dsp_ptr, stream_ptr, encType);
                stream_ptr->enc.lastEncoder = encType;
            }
            else if ((stream_ptr->enc.streamEncPic.width != dsp_ptr->pic.width) ||
                    (stream_ptr->enc.streamEncPic.height != dsp_ptr->pic.height) ||
                    (stream_ptr->enc.streamEncPic.format != dsp_ptr->pic.format)) {
                _VE_TRACE(__FILE__, __LINE__);        
                /*
                 * Reinit, but dont if just inited.
                 */
                _VE_shutEncoder(dsp_ptr, stream_ptr, encType);
                _VE_initEncoder(dsp_ptr, stream_ptr, encType);
            }

            /*
             * Key frame generation.
             */
            if (stream_ptr->enc.requestKey) {
                _VE_videoRequestKeyFrame(stream_ptr, encType, infc);
                stream_ptr->enc.requestKey = 0;
            }

            /*
             * Change of resolution request.
             */
            if ((0 != stream_ptr->enc.requestedWidth) &&
                    (0 != stream_ptr->enc.requestedHeight)) {

                /*
                 * Notify encoder.
                 * Hopefully there is a scaling function in the encoder.
                 */
                if (!_VE_videoRequestResolutionChange(stream_ptr, encType,
                        stream_ptr->enc.requestedWidth,
                        stream_ptr->enc.requestedHeight,
                        infc)) {
                        _VE_TRACE(__FILE__,__LINE__);
                }

                /*
                 * Notify app.
                 * Hopefully it can change.
                 */
                if (0 != VCD_requestResolution(stream_ptr->enc.requestedWidth,
                        stream_ptr->enc.requestedHeight)) {
                    /*
                     * Not possible to change resolution.
                     */
                    _VE_TRACE(__FILE__,__LINE__);
                }
                
                stream_ptr->enc.requestedWidth = 0;
                stream_ptr->enc.requestedHeight = 0;
            }

            OSAL_memCpy(&stream_ptr->enc.streamEncPic, &dsp_ptr->pic,
                    sizeof(stream_ptr->enc.streamEncPic));

            /*
             * Encode.
             */
            if ((stream_ptr->streamParam.encodeType[encType] 
                    != VTSP_CODER_UNAVAIL)) {
                /*
                 * Encode
                 */
                _VE_videoRawToCoded(stream_ptr,
                        &stream_ptr->enc.streamEncPic, encType, infc);
            }
        }
    }
}

/*
 * ======== _VE_videoStreamEncodeSendData() ========
 *
 * Process audio to peer end on stream
 * This is called in encoder task context only
 *
 * H263
 * H264
 *
 */
void _VE_videoStreamEncodeSendData(
    _VE_Obj    *ve_ptr,
    _VE_Queues *q_ptr,
    _VE_Dsp    *dsp_ptr)
{
    VTSP_BlockHeader  blockHeader;
    _VE_NetObj       *net_ptr;
    _VE_RtpObject    *rtp_ptr;
    vint              encType;
    Video_Packet      pkt;
    _VE_StreamObj    *stream_ptr;
    vint              infc;
    vint              streamId;

    for (infc = VTSP_INFC_VIDEO; infc == VTSP_INFC_VIDEO; infc++) {
        /*
         * Do for all streams on infc.
         */
        for (streamId = _VTSP_STREAM_PER_INFC - 1; streamId >= 0; streamId--) {
            stream_ptr = _VE_streamIdToStreamPtr(dsp_ptr, infc, streamId);

            /*
             * For the stream, sum all active peer streams, and
             * put the sum in a dsp_ptr->confBuffer (a stack buffer) 
             * for encoding to that stream.
             */

            /*
             * Check for SEND stream direction.
             */
            if ((VTSP_STREAM_DIR_SENDONLY != stream_ptr->streamParam.dir) &&
                    (VTSP_STREAM_DIR_SENDRECV != stream_ptr->streamParam.dir)) {
                /*
                 * Not sending; skip encode
                 *
                 * Should never get here
                 */
                continue;
            }

            encType = stream_ptr->streamParam.encoder;
            net_ptr = ve_ptr->net_ptr;


            if ((stream_ptr->streamParam.encodeType[encType] 
                    != VTSP_CODER_UNAVAIL)) {
                /*
                 * Get Data
                 */

                rtp_ptr = _VE_streamIdToRtpPtr(net_ptr, infc,
                        stream_ptr->streamParam.streamId);

                pkt.buf_ptr = rtp_ptr->sendRtpObj.pkt.payload;

                while (_VE_videoGetCodedData(stream_ptr, &pkt, encType, infc)) {

                    /*
                     * Fill in BlockHeader here
                     */
                    stream_ptr->enc.marker = pkt.mark;
                    blockHeader.extension = 0;
                    _VE_setBlockHdr(stream_ptr, &blockHeader, encType);
                    blockHeader.dynamicCoder = _VE_localToDynamicEncoder(
                            &stream_ptr->streamParam, encType);
                    blockHeader.localCoder = encType;
                    blockHeader.infc         = infc;
                    blockHeader.streamId     = stream_ptr->streamParam.streamId;
                    rtp_ptr->payloadOffset = pkt.sz;
                    rtp_ptr->rtpTime = (uint32)pkt.ts & 0xFFFFFFFF;

                    /*
                     * Call _VE_rtpSend().
                     *
                     * Call _VE_rtpSend() to transmit data to network.
                     * The block data is in network byte order.
                     */
                    _VE_rtpSend(ve_ptr, rtp_ptr, &blockHeader, NULL, 0, 0);
                }
            }
        }
    }
}
