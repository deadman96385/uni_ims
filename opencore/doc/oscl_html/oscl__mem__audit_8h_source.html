<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>oscl: oscl_mem_audit.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>oscl_mem_audit.h</h1><a href="oscl__mem__audit_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// -*- c++ -*-</span>
<a name="l00002"></a>00002 <span class="comment">// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</span>
<a name="l00003"></a>00003 
<a name="l00004"></a>00004 <span class="comment">//                   O S C L _ M E M _ A U D I T</span>
<a name="l00005"></a>00005 
<a name="l00006"></a>00006 <span class="comment">// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</span>
<a name="l00007"></a>00007 
<a name="l00018"></a>00018 <span class="preprocessor">#ifndef OSCL_MEM_AUDIT_H_INCLUDED</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span><span class="preprocessor">#define OSCL_MEM_AUDIT_H_INCLUDED</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span>
<a name="l00021"></a>00021 <span class="preprocessor">#ifndef OSCL_LOCK_BASE_H_INCLUDED</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="oscl__lock__base_8h.html" title="This file defines an abstract lock class, OsclLockBase, that is used for APIs potentially...">oscl_lock_base.h</a>&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#endif</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a>00025 <span class="preprocessor">#ifndef OSCL_BASE_ALLOC_H_INCLUDED</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="oscl__base__alloc_8h.html" title="A basic allocator that does not rely on other modules.">oscl_base_alloc.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a>00029 <span class="preprocessor">#ifndef OSCL_TAGTREE_H_INCLUDED</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="oscl__tagtree_8h.html" title="The file oscl_tagtree.h ...">oscl_tagtree.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#endif</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span>
<a name="l00033"></a>00033 <span class="preprocessor">#ifndef OSCL_MEM_H_INCLUDED</span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="oscl__mem_8h.html" title="This file contains basic memory definitions for common use across platforms.">oscl_mem.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#endif</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span>
<a name="l00037"></a>00037 <span class="preprocessor">#ifndef OSCL_MEM_AUTO_PTR_H_INCLUDED</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="oscl__mem__auto__ptr_8h.html" title="This file defines the oscl_mem_auto_ptr template class. This class is used to avoid...">oscl_mem_auto_ptr.h</a>&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#endif</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a><a class="code" href="group__osclmemory.html#ga9fcc278d0a7a8d1c95f95c3bd7067994">00041</a> <span class="preprocessor">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="osclconfig__compiler__warnings_8h.html" title="This file contains the ability to turn off/on compiler warnings.">osclconfig_compiler_warnings.h</a>&quot;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="comment">/* DATA TYPES */</span>
<a name="l00046"></a><a class="code" href="structMM__Stats__t.html">00046</a> <span class="keyword">struct </span><a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>
<a name="l00047"></a>00047 {
<a name="l00048"></a><a class="code" href="structMM__Stats__t.html#ae9b8fcb49642967e7b7b24f5e085583e">00048</a>     uint32  <a class="code" href="structMM__Stats__t.html#ae9b8fcb49642967e7b7b24f5e085583e">numBytes</a>;
<a name="l00049"></a><a class="code" href="structMM__Stats__t.html#a82809c6080573ef07492ba03cf4011da">00049</a>     uint32  <a class="code" href="structMM__Stats__t.html#a82809c6080573ef07492ba03cf4011da">peakNumBytes</a>;
<a name="l00050"></a><a class="code" href="structMM__Stats__t.html#a4ee4cdd642eca951947bff9d5b316afb">00050</a>     uint32  <a class="code" href="structMM__Stats__t.html#a4ee4cdd642eca951947bff9d5b316afb">numAllocs</a>;
<a name="l00051"></a><a class="code" href="structMM__Stats__t.html#af1b8545eeb4e3bb3078f7be3d31555fd">00051</a>     uint32  <a class="code" href="structMM__Stats__t.html#af1b8545eeb4e3bb3078f7be3d31555fd">peakNumAllocs</a>;
<a name="l00052"></a><a class="code" href="structMM__Stats__t.html#a16096b32c5ba5e5cad414fec4403a592">00052</a>     uint32  <a class="code" href="structMM__Stats__t.html#a16096b32c5ba5e5cad414fec4403a592">numAllocFails</a>;
<a name="l00053"></a><a class="code" href="structMM__Stats__t.html#a11a0cc3ed0ce9cf7494c38961295224f">00053</a>     uint32  <a class="code" href="structMM__Stats__t.html#a11a0cc3ed0ce9cf7494c38961295224f">totalNumAllocs</a>;
<a name="l00054"></a><a class="code" href="structMM__Stats__t.html#aa28457c6ba0110855868651033d7c96f">00054</a>     uint32  <a class="code" href="structMM__Stats__t.html#aa28457c6ba0110855868651033d7c96f">totalNumBytes</a>;
<a name="l00055"></a>00055 
<a name="l00056"></a><a class="code" href="structMM__Stats__t.html#acc76e5a70cf63bf8f10961d6ac25285e">00056</a>     <a class="code" href="structMM__Stats__t.html#acc76e5a70cf63bf8f10961d6ac25285e">MM_Stats_t</a>()
<a name="l00057"></a>00057     {
<a name="l00058"></a>00058         <a class="code" href="group__osclmemory.html#ga93ce8ea351e601f7d68094199190178b">oscl_memset</a>(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>));
<a name="l00059"></a>00059     };
<a name="l00060"></a><a class="code" href="structMM__Stats__t.html#a9ff4b68705841d01371fb6a540e8a0ff">00060</a>     <a class="code" href="structMM__Stats__t.html#acc76e5a70cf63bf8f10961d6ac25285e">MM_Stats_t</a>(uint32 sizeIn)
<a name="l00061"></a>00061     {
<a name="l00062"></a>00062         <a class="code" href="structMM__Stats__t.html#ae9b8fcb49642967e7b7b24f5e085583e">numBytes</a> = <a class="code" href="structMM__Stats__t.html#a82809c6080573ef07492ba03cf4011da">peakNumBytes</a> = sizeIn;
<a name="l00063"></a>00063         <a class="code" href="structMM__Stats__t.html#af1b8545eeb4e3bb3078f7be3d31555fd">peakNumAllocs</a> = <a class="code" href="structMM__Stats__t.html#a4ee4cdd642eca951947bff9d5b316afb">numAllocs</a> = 1;
<a name="l00064"></a>00064         <a class="code" href="structMM__Stats__t.html#a16096b32c5ba5e5cad414fec4403a592">numAllocFails</a> = 0;
<a name="l00065"></a>00065         <a class="code" href="structMM__Stats__t.html#a11a0cc3ed0ce9cf7494c38961295224f">totalNumAllocs</a> = 1;
<a name="l00066"></a>00066         <a class="code" href="structMM__Stats__t.html#aa28457c6ba0110855868651033d7c96f">totalNumBytes</a> = sizeIn;
<a name="l00067"></a>00067     };
<a name="l00068"></a>00068 
<a name="l00069"></a><a class="code" href="structMM__Stats__t.html#a78ca17f36df6a0620b44c9435ad665ac">00069</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__Stats__t.html#a78ca17f36df6a0620b44c9435ad665ac">reset</a>()
<a name="l00070"></a>00070     {
<a name="l00071"></a>00071         <a class="code" href="group__osclmemory.html#ga93ce8ea351e601f7d68094199190178b">oscl_memset</a>(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>));
<a name="l00072"></a>00072     };
<a name="l00073"></a>00073 
<a name="l00074"></a><a class="code" href="structMM__Stats__t.html#a982add90ea151f03bcdc2482dfce1faa">00074</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__Stats__t.html#a982add90ea151f03bcdc2482dfce1faa">update</a>(<span class="keyword">const</span> <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>&amp; delta, <span class="keywordtype">bool</span> add)
<a name="l00075"></a>00075     {
<a name="l00076"></a>00076         <span class="keywordflow">if</span> (add)
<a name="l00077"></a>00077         {
<a name="l00078"></a>00078             <a class="code" href="structMM__Stats__t.html#ae9b8fcb49642967e7b7b24f5e085583e">numBytes</a> += delta.<a class="code" href="structMM__Stats__t.html#ae9b8fcb49642967e7b7b24f5e085583e">numBytes</a>;
<a name="l00079"></a>00079             <a class="code" href="structMM__Stats__t.html#a4ee4cdd642eca951947bff9d5b316afb">numAllocs</a> += delta.<a class="code" href="structMM__Stats__t.html#a4ee4cdd642eca951947bff9d5b316afb">numAllocs</a>;
<a name="l00080"></a>00080             <a class="code" href="structMM__Stats__t.html#a16096b32c5ba5e5cad414fec4403a592">numAllocFails</a> += delta.<a class="code" href="structMM__Stats__t.html#a16096b32c5ba5e5cad414fec4403a592">numAllocFails</a>;
<a name="l00081"></a>00081             <span class="keywordflow">if</span> (<a class="code" href="structMM__Stats__t.html#ae9b8fcb49642967e7b7b24f5e085583e">numBytes</a> &gt; <a class="code" href="structMM__Stats__t.html#a82809c6080573ef07492ba03cf4011da">peakNumBytes</a>)
<a name="l00082"></a>00082             {
<a name="l00083"></a>00083                 <a class="code" href="structMM__Stats__t.html#a82809c6080573ef07492ba03cf4011da">peakNumBytes</a> = <a class="code" href="structMM__Stats__t.html#ae9b8fcb49642967e7b7b24f5e085583e">numBytes</a>;
<a name="l00084"></a>00084             }
<a name="l00085"></a>00085             <span class="keywordflow">if</span> (<a class="code" href="structMM__Stats__t.html#a4ee4cdd642eca951947bff9d5b316afb">numAllocs</a> &gt; <a class="code" href="structMM__Stats__t.html#af1b8545eeb4e3bb3078f7be3d31555fd">peakNumAllocs</a>)
<a name="l00086"></a>00086             {
<a name="l00087"></a>00087                 <a class="code" href="structMM__Stats__t.html#af1b8545eeb4e3bb3078f7be3d31555fd">peakNumAllocs</a> = <a class="code" href="structMM__Stats__t.html#a4ee4cdd642eca951947bff9d5b316afb">numAllocs</a>;
<a name="l00088"></a>00088             }
<a name="l00089"></a>00089 
<a name="l00090"></a>00090             <a class="code" href="structMM__Stats__t.html#a11a0cc3ed0ce9cf7494c38961295224f">totalNumAllocs</a> += delta.<a class="code" href="structMM__Stats__t.html#a4ee4cdd642eca951947bff9d5b316afb">numAllocs</a>;
<a name="l00091"></a>00091             <a class="code" href="structMM__Stats__t.html#aa28457c6ba0110855868651033d7c96f">totalNumBytes</a> += delta.<a class="code" href="structMM__Stats__t.html#ae9b8fcb49642967e7b7b24f5e085583e">numBytes</a>;
<a name="l00092"></a>00092 
<a name="l00093"></a>00093         }
<a name="l00094"></a>00094         <span class="keywordflow">else</span>
<a name="l00095"></a>00095         {
<a name="l00096"></a>00096             <a class="code" href="structMM__Stats__t.html#ae9b8fcb49642967e7b7b24f5e085583e">numBytes</a> -= delta.<a class="code" href="structMM__Stats__t.html#ae9b8fcb49642967e7b7b24f5e085583e">numBytes</a>;
<a name="l00097"></a>00097             <a class="code" href="structMM__Stats__t.html#a4ee4cdd642eca951947bff9d5b316afb">numAllocs</a> -= delta.<a class="code" href="structMM__Stats__t.html#a4ee4cdd642eca951947bff9d5b316afb">numAllocs</a>;
<a name="l00098"></a>00098             <a class="code" href="structMM__Stats__t.html#a16096b32c5ba5e5cad414fec4403a592">numAllocFails</a> -= delta.<a class="code" href="structMM__Stats__t.html#a16096b32c5ba5e5cad414fec4403a592">numAllocFails</a>;
<a name="l00099"></a>00099         }
<a name="l00100"></a>00100     }
<a name="l00101"></a>00101 
<a name="l00102"></a><a class="code" href="structMM__Stats__t.html#aff2a75ed0789fe9bcdc04a59404f30a4">00102</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__Stats__t.html#aff2a75ed0789fe9bcdc04a59404f30a4">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> size)
<a name="l00103"></a>00103     {
<a name="l00104"></a>00104         <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00105"></a>00105         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_Stats_t, OsclMemBasicAllocator&gt;</a> statsAlloc;
<a name="l00106"></a>00106         <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a> *ptr = statsAlloc.<a class="code" href="classOscl__TAlloc.html#abd4d816b6b4c0cebc5e1bb32982c0483">allocate</a>(1);
<a name="l00107"></a>00107         <span class="keywordflow">return</span> ptr;
<a name="l00108"></a>00108     };
<a name="l00109"></a>00109 
<a name="l00110"></a><a class="code" href="structMM__Stats__t.html#a4df5e70ce805e0e8505c41f82d3bf5b6">00110</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__Stats__t.html#aff2a75ed0789fe9bcdc04a59404f30a4">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> size, <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>* ptr)
<a name="l00111"></a>00111     {
<a name="l00112"></a>00112         <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00113"></a>00113         <span class="keywordflow">return</span> ptr;
<a name="l00114"></a>00114     };
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 
<a name="l00117"></a><a class="code" href="structMM__Stats__t.html#a550d0b8623e028f5919431b4ab021b75">00117</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__Stats__t.html#a550d0b8623e028f5919431b4ab021b75">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
<a name="l00118"></a>00118     {
<a name="l00119"></a>00119         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_Stats_t, OsclMemBasicAllocator&gt;</a> statsAlloc;
<a name="l00120"></a>00120         statsAlloc.<a class="code" href="classOscl__TAlloc.html#aad556619cdcb4169d32df057fa4bce93">deallocate</a>((<a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>*)ptr);
<a name="l00121"></a>00121     };
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="comment">/* won&#39;t build on ADS</span>
<a name="l00124"></a>00124 <span class="comment">    void operator delete(void *ptr, MM_Stats_t* mptr) {</span>
<a name="l00125"></a>00125 <span class="comment">         OSCL_UNUSED_ARG(ptr);</span>
<a name="l00126"></a>00126 <span class="comment">         OSCL_UNUSED_ARG(mptr);</span>
<a name="l00127"></a>00127 <span class="comment">     };</span>
<a name="l00128"></a>00128 <span class="comment">         */</span>
<a name="l00129"></a>00129 };
<a name="l00130"></a>00130 
<a name="l00131"></a><a class="code" href="structMM__FailInsertParam.html">00131</a> <span class="keyword">struct </span><a class="code" href="structMM__FailInsertParam.html">MM_FailInsertParam</a>
<a name="l00132"></a>00132 {
<a name="l00133"></a><a class="code" href="structMM__FailInsertParam.html#a01011fc613ec52f0f0c0d53a7093eb57">00133</a>     uint32 <a class="code" href="structMM__FailInsertParam.html#a01011fc613ec52f0f0c0d53a7093eb57">nAllocNum</a>;
<a name="l00134"></a><a class="code" href="structMM__FailInsertParam.html#a258f41f28d6b0a22ef199a9f598a26df">00134</a>     uint16 <a class="code" href="structMM__FailInsertParam.html#a258f41f28d6b0a22ef199a9f598a26df">xsubi</a>[3];
<a name="l00135"></a><a class="code" href="structMM__FailInsertParam.html#a7096781f88143b7c378b84cbb9722ae1">00135</a>     <a class="code" href="structMM__FailInsertParam.html#a7096781f88143b7c378b84cbb9722ae1">MM_FailInsertParam</a>(): <a class="code" href="structMM__FailInsertParam.html#a01011fc613ec52f0f0c0d53a7093eb57">nAllocNum</a>(0)
<a name="l00136"></a>00136     {
<a name="l00137"></a>00137         <a class="code" href="group__osclmemory.html#ga93ce8ea351e601f7d68094199190178b">oscl_memset</a>(<a class="code" href="structMM__FailInsertParam.html#a258f41f28d6b0a22ef199a9f598a26df">xsubi</a>, 0, 3*<span class="keyword">sizeof</span>(<a class="code" href="structMM__FailInsertParam.html#a258f41f28d6b0a22ef199a9f598a26df">xsubi</a>[0]));
<a name="l00138"></a>00138     }
<a name="l00139"></a>00139 
<a name="l00140"></a><a class="code" href="structMM__FailInsertParam.html#ae23e7c1bcdeb1eb080399a704f760dc6">00140</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__FailInsertParam.html#ae23e7c1bcdeb1eb080399a704f760dc6">reset</a>()
<a name="l00141"></a>00141     {
<a name="l00142"></a>00142         <a class="code" href="structMM__FailInsertParam.html#a01011fc613ec52f0f0c0d53a7093eb57">nAllocNum</a> = 0;
<a name="l00143"></a>00143         <a class="code" href="group__osclmemory.html#ga93ce8ea351e601f7d68094199190178b">oscl_memset</a>(<a class="code" href="structMM__FailInsertParam.html#a258f41f28d6b0a22ef199a9f598a26df">xsubi</a>, 0, 3*<span class="keyword">sizeof</span>(<a class="code" href="structMM__FailInsertParam.html#a258f41f28d6b0a22ef199a9f598a26df">xsubi</a>[0]));
<a name="l00144"></a>00144     };
<a name="l00145"></a>00145 
<a name="l00146"></a><a class="code" href="structMM__FailInsertParam.html#ad3d641024290ff0dfe3538054d83adee">00146</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__FailInsertParam.html#ad3d641024290ff0dfe3538054d83adee">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> size)
<a name="l00147"></a>00147     {
<a name="l00148"></a>00148         <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00149"></a>00149         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_FailInsertParam, OsclMemBasicAllocator&gt;</a> failAlloc;
<a name="l00150"></a>00150         <a class="code" href="structMM__FailInsertParam.html">MM_FailInsertParam</a> *ptr = failAlloc.<a class="code" href="classOscl__TAlloc.html#abd4d816b6b4c0cebc5e1bb32982c0483">allocate</a>(1);
<a name="l00151"></a>00151         <span class="keywordflow">return</span> ptr;
<a name="l00152"></a>00152     };
<a name="l00153"></a>00153 
<a name="l00154"></a><a class="code" href="structMM__FailInsertParam.html#a656ca049ee30033641102c0a98c1b385">00154</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__FailInsertParam.html#ad3d641024290ff0dfe3538054d83adee">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> size, <a class="code" href="structMM__FailInsertParam.html">MM_FailInsertParam</a>* ptr)
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156         <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00157"></a>00157         <span class="keywordflow">return</span> ptr;
<a name="l00158"></a>00158     };
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 
<a name="l00161"></a><a class="code" href="structMM__FailInsertParam.html#a1ee93733cdc58b93b9b15376a6d92024">00161</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__FailInsertParam.html#a1ee93733cdc58b93b9b15376a6d92024">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
<a name="l00162"></a>00162     {
<a name="l00163"></a>00163         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_FailInsertParam, OsclMemBasicAllocator&gt;</a> failAlloc;
<a name="l00164"></a>00164         failAlloc.<a class="code" href="classOscl__TAlloc.html#aad556619cdcb4169d32df057fa4bce93">deallocate</a>((<a class="code" href="structMM__FailInsertParam.html">MM_FailInsertParam</a>*)ptr);
<a name="l00165"></a>00165     };
<a name="l00166"></a>00166 
<a name="l00167"></a>00167     <span class="comment">/* won&#39;t build on ADS</span>
<a name="l00168"></a>00168 <span class="comment">    void operator delete(void *ptr, MM_FailInsertParam* mptr) {</span>
<a name="l00169"></a>00169 <span class="comment">        OSCL_UNUSED_ARG(ptr);</span>
<a name="l00170"></a>00170 <span class="comment">        OSCL_UNUSED_ARG(mptr);</span>
<a name="l00171"></a>00171 <span class="comment">    };*/</span>
<a name="l00172"></a>00172 };
<a name="l00173"></a>00173 
<a name="l00174"></a><a class="code" href="classOsclMemStatsNode.html">00174</a> <span class="keyword">class </span><a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>
<a name="l00175"></a>00175 {
<a name="l00176"></a>00176     <span class="keyword">public</span>:
<a name="l00177"></a>00177 
<a name="l00178"></a><a class="code" href="classOsclMemStatsNode.html#aab787f6296cc3cee285a7bc3de9e7267">00178</a>         <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a> *<a class="code" href="classOsclMemStatsNode.html#aab787f6296cc3cee285a7bc3de9e7267">pMMStats</a>;
<a name="l00179"></a><a class="code" href="classOsclMemStatsNode.html#a74a1f866d44e10a5b1de5c056350c889">00179</a>         <a class="code" href="structMM__FailInsertParam.html">MM_FailInsertParam</a> *<a class="code" href="classOsclMemStatsNode.html#a74a1f866d44e10a5b1de5c056350c889">pMMFIParam</a>;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181         <span class="comment">/* set a link to map, especially for getting the tags of children nodes */</span>
<a name="l00182"></a><a class="code" href="classOsclMemStatsNode.html#a6e44ba49809345a102da34bf3a90bcc5">00182</a>         <span class="keywordtype">char</span> *<a class="code" href="classOsclMemStatsNode.html#a6e44ba49809345a102da34bf3a90bcc5">tag</a>;
<a name="l00183"></a>00183 
<a name="l00184"></a><a class="code" href="classOsclMemStatsNode.html#a15340ac62065896f4ed25f62a819bbf2">00184</a>         <a class="code" href="classOsclMemStatsNode.html#a15340ac62065896f4ed25f62a819bbf2">OsclMemStatsNode</a>()
<a name="l00185"></a>00185         {
<a name="l00186"></a>00186             <a class="code" href="classOsclMemStatsNode.html#aab787f6296cc3cee285a7bc3de9e7267">pMMStats</a> = <a class="code" href="group__osclbase.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="The NULL_TERM_CHAR is used to terminate c-style strings.">NULL</a>;
<a name="l00187"></a>00187             <a class="code" href="classOsclMemStatsNode.html#a74a1f866d44e10a5b1de5c056350c889">pMMFIParam</a> = <a class="code" href="group__osclbase.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="The NULL_TERM_CHAR is used to terminate c-style strings.">NULL</a>;
<a name="l00188"></a>00188             <a class="code" href="classOsclMemStatsNode.html#a6e44ba49809345a102da34bf3a90bcc5">tag</a> = <a class="code" href="group__osclbase.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="The NULL_TERM_CHAR is used to terminate c-style strings.">NULL</a>;
<a name="l00189"></a>00189         }
<a name="l00190"></a>00190 
<a name="l00191"></a><a class="code" href="classOsclMemStatsNode.html#a61540cac9878522a6dca7b9c6271e95f">00191</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemStatsNode.html#a61540cac9878522a6dca7b9c6271e95f">reset</a>()
<a name="l00192"></a>00192         {
<a name="l00193"></a>00193             <span class="keywordflow">if</span> (<a class="code" href="classOsclMemStatsNode.html#aab787f6296cc3cee285a7bc3de9e7267">pMMStats</a>) <a class="code" href="classOsclMemStatsNode.html#aab787f6296cc3cee285a7bc3de9e7267">pMMStats</a>-&gt;<a class="code" href="structMM__Stats__t.html#a78ca17f36df6a0620b44c9435ad665ac">reset</a>();
<a name="l00194"></a>00194             <span class="keywordflow">if</span> (<a class="code" href="classOsclMemStatsNode.html#a74a1f866d44e10a5b1de5c056350c889">pMMFIParam</a>) <a class="code" href="classOsclMemStatsNode.html#a74a1f866d44e10a5b1de5c056350c889">pMMFIParam</a>-&gt;<a class="code" href="structMM__FailInsertParam.html#ae23e7c1bcdeb1eb080399a704f760dc6">reset</a>();
<a name="l00195"></a>00195         };
<a name="l00196"></a>00196 
<a name="l00197"></a><a class="code" href="classOsclMemStatsNode.html#a51d25e0128f9e1dd6aaa5b3cf7dab92e">00197</a>         <a class="code" href="classOsclMemStatsNode.html#a51d25e0128f9e1dd6aaa5b3cf7dab92e">~OsclMemStatsNode</a>()
<a name="l00198"></a>00198         {
<a name="l00199"></a>00199             <a class="code" href="group__osclmemory.html#ga1a1abac94dc334b1b865949f6f250b0f">OSCL_DELETE</a>(<a class="code" href="classOsclMemStatsNode.html#aab787f6296cc3cee285a7bc3de9e7267">pMMStats</a>);
<a name="l00200"></a>00200             <a class="code" href="group__osclmemory.html#ga1a1abac94dc334b1b865949f6f250b0f">OSCL_DELETE</a>(<a class="code" href="classOsclMemStatsNode.html#a74a1f866d44e10a5b1de5c056350c889">pMMFIParam</a>);
<a name="l00201"></a>00201             <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;char, OsclMemBasicAllocator&gt;</a> charAlloc;
<a name="l00202"></a>00202             charAlloc.<a class="code" href="classOscl__TAlloc.html#aad556619cdcb4169d32df057fa4bce93">deallocate</a>(<a class="code" href="classOsclMemStatsNode.html#a6e44ba49809345a102da34bf3a90bcc5">tag</a>);
<a name="l00203"></a>00203         }
<a name="l00204"></a>00204 
<a name="l00205"></a><a class="code" href="classOsclMemStatsNode.html#a18781b6a637adad4abf026a8446a8d74">00205</a>         <span class="keywordtype">void</span> *<a class="code" href="classOsclMemStatsNode.html#a18781b6a637adad4abf026a8446a8d74">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> size)
<a name="l00206"></a>00206         {
<a name="l00207"></a>00207             <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00208"></a>00208             <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;OsclMemStatsNode, OsclMemBasicAllocator&gt;</a> statsNodeAlloc;
<a name="l00209"></a>00209             <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *ptr = statsNodeAlloc.<a class="code" href="classOscl__TAlloc.html#abd4d816b6b4c0cebc5e1bb32982c0483">allocate</a>(1);
<a name="l00210"></a>00210             <span class="keywordflow">return</span> ptr;
<a name="l00211"></a>00211         };
<a name="l00212"></a>00212 
<a name="l00213"></a><a class="code" href="classOsclMemStatsNode.html#a2e9165bd9f4950cdf9410faf9f05e43d">00213</a>         <span class="keywordtype">void</span> *<a class="code" href="classOsclMemStatsNode.html#a18781b6a637adad4abf026a8446a8d74">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> size, <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* ptr)
<a name="l00214"></a>00214         {
<a name="l00215"></a>00215             <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00216"></a>00216             <span class="keywordflow">return</span> ptr;
<a name="l00217"></a>00217         };
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 
<a name="l00220"></a><a class="code" href="classOsclMemStatsNode.html#a6cb66f3e4c29b72efbaa056e150697f5">00220</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemStatsNode.html#a6cb66f3e4c29b72efbaa056e150697f5">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
<a name="l00221"></a>00221         {
<a name="l00222"></a>00222             <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;OsclMemStatsNode, OsclMemBasicAllocator&gt;</a> statsNodeAlloc;
<a name="l00223"></a>00223             statsNodeAlloc.<a class="code" href="classOscl__TAlloc.html#aad556619cdcb4169d32df057fa4bce93">deallocate</a>((<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>*)ptr);
<a name="l00224"></a>00224         };
<a name="l00225"></a>00225 
<a name="l00226"></a>00226         <span class="comment">/* won&#39;t build on ADS</span>
<a name="l00227"></a>00227 <span class="comment">        void operator delete(void *ptr, OsclMemStatsNode* mptr) {</span>
<a name="l00228"></a>00228 <span class="comment">            OSCL_UNUSED_ARG(ptr);</span>
<a name="l00229"></a>00229 <span class="comment">            OSCL_UNUSED_ARG(mptr);</span>
<a name="l00230"></a>00230 <span class="comment">        };*/</span>
<a name="l00231"></a>00231 };
<a name="l00232"></a>00232 
<a name="l00233"></a><a class="code" href="structMM__Stats__CB.html">00233</a> <span class="keyword">struct </span><a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a>
<a name="l00234"></a>00234 {
<a name="l00235"></a><a class="code" href="structMM__Stats__CB.html#aef7177a9bab17ab8efd7bf779918fabe">00235</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structMM__Stats__CB.html#aef7177a9bab17ab8efd7bf779918fabe">tag</a>;
<a name="l00236"></a><a class="code" href="structMM__Stats__CB.html#a7a7a06465c4b4c50fe6f2fe9facd1aeb">00236</a>     <span class="keyword">const</span> <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a> *<a class="code" href="structMM__Stats__CB.html#a7a7a06465c4b4c50fe6f2fe9facd1aeb">pStats</a>;
<a name="l00237"></a><a class="code" href="structMM__Stats__CB.html#a83cf63df02fc1a9895101ee930e161c1">00237</a>     uint32 <a class="code" href="structMM__Stats__CB.html#a83cf63df02fc1a9895101ee930e161c1">num_child_nodes</a>;
<a name="l00238"></a>00238 
<a name="l00239"></a><a class="code" href="structMM__Stats__CB.html#a0894a0794fbf491963e4377c0f331b7a">00239</a>     <a class="code" href="structMM__Stats__CB.html#a0894a0794fbf491963e4377c0f331b7a">MM_Stats_CB</a>()
<a name="l00240"></a>00240     {
<a name="l00241"></a>00241         <a class="code" href="group__osclmemory.html#ga93ce8ea351e601f7d68094199190178b">oscl_memset</a>(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a>));
<a name="l00242"></a>00242     }
<a name="l00243"></a>00243 
<a name="l00244"></a><a class="code" href="structMM__Stats__CB.html#abcff587e810199f65ae1461c2d9d00c0">00244</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__Stats__CB.html#abcff587e810199f65ae1461c2d9d00c0">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> size)
<a name="l00245"></a>00245     {
<a name="l00246"></a>00246         <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00247"></a>00247         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_Stats_CB, OsclMemBasicAllocator&gt;</a> statsCBAlloc;
<a name="l00248"></a>00248         <a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a> *ptr = statsCBAlloc.<a class="code" href="classOscl__TAlloc.html#abd4d816b6b4c0cebc5e1bb32982c0483">allocate</a>(1);
<a name="l00249"></a>00249         <span class="keywordflow">return</span> ptr;
<a name="l00250"></a>00250     };
<a name="l00251"></a>00251 
<a name="l00252"></a><a class="code" href="structMM__Stats__CB.html#aa6d7d2445dd4cbcdf4a4eb6992f830c6">00252</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__Stats__CB.html#abcff587e810199f65ae1461c2d9d00c0">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> size, <a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a>* ptr)
<a name="l00253"></a>00253     {
<a name="l00254"></a>00254         <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00255"></a>00255         <span class="keywordflow">return</span> ptr;
<a name="l00256"></a>00256     };
<a name="l00257"></a>00257 
<a name="l00258"></a>00258 
<a name="l00259"></a><a class="code" href="structMM__Stats__CB.html#a5f0c14cda05036b3527dedb576000cf8">00259</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__Stats__CB.html#a5f0c14cda05036b3527dedb576000cf8">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
<a name="l00260"></a>00260     {
<a name="l00261"></a>00261         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_Stats_CB, OsclMemBasicAllocator&gt;</a> statsCBAlloc;
<a name="l00262"></a>00262         statsCBAlloc.<a class="code" href="classOscl__TAlloc.html#aad556619cdcb4169d32df057fa4bce93">deallocate</a>((<a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a>*)ptr);
<a name="l00263"></a>00263     };
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     <span class="comment">/* won&#39;t build on ADS</span>
<a name="l00266"></a>00266 <span class="comment">    void operator delete(void *ptr, MM_Stats_CB* mptr) {</span>
<a name="l00267"></a>00267 <span class="comment">        OSCL_UNUSED_ARG(ptr);</span>
<a name="l00268"></a>00268 <span class="comment">        OSCL_UNUSED_ARG(mptr);</span>
<a name="l00269"></a>00269 <span class="comment">    };*/</span>
<a name="l00270"></a>00270 };
<a name="l00271"></a>00271 
<a name="l00272"></a><a class="code" href="group__osclmemory.html#ga41c317c81cc0cf56f9a6268a647b1a11">00272</a> <span class="preprocessor">#define MM_ALLOC_MAX_QUERY_FILENAME_LEN 128</span>
<a name="l00273"></a><a class="code" href="group__osclmemory.html#ga8ec1573266de990b64234c7696a69930">00273</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_ALLOC_MAX_QUERY_TAG_LEN 64</span>
<a name="l00274"></a>00274 <span class="preprocessor"></span>
<a name="l00275"></a><a class="code" href="structMM__AllocQueryInfo.html">00275</a> <span class="keyword">struct </span><a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>
<a name="l00276"></a>00276 {
<a name="l00277"></a><a class="code" href="structMM__AllocQueryInfo.html#a9e1d206c748f1d0556f2cf162f0ff40c">00277</a>     uint32 <a class="code" href="structMM__AllocQueryInfo.html#a9e1d206c748f1d0556f2cf162f0ff40c">allocNum</a>;
<a name="l00278"></a><a class="code" href="structMM__AllocQueryInfo.html#a7d1391360640ed7418d5ba9039b96049">00278</a>     <span class="keywordtype">char</span> <a class="code" href="structMM__AllocQueryInfo.html#a7d1391360640ed7418d5ba9039b96049">fileName</a>[<a class="code" href="group__osclmemory.html#ga41c317c81cc0cf56f9a6268a647b1a11">MM_ALLOC_MAX_QUERY_FILENAME_LEN</a>];
<a name="l00279"></a><a class="code" href="structMM__AllocQueryInfo.html#a2489514182d458e97a6c3f2883a43dc7">00279</a>     uint32 <a class="code" href="structMM__AllocQueryInfo.html#a2489514182d458e97a6c3f2883a43dc7">lineNo</a>;
<a name="l00280"></a><a class="code" href="structMM__AllocQueryInfo.html#a3ca9f9934cc859ff09518592a5b5087c">00280</a>     uint32 <a class="code" href="structMM__AllocQueryInfo.html#a3ca9f9934cc859ff09518592a5b5087c">size</a>;
<a name="l00281"></a><a class="code" href="structMM__AllocQueryInfo.html#a18e6536493f73c5d4df56c217b190197">00281</a>     <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocQueryInfo.html#a18e6536493f73c5d4df56c217b190197">pMemBlock</a>;
<a name="l00282"></a><a class="code" href="structMM__AllocQueryInfo.html#aa771a1dbe03ecd0e85d05b3dbd699a4e">00282</a>     <span class="keywordtype">char</span> <a class="code" href="structMM__AllocQueryInfo.html#aa771a1dbe03ecd0e85d05b3dbd699a4e">tag</a>[<a class="code" href="group__osclmemory.html#ga8ec1573266de990b64234c7696a69930">MM_ALLOC_MAX_QUERY_TAG_LEN</a>];
<a name="l00283"></a>00283 };
<a name="l00284"></a>00284 
<a name="l00285"></a>00285 
<a name="l00286"></a><a class="code" href="structMM__AllocInfo.html">00286</a> <span class="keyword">struct </span><a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a>
<a name="l00287"></a>00287 {
<a name="l00288"></a><a class="code" href="structMM__AllocInfo.html#a74f85e2736aa511c10445039b964e872">00288</a>     uint32 <a class="code" href="structMM__AllocInfo.html#a74f85e2736aa511c10445039b964e872">allocNum</a>;
<a name="l00289"></a><a class="code" href="structMM__AllocInfo.html#a8158a4b8134562a903566621cf531771">00289</a>     <span class="keywordtype">char</span> *<a class="code" href="structMM__AllocInfo.html#a8158a4b8134562a903566621cf531771">pFileName</a>;
<a name="l00290"></a><a class="code" href="structMM__AllocInfo.html#a94453f890a0727dba22d9a2a4cfa8330">00290</a>     uint32 <a class="code" href="structMM__AllocInfo.html#a94453f890a0727dba22d9a2a4cfa8330">lineNo</a>;
<a name="l00291"></a><a class="code" href="structMM__AllocInfo.html#acb71dbcec57eb1d34466395877994243">00291</a>     uint32 <a class="code" href="structMM__AllocInfo.html#acb71dbcec57eb1d34466395877994243">size</a>;
<a name="l00292"></a><a class="code" href="structMM__AllocInfo.html#ab2a37b4a715cee39bc500d4ccc7c2118">00292</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocInfo.html#ab2a37b4a715cee39bc500d4ccc7c2118">pMemBlock</a>;
<a name="l00293"></a><a class="code" href="structMM__AllocInfo.html#adf0306923ec530a04f1cfcf81d663243">00293</a>     <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *<a class="code" href="structMM__AllocInfo.html#adf0306923ec530a04f1cfcf81d663243">pStatsNode</a>;
<a name="l00294"></a><a class="code" href="structMM__AllocInfo.html#a15260d6183705abf2615266d221eb853">00294</a>     <span class="keywordtype">bool</span> <a class="code" href="structMM__AllocInfo.html#a15260d6183705abf2615266d221eb853">bSetFailure</a>;
<a name="l00295"></a>00295 
<a name="l00296"></a><a class="code" href="structMM__AllocInfo.html#a41643cf2b8a6bbde62b743dc5e31d98e">00296</a>     <a class="code" href="structMM__AllocInfo.html#a41643cf2b8a6bbde62b743dc5e31d98e">MM_AllocInfo</a>()
<a name="l00297"></a>00297     {
<a name="l00298"></a>00298         <a class="code" href="group__osclmemory.html#ga93ce8ea351e601f7d68094199190178b">oscl_memset</a>(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a>));
<a name="l00299"></a>00299     }
<a name="l00300"></a>00300 
<a name="l00301"></a><a class="code" href="structMM__AllocInfo.html#ae7dd22e414e8445ee1f326eab66710e5">00301</a>     <a class="code" href="structMM__AllocInfo.html#ae7dd22e414e8445ee1f326eab66710e5">~MM_AllocInfo</a>()
<a name="l00302"></a>00302     {
<a name="l00303"></a>00303         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;char, OsclMemBasicAllocator&gt;</a> charAlloc;
<a name="l00304"></a>00304         charAlloc.<a class="code" href="classOscl__TAlloc.html#aad556619cdcb4169d32df057fa4bce93">deallocate</a>(<a class="code" href="structMM__AllocInfo.html#a8158a4b8134562a903566621cf531771">pFileName</a>);
<a name="l00305"></a>00305     }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 
<a name="l00308"></a><a class="code" href="structMM__AllocInfo.html#ac8f80e373a8fcf2690fc454ae091989d">00308</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocInfo.html#ac8f80e373a8fcf2690fc454ae091989d">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> <a class="code" href="structMM__AllocInfo.html#acb71dbcec57eb1d34466395877994243">size</a>)
<a name="l00309"></a>00309     {
<a name="l00310"></a>00310         <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00311"></a>00311         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_AllocInfo, OsclMemBasicAllocator&gt;</a> allocInfoAlloc;
<a name="l00312"></a>00312         <a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a> *ptr = allocInfoAlloc.<a class="code" href="classOscl__TAlloc.html#abd4d816b6b4c0cebc5e1bb32982c0483">allocate</a>(1);
<a name="l00313"></a>00313         <span class="keywordflow">return</span> ptr;
<a name="l00314"></a>00314     };
<a name="l00315"></a>00315 
<a name="l00316"></a><a class="code" href="structMM__AllocInfo.html#a2b68274506d525a72df9f87cf5e6346d">00316</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocInfo.html#ac8f80e373a8fcf2690fc454ae091989d">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> <a class="code" href="structMM__AllocInfo.html#acb71dbcec57eb1d34466395877994243">size</a>, <a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a>* ptr)
<a name="l00317"></a>00317     {
<a name="l00318"></a>00318         <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00319"></a>00319         <span class="keywordflow">return</span> ptr;
<a name="l00320"></a>00320     };
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 
<a name="l00323"></a><a class="code" href="structMM__AllocInfo.html#a230dd7d69c0cd455215152b301d796ab">00323</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__AllocInfo.html#a230dd7d69c0cd455215152b301d796ab">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
<a name="l00324"></a>00324     {
<a name="l00325"></a>00325         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_AllocInfo, OsclMemBasicAllocator&gt;</a> allocInfoAlloc;
<a name="l00326"></a>00326         allocInfoAlloc.<a class="code" href="classOscl__TAlloc.html#aad556619cdcb4169d32df057fa4bce93">deallocate</a>((<a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a>*)ptr);
<a name="l00327"></a>00327     };
<a name="l00328"></a>00328 
<a name="l00329"></a>00329     <span class="comment">/* won&#39;t build on ADS</span>
<a name="l00330"></a>00330 <span class="comment">    void operator delete(void *ptr, MM_AllocInfo* mptr) {</span>
<a name="l00331"></a>00331 <span class="comment">        OSCL_UNUSED_ARG(ptr);</span>
<a name="l00332"></a>00332 <span class="comment">        OSCL_UNUSED_ARG(mptr);</span>
<a name="l00333"></a>00333 <span class="comment">    };*/</span>
<a name="l00334"></a>00334 };
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 
<a name="l00337"></a><a class="code" href="structMM__AllocNode.html">00337</a> <span class="keyword">struct </span><a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>
<a name="l00338"></a>00338 {
<a name="l00339"></a><a class="code" href="structMM__AllocNode.html#ad73e18a985c38ae15d0322f9c5bde530">00339</a>     <a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a> *<a class="code" href="structMM__AllocNode.html#ad73e18a985c38ae15d0322f9c5bde530">pAllocInfo</a>;
<a name="l00340"></a>00340 
<a name="l00341"></a><a class="code" href="structMM__AllocNode.html#a5d19a19b2094c6fbc17547d69c6e80ca">00341</a>     <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a> *<a class="code" href="structMM__AllocNode.html#a5d19a19b2094c6fbc17547d69c6e80ca">pPrev</a>;
<a name="l00342"></a><a class="code" href="structMM__AllocNode.html#a1e222e64229427c89357701f5557df67">00342</a>     <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a> *<a class="code" href="structMM__AllocNode.html#a1e222e64229427c89357701f5557df67">pNext</a>;
<a name="l00343"></a><a class="code" href="structMM__AllocNode.html#a763220a74ed86cbc1c72e079ea8ba796">00343</a>     <a class="code" href="structMM__AllocNode.html#a763220a74ed86cbc1c72e079ea8ba796">MM_AllocNode</a>()
<a name="l00344"></a>00344     {
<a name="l00345"></a>00345         <a class="code" href="group__osclmemory.html#ga93ce8ea351e601f7d68094199190178b">oscl_memset</a>(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>));
<a name="l00346"></a>00346     }
<a name="l00347"></a>00347 
<a name="l00348"></a><a class="code" href="structMM__AllocNode.html#a2b357fb8e4c360d507bc5141dbca9e75">00348</a>     <a class="code" href="structMM__AllocNode.html#a2b357fb8e4c360d507bc5141dbca9e75">~MM_AllocNode</a>()
<a name="l00349"></a>00349     {
<a name="l00350"></a>00350         <a class="code" href="group__osclmemory.html#ga1a1abac94dc334b1b865949f6f250b0f">OSCL_DELETE</a>(<a class="code" href="structMM__AllocNode.html#ad73e18a985c38ae15d0322f9c5bde530">pAllocInfo</a>);
<a name="l00351"></a>00351     }
<a name="l00352"></a>00352 
<a name="l00353"></a><a class="code" href="structMM__AllocNode.html#a1c8dbda56ecd940bff7a59633724dfd5">00353</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocNode.html#a1c8dbda56ecd940bff7a59633724dfd5">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> size)
<a name="l00354"></a>00354     {
<a name="l00355"></a>00355         <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00356"></a>00356         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_AllocNode, OsclMemBasicAllocator&gt;</a> allocNodeAlloc;
<a name="l00357"></a>00357         <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a> *ptr = allocNodeAlloc.<a class="code" href="classOscl__TAlloc.html#abd4d816b6b4c0cebc5e1bb32982c0483">allocate</a>(1);
<a name="l00358"></a>00358         <span class="keywordflow">return</span> ptr;
<a name="l00359"></a>00359     };
<a name="l00360"></a>00360 
<a name="l00361"></a><a class="code" href="structMM__AllocNode.html#a21310729ee8c1c69a6845a4ae3d23f40">00361</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocNode.html#a1c8dbda56ecd940bff7a59633724dfd5">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#ab1a32e730ee1d662df94509a2661379f">oscl_memsize_t</a> size, <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>* ptr)
<a name="l00362"></a>00362     {
<a name="l00363"></a>00363         <a class="code" href="group__osclbase.html#ga0ac3a7c93a978fa6d04c2a5d810612dd">OSCL_UNUSED_ARG</a>(size);
<a name="l00364"></a>00364         <span class="keywordflow">return</span> ptr;
<a name="l00365"></a>00365     };
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 
<a name="l00368"></a><a class="code" href="structMM__AllocNode.html#a8a0bf45e3936fb5e620e02c9a54f85ce">00368</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__AllocNode.html#a8a0bf45e3936fb5e620e02c9a54f85ce">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
<a name="l00369"></a>00369     {
<a name="l00370"></a>00370         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_AllocNode, OsclMemBasicAllocator&gt;</a> allocNodeAlloc;
<a name="l00371"></a>00371         allocNodeAlloc.<a class="code" href="classOscl__TAlloc.html#aad556619cdcb4169d32df057fa4bce93">deallocate</a>((<a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>*)ptr);
<a name="l00372"></a>00372     };
<a name="l00373"></a>00373 
<a name="l00374"></a>00374     <span class="comment">/* won&#39;t build on ADS</span>
<a name="l00375"></a>00375 <span class="comment">    void operator delete(void *ptr, MM_AllocNode* mptr) {</span>
<a name="l00376"></a>00376 <span class="comment">        OSCL_UNUSED_ARG(ptr);</span>
<a name="l00377"></a>00377 <span class="comment">        OSCL_UNUSED_ARG(mptr);</span>
<a name="l00378"></a>00378 <span class="comment">    };*/</span>
<a name="l00379"></a>00379 };
<a name="l00380"></a>00380 
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 <span class="comment">/* Define internal auto ptr classes that don&#39;t go through mem mgmt */</span>
<a name="l00383"></a><a class="code" href="group__osclmemory.html#gaf66c1777f28e18dd3c7f935481cbf453">00383</a> <span class="keyword">typedef</span> <a class="code" href="classOSCLMemAutoPtr.html" title="The oscl_auto_ptr class is a template class that defines a pointer like object intended...">OSCLMemAutoPtr&lt;char, Oscl_TAlloc&lt;char, OsclMemBasicAllocator&gt;</a> &gt; <a class="code" href="classOSCLMemAutoPtr.html" title="The oscl_auto_ptr class is a template class that defines a pointer like object intended...">MMAuditCharAutoPtr</a>;
<a name="l00384"></a><a class="code" href="group__osclmemory.html#gaef861d5c7d2bc396e389426e7d5475ff">00384</a> <span class="keyword">typedef</span> <a class="code" href="classOSCLMemAutoPtr.html" title="The oscl_auto_ptr class is a template class that defines a pointer like object intended...">OSCLMemAutoPtr&lt;uint8, Oscl_TAlloc&lt;uint8, _OsclBasicAllocator&gt;</a> &gt; <a class="code" href="classOSCLMemAutoPtr.html" title="The oscl_auto_ptr class is a template class that defines a pointer like object intended...">MMAuditUint8AutoPtr</a>;
<a name="l00385"></a><a class="code" href="group__osclmemory.html#ga8072c1242865d5bc7f5c10c85bf84198">00385</a> <span class="keyword">typedef</span> <a class="code" href="classOSCLMemAutoPtr.html" title="The oscl_auto_ptr class is a template class that defines a pointer like object intended...">OSCLMemAutoPtr&lt;MM_AllocNode, Oscl_TAlloc&lt;MM_AllocNode, OsclMemBasicAllocator&gt;</a> &gt; <a class="code" href="classOSCLMemAutoPtr.html" title="The oscl_auto_ptr class is a template class that defines a pointer like object intended...">MM_AllocNodeAutoPtr</a>;
<a name="l00386"></a>00386 
<a name="l00387"></a><a class="code" href="group__osclmemory.html#gaffc3054a3e8a75823bca68ad5d2694e3">00387</a> <span class="keyword">typedef</span> <a class="code" href="classOSCLMemAutoPtr.html" title="The oscl_auto_ptr class is a template class that defines a pointer like object intended...">OSCLMemAutoPtr&lt;OsclMemStatsNode, Oscl_TAlloc&lt;OsclMemStatsNode, OsclMemBasicAllocator&gt;</a> &gt; <a class="code" href="classOSCLMemAutoPtr.html" title="The oscl_auto_ptr class is a template class that defines a pointer like object intended...">MM_StatsNodeTagTreeType</a>;
<a name="l00388"></a><a class="code" href="group__osclmemory.html#gab71b84d6f0d3d4710086b903d7c3fbe9">00388</a> <span class="keyword">typedef</span> <a class="code" href="classOSCLMemAutoPtr.html" title="The oscl_auto_ptr class is a template class that defines a pointer like object intended...">OSCLMemAutoPtr&lt;OsclMemStatsNode, Oscl_TAlloc&lt;OsclMemStatsNode, OsclMemBasicAllocator&gt;</a> &gt; <a class="code" href="classOSCLMemAutoPtr.html" title="The oscl_auto_ptr class is a template class that defines a pointer like object intended...">OsclMemStatsNodeAutoPtr</a>;
<a name="l00389"></a><a class="code" href="group__osclmemory.html#ga42232be54b13e608ad6b0cf7bfa43050">00389</a> <span class="keyword">typedef</span> <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_StatsNodeTagTreeType, OsclMemBasicAllocator&gt;</a> <a class="code" href="classOscl__TAlloc.html">TagTree_Allocator</a>;
<a name="l00390"></a><a class="code" href="group__osclmemory.html#ga85218bbcb0f0b13d29e84fce5cf779a9">00390</a> <span class="keyword">typedef</span> <a class="code" href="classOscl__TagTree.html">Oscl_TagTree&lt;MM_StatsNodeTagTreeType, TagTree_Allocator&gt;</a> <a class="code" href="classOscl__TagTree.html">OsclTagTreeType</a>;
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 
<a name="l00393"></a><a class="code" href="group__osclmemory.html#ga54a16ec57774bf2c149180fb5a3cec18">00393</a> <span class="preprocessor">#define MM_AUDIT_VALIDATE_BLOCK 1</span>
<a name="l00394"></a><a class="code" href="group__osclmemory.html#ga441caaaf6c5ac0d6027c4a9a1b2f310f">00394</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_PREFILL_FLAG 0x1</span>
<a name="l00395"></a><a class="code" href="group__osclmemory.html#ga420334bb2ce96ace4235292f6cd0c2f7">00395</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_POSTFILL_FLAG 0x2</span>
<a name="l00396"></a><a class="code" href="group__osclmemory.html#ga6d3fedc4b1ba7555e3fc1cf639fa77e1">00396</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_VALIDATE_ALL_HEAP_FLAG 0x4</span>
<a name="l00397"></a><a class="code" href="group__osclmemory.html#gac96cf1894ab7f8f462f1810c37b6968f">00397</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_VALIDATE_ON_FREE_FLAG 0x8</span>
<a name="l00398"></a><a class="code" href="group__osclmemory.html#ga039081ebef2726cb323a253758383d76">00398</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_ALLOC_NODE_ENABLE_FLAG 0x10</span>
<a name="l00399"></a><a class="code" href="group__osclmemory.html#ga5fc5d0440912bd427b639f6826e82251">00399</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_SUPPRESS_FILENAME_FLAG 0x20</span>
<a name="l00400"></a>00400 <span class="preprocessor"></span>
<a name="l00401"></a>00401 <span class="preprocessor">#if(PVMEM_INST_LEVEL&gt;0)</span>
<a name="l00402"></a>00402 <span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_MM_AUDIT_MODE (MM_AUDIT_PREFILL_FLAG | \</span>
<a name="l00403"></a>00403 <span class="preprocessor">                               MM_AUDIT_POSTFILL_FLAG | \</span>
<a name="l00404"></a>00404 <span class="preprocessor">                               MM_AUDIT_VALIDATE_ON_FREE_FLAG | \</span>
<a name="l00405"></a>00405 <span class="preprocessor">                               MM_AUDIT_ALLOC_NODE_ENABLE_FLAG )</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span>
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="preprocessor">#else</span>
<a name="l00410"></a><a class="code" href="group__osclmemory.html#ga2030b79099921eaccb563d748ae8fc94">00410</a> <span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_MM_AUDIT_MODE 0</span>
<a name="l00411"></a>00411 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00412"></a>00412 <span class="preprocessor"></span>
<a name="l00413"></a>00413 
<a name="l00414"></a><a class="code" href="structMM__AuditOverheadStats.html">00414</a> <span class="keyword">struct </span><a class="code" href="structMM__AuditOverheadStats.html">MM_AuditOverheadStats</a>
<a name="l00415"></a>00415 {
<a name="l00416"></a><a class="code" href="structMM__AuditOverheadStats.html#adce0206d38ee8f9b8fbdf9d977a7c0c0">00416</a>     uint32 <a class="code" href="structMM__AuditOverheadStats.html#adce0206d38ee8f9b8fbdf9d977a7c0c0">per_allocation_overhead</a>;
<a name="l00417"></a><a class="code" href="structMM__AuditOverheadStats.html#a81e2d51beb542603021926862fa94c6b">00417</a>     uint32 <a class="code" href="structMM__AuditOverheadStats.html#a81e2d51beb542603021926862fa94c6b">stats_overhead</a>;
<a name="l00418"></a>00418 };
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="preprocessor">#if OSCL_BYPASS_MEMMGT</span>
<a name="l00421"></a>00421 <span class="preprocessor"></span><span class="comment">//an empty class for compilation only</span>
<a name="l00422"></a><a class="code" href="classMM__Audit__Imp.html">00422</a> <span class="keyword">class </span><a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a>
<a name="l00423"></a>00423 {
<a name="l00424"></a>00424     <span class="keyword">public</span>:
<a name="l00425"></a>00425 };
<a name="l00426"></a>00426 <span class="preprocessor">#else</span>
<a name="l00427"></a>00427 <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a>
<a name="l00428"></a>00428 {
<a name="l00429"></a>00429     <span class="keyword">public</span>:
<a name="l00430"></a>00430 
<a name="l00434"></a>00434         <a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a>();
<a name="l00435"></a>00435 
<a name="l00439"></a>00439         ~<a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a>();
<a name="l00440"></a>00440 
<a name="l00447"></a>00447         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">void</span> *MM_allocate(<span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>*  statsNode,
<a name="l00448"></a>00448                                           uint32 sizeIn,
<a name="l00449"></a>00449                                           <span class="keyword">const</span> <span class="keywordtype">char</span> *pFileName,
<a name="l00450"></a>00450                                           uint32 lineNumber,
<a name="l00451"></a>00451                                           <span class="keywordtype">bool</span> allocNodeTracking = <span class="keyword">false</span>);
<a name="l00452"></a>00452 
<a name="l00456"></a>00456         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">bool</span> MM_deallocate(<span class="keywordtype">void</span> *pMemBlockIn);
<a name="l00457"></a>00457 
<a name="l00462"></a>00462         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a> * MM_GetStats(<span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span>  tagIn);
<a name="l00463"></a>00463 
<a name="l00468"></a>00468         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> uint32 MM_GetStatsInDepth(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn, <a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a> *array_ptr, uint32 max_nodes);
<a name="l00469"></a>00469 
<a name="l00475"></a>00475         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> uint32 MM_GetTreeNodes(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn);
<a name="l00476"></a>00476 
<a name="l00482"></a>00482         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">bool</span> MM_AddTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
<a name="l00483"></a>00483         {
<a name="l00484"></a>00484             <span class="keywordflow">return</span> (MM_GetTagNode(tagIn) != <a class="code" href="group__osclbase.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="The NULL_TERM_CHAR is used to terminate c-style strings.">NULL</a>);
<a name="l00485"></a>00485         };
<a name="l00486"></a>00486 
<a name="l00493"></a>00493         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* MM_GetTagNode(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 
<a name="l00502"></a>00502         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* MM_GetExistingTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 
<a name="l00505"></a>00505         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* MM_GetRootNode()
<a name="l00506"></a>00506         {
<a name="l00507"></a>00507             <span class="keywordflow">return</span> mpStatsNode;
<a name="l00508"></a>00508         };
<a name="l00509"></a>00509 
<a name="l00514"></a>00514         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* MM_CreateAllocNodeInfo(uint32 max_array_size);
<a name="l00515"></a>00515         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">void</span> MM_ReleaseAllocNodeInfo(<a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* info);
<a name="l00516"></a>00516 
<a name="l00526"></a>00526         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> uint32 MM_GetAllocNodeInfo(<a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* output_array,
<a name="l00527"></a>00527                 uint32 max_array_size, uint32 offset);
<a name="l00528"></a>00528 
<a name="l00534"></a>00534         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">bool</span> MM_Validate(<span class="keyword">const</span> <span class="keywordtype">void</span> *ptrIn);
<a name="l00535"></a>00535 
<a name="l00540"></a>00540         uint32 MM_GetAllocNo(<span class="keywordtype">void</span>)
<a name="l00541"></a>00541         {
<a name="l00542"></a>00542             <span class="keywordflow">return</span> mnAllocNum;
<a name="l00543"></a>00543         }
<a name="l00544"></a>00544 
<a name="l00549"></a>00549         <span class="keywordtype">void</span> MM_GetOverheadStats(<a class="code" href="structMM__AuditOverheadStats.html">MM_AuditOverheadStats</a>&amp; stats)
<a name="l00550"></a>00550         {
<a name="l00551"></a>00551             stats.<a class="code" href="structMM__AuditOverheadStats.html#adce0206d38ee8f9b8fbdf9d977a7c0c0">per_allocation_overhead</a> = mm_audit_per_block_overhead;
<a name="l00552"></a>00552             stats.<a class="code" href="structMM__AuditOverheadStats.html#a81e2d51beb542603021926862fa94c6b">stats_overhead</a> = mm_audit_stats_overhead;
<a name="l00553"></a>00553         }
<a name="l00554"></a>00554 
<a name="l00559"></a>00559         uint32 MM_GetNumAllocNodes()
<a name="l00560"></a>00560         {
<a name="l00561"></a>00561             <span class="keywordflow">return</span> mNumAllocNodes;
<a name="l00562"></a>00562         };
<a name="l00563"></a>00563 
<a name="l00567"></a>00567         uint32 MM_GetMode(<span class="keywordtype">void</span>)
<a name="l00568"></a>00568         {
<a name="l00569"></a>00569             <span class="keywordflow">return</span> mode;
<a name="l00570"></a>00570         }
<a name="l00571"></a>00571 
<a name="l00576"></a>00576         uint8 MM_GetPrefillPattern(<span class="keywordtype">void</span>)
<a name="l00577"></a>00577         {
<a name="l00578"></a>00578             <span class="keywordflow">return</span> prefill_pattern;
<a name="l00579"></a>00579         }
<a name="l00580"></a>00580 
<a name="l00585"></a>00585         uint32 MM_GetPostfillPattern(<span class="keywordtype">void</span>)
<a name="l00586"></a>00586         {
<a name="l00587"></a>00587             <span class="keywordflow">return</span> postfill_pattern;
<a name="l00588"></a>00588         }
<a name="l00589"></a>00589 
<a name="l00593"></a>00593         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">void</span> MM_SetMode(uint32 inMode);
<a name="l00594"></a>00594 
<a name="l00598"></a>00598         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">void</span> MM_SetPrefillPattern(uint8 pattern);
<a name="l00599"></a>00599 
<a name="l00603"></a>00603         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">void</span> MM_SetPostfillPattern(uint8 pattern);
<a name="l00604"></a>00604 
<a name="l00609"></a>00609         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">void</span> MM_SetTagLevel(uint32 level);
<a name="l00610"></a>00610 
<a name="l00617"></a>00617         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">bool</span> MM_SetFailurePoint(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn, uint32 alloc_number);
<a name="l00618"></a>00618 
<a name="l00623"></a>00623         <a class="code" href="osclconfig_8h.html#a6de0f53c5c11f8f53ce72c70d74d9abc">OSCL_IMPORT_REF</a> <span class="keywordtype">void</span> MM_UnsetFailurePoint(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="comment">/*</span>
<a name="l00627"></a>00627 <span class="comment">        * The following are private member functions</span>
<a name="l00628"></a>00628 <span class="comment">        */</span>
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 
<a name="l00634"></a>00634         <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>* addAllocNode(<span class="keywordtype">void</span> *pMem, uint32 sizeIn, <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* pStatsNode, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFileName, uint32 lineNumber);
<a name="l00638"></a>00638         <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* removeAllocNode(<span class="keywordtype">void</span> *pMemBlockIn, uint32&amp; size);
<a name="l00639"></a>00639         <span class="keywordtype">void</span> removeALLAllocNodes();
<a name="l00640"></a>00640 
<a name="l00644"></a>00644         <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* createStatsNode(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn);
<a name="l00648"></a>00648         <span class="keywordtype">bool</span> updateStatsNode(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *pCurrStatsNode,
<a name="l00649"></a>00649                              <span class="keyword">const</span> <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>&amp; pDelta, <span class="keywordtype">bool</span> bAdd);
<a name="l00653"></a>00653         <span class="keywordtype">bool</span> updateStatsNodeInFailure(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
<a name="l00654"></a>00654         <span class="keywordtype">bool</span> updateStatsNodeInFailure(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> * pStatsNode);
<a name="l00658"></a>00658         <span class="keywordtype">bool</span> pruneSubtree(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *pNode);
<a name="l00659"></a>00659         <span class="keywordtype">bool</span> pruneSubtree(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
<a name="l00660"></a>00660 
<a name="l00661"></a>00661         <span class="keywordtype">void</span> retrieveParentTag(<span class="keywordtype">char</span> *tag);
<a name="l00665"></a>00665         int32 retrieveParentTagLength(<span class="keyword">const</span> <span class="keywordtype">char</span> *tag, int32 bound);
<a name="l00669"></a>00669         <span class="keywordtype">void</span> makeValidTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn, MMAuditCharAutoPtr&amp; autoptr);
<a name="l00673"></a>00673         uint32 getTagActualSize(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
<a name="l00680"></a>00680         <span class="keywordtype">bool</span> isSetFailure(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682         <span class="keywordtype">bool</span> isSetFailure(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> * statsNode);
<a name="l00686"></a>00686         <span class="keyword">static</span> <span class="keywordtype">bool</span> validate(<span class="keywordtype">void</span> *ptrIn);
<a name="l00687"></a>00687 
<a name="l00691"></a>00691         <span class="keyword">static</span> <a class="code" href="classOsclMemAudit.html">OsclMemAudit</a>* getAuditRoot(<span class="keywordtype">void</span> *ptrIn);
<a name="l00692"></a>00692 
<a name="l00696"></a>00696         <span class="keyword">static</span> uint32 getSize(<span class="keywordtype">void</span> *ptrIn);
<a name="l00697"></a>00697 
<a name="l00701"></a>00701         <span class="keywordtype">bool</span> validate_all_heap();
<a name="l00702"></a>00702 
<a name="l00703"></a>00703     <span class="keyword">private</span>:
<a name="l00704"></a>00704 
<a name="l00705"></a>00705         <span class="keywordtype">void</span> populateChildren(<span class="keyword">const</span> <span class="keywordtype">char</span> *tagIn,
<a name="l00706"></a>00706                               <a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a> *array_ptr,
<a name="l00707"></a>00707                               uint32 &amp;curr_array_index,
<a name="l00708"></a>00708                               uint32 max_nodes);
<a name="l00709"></a>00709 
<a name="l00710"></a>00710         <span class="comment">/*</span>
<a name="l00711"></a>00711 <span class="comment">        * The following are private data members</span>
<a name="l00712"></a>00712 <span class="comment">        */</span>
<a name="l00713"></a>00713 
<a name="l00718"></a>00718         <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a> *mpAllocNode, *mpCurrAllocNode;
<a name="l00719"></a>00719 
<a name="l00724"></a>00724         uint32 mNumAllocNodes;
<a name="l00725"></a>00725 
<a name="l00729"></a>00729         <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *mpStatsNode;
<a name="l00734"></a>00734         OsclTagTreeType          mTagTree;
<a name="l00738"></a>00738         uint32 mnAllocNum;
<a name="l00739"></a>00739         uint32 mnMaxTagLevel;
<a name="l00740"></a>00740         uint32 mode;
<a name="l00741"></a>00741 
<a name="l00742"></a>00742         uint32 mm_audit_per_block_overhead;
<a name="l00743"></a>00743         uint32 mm_audit_stats_overhead;
<a name="l00744"></a>00744 
<a name="l00745"></a>00745         uint8 prefill_pattern;
<a name="l00746"></a>00746         uint8 postfill_pattern;
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 };
<a name="l00749"></a>00749 <span class="preprocessor">#endif</span>
<a name="l00750"></a>00750 <span class="preprocessor"></span>
<a name="l00751"></a>00751 <span class="preprocessor">#if OSCL_BYPASS_MEMMGT</span>
<a name="l00752"></a>00752 <span class="preprocessor"></span><span class="comment">//an empty class for compilation only.</span>
<a name="l00753"></a><a class="code" href="classOsclMemAudit.html">00753</a> <span class="keyword">class </span><a class="code" href="classOsclMemAudit.html">OsclMemAudit</a>
<a name="l00754"></a>00754 {
<a name="l00755"></a>00755     <span class="keyword">public</span>:
<a name="l00756"></a>00756 };
<a name="l00757"></a>00757 <span class="preprocessor">#else</span>
<a name="l00758"></a>00758 <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classOsclMemAudit.html">OsclMemAudit</a>
<a name="l00759"></a>00759 {
<a name="l00760"></a>00760     <span class="keyword">public</span>:
<a name="l00764"></a>00764         <a class="code" href="classOsclMemAudit.html">OsclMemAudit</a>()
<a name="l00765"></a>00765         {
<a name="l00766"></a>00766             <span class="keywordtype">void</span> * p = <a class="code" href="group__osclmemory.html#gac26198ea976235d69f4140bcc63246a0">_oscl_malloc</a>(<span class="keyword">sizeof</span>(<a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a>));
<a name="l00767"></a>00767             <a class="code" href="classOsclError.html#aca9829cfcc11ff580338353602c38e0d">OsclError::LeaveIfNull</a>(p);
<a name="l00768"></a>00768 
<a name="l00769"></a>00769             <span class="comment">// this will invoke system placement new operator</span>
<a name="l00770"></a>00770             _pMM_Audit_Imp = <a class="code" href="group__osclmemory.html#ga4bf8a56280e6377de56a030a453bb447">OSCL_PLACEMENT_NEW</a>(p, <a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a>());
<a name="l00771"></a>00771             iLock = &amp;iSingletonLock;
<a name="l00772"></a>00772             iRefCount = 1;
<a name="l00773"></a>00773         };
<a name="l00774"></a>00774 
<a name="l00778"></a>00778         ~<a class="code" href="classOsclMemAudit.html">OsclMemAudit</a>()
<a name="l00779"></a>00779         {
<a name="l00780"></a>00780             _pMM_Audit_Imp-&gt;~MM_Audit_Imp();
<a name="l00781"></a>00781             <a class="code" href="group__osclmemory.html#ga952e5011acf2fddbf25c0791f54963cb">_oscl_free</a>((<span class="keywordtype">void</span> *) _pMM_Audit_Imp);
<a name="l00782"></a>00782         };
<a name="l00783"></a>00783 
<a name="l00790"></a>00790         <span class="keywordtype">void</span> *MM_allocate(<span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>*  statsNode,
<a name="l00791"></a>00791                           uint32 sizeIn,
<a name="l00792"></a>00792                           <span class="keyword">const</span> <span class="keywordtype">char</span> *pFileName,
<a name="l00793"></a>00793                           uint32 lineNumber,
<a name="l00794"></a>00794                           <span class="keywordtype">bool</span> allocNodeTracking = <span class="keyword">false</span>)
<a name="l00795"></a>00795         {
<a name="l00796"></a>00796             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l00797"></a>00797             iLock-&gt;Lock();
<a name="l00798"></a>00798 
<a name="l00799"></a>00799             <span class="keywordtype">void</span>* result = _pMM_Audit_Imp-&gt;MM_allocate(statsNode, sizeIn, pFileName, lineNumber, allocNodeTracking);
<a name="l00800"></a>00800 
<a name="l00801"></a>00801             iLock-&gt;Unlock();
<a name="l00802"></a>00802             <span class="keywordflow">return</span> result;
<a name="l00803"></a>00803         };
<a name="l00804"></a>00804 
<a name="l00808"></a>00808         <span class="keywordtype">bool</span> MM_deallocate(<span class="keywordtype">void</span> *pMemBlockIn)
<a name="l00809"></a>00809         {
<a name="l00810"></a>00810             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l00811"></a>00811             iLock-&gt;Lock();
<a name="l00812"></a>00812 
<a name="l00813"></a>00813             <span class="keywordtype">bool</span> result = _pMM_Audit_Imp-&gt;MM_deallocate(pMemBlockIn);
<a name="l00814"></a>00814 
<a name="l00815"></a>00815             iLock-&gt;Unlock();
<a name="l00816"></a>00816             <span class="keywordflow">return</span> result;
<a name="l00817"></a>00817         };
<a name="l00818"></a>00818 
<a name="l00823"></a>00823         <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a> * MM_GetStats(<span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span>  tagIn)
<a name="l00824"></a>00824         {
<a name="l00825"></a>00825             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l00826"></a>00826             iLock-&gt;Lock();
<a name="l00827"></a>00827 
<a name="l00828"></a>00828             <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>* result = (_pMM_Audit_Imp-&gt;MM_GetStats(tagIn));
<a name="l00829"></a>00829 
<a name="l00830"></a>00830             iLock-&gt;Unlock();
<a name="l00831"></a>00831             <span class="keywordflow">return</span> result;
<a name="l00832"></a>00832         };
<a name="l00833"></a>00833 
<a name="l00838"></a>00838         uint32 MM_GetStatsInDepth(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn, <a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a> *array_ptr, uint32 max_nodes)
<a name="l00839"></a>00839         {
<a name="l00840"></a>00840             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l00841"></a>00841             iLock-&gt;Lock();
<a name="l00842"></a>00842 
<a name="l00843"></a>00843             uint32 result = (_pMM_Audit_Imp-&gt;MM_GetStatsInDepth(tagIn, array_ptr, max_nodes));
<a name="l00844"></a>00844 
<a name="l00845"></a>00845             iLock-&gt;Unlock();
<a name="l00846"></a>00846             <span class="keywordflow">return</span> result;
<a name="l00847"></a>00847         };
<a name="l00848"></a>00848 
<a name="l00854"></a>00854         uint32 MM_GetTreeNodes(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn)
<a name="l00855"></a>00855         {
<a name="l00856"></a>00856             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l00857"></a>00857             iLock-&gt;Lock();
<a name="l00858"></a>00858 
<a name="l00859"></a>00859             uint32 result = (_pMM_Audit_Imp-&gt;MM_GetTreeNodes(tagIn));
<a name="l00860"></a>00860 
<a name="l00861"></a>00861             iLock-&gt;Unlock();
<a name="l00862"></a>00862             <span class="keywordflow">return</span> result;
<a name="l00863"></a>00863         };
<a name="l00864"></a>00864 
<a name="l00870"></a>00870         <span class="keywordtype">bool</span> MM_AddTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
<a name="l00871"></a>00871         {
<a name="l00872"></a>00872             <span class="keywordflow">return</span> (MM_GetTagNode(tagIn) != <a class="code" href="group__osclbase.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="The NULL_TERM_CHAR is used to terminate c-style strings.">NULL</a>);
<a name="l00873"></a>00873         };
<a name="l00874"></a>00874 
<a name="l00881"></a>00881         <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* MM_GetTagNode(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
<a name="l00882"></a>00882         {
<a name="l00883"></a>00883             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l00884"></a>00884             iLock-&gt;Lock();
<a name="l00885"></a>00885 
<a name="l00886"></a>00886             <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* result = (_pMM_Audit_Imp-&gt;MM_GetTagNode(tagIn));
<a name="l00887"></a>00887 
<a name="l00888"></a>00888             iLock-&gt;Unlock();
<a name="l00889"></a>00889             <span class="keywordflow">return</span> result;
<a name="l00890"></a>00890         };
<a name="l00891"></a>00891 
<a name="l00892"></a>00892 
<a name="l00899"></a>00899         <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* MM_GetExistingTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
<a name="l00900"></a>00900         {
<a name="l00901"></a>00901             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l00902"></a>00902             iLock-&gt;Lock();
<a name="l00903"></a>00903 
<a name="l00904"></a>00904             <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* result = (_pMM_Audit_Imp-&gt;MM_GetExistingTag(tagIn));
<a name="l00905"></a>00905 
<a name="l00906"></a>00906             iLock-&gt;Unlock();
<a name="l00907"></a>00907             <span class="keywordflow">return</span> result;
<a name="l00908"></a>00908         };
<a name="l00909"></a>00909 
<a name="l00910"></a>00910 
<a name="l00911"></a>00911         <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* MM_GetRootNode()
<a name="l00912"></a>00912         {
<a name="l00913"></a>00913             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;MM_GetRootNode());
<a name="l00914"></a>00914         };
<a name="l00915"></a>00915 
<a name="l00925"></a>00925         uint32 MM_GetAllocNodeInfo(<a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* output_array,
<a name="l00926"></a>00926                                    uint32 max_array_size, uint32 offset)
<a name="l00927"></a>00927         {
<a name="l00928"></a>00928             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l00929"></a>00929             iLock-&gt;Lock();
<a name="l00930"></a>00930 
<a name="l00931"></a>00931             uint32 result = (_pMM_Audit_Imp-&gt;MM_GetAllocNodeInfo(output_array, max_array_size, offset));
<a name="l00932"></a>00932 
<a name="l00933"></a>00933             iLock-&gt;Unlock();
<a name="l00934"></a>00934             <span class="keywordflow">return</span> result;
<a name="l00935"></a>00935         };
<a name="l00936"></a>00936 
<a name="l00937"></a>00937         <a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* MM_CreateAllocNodeInfo(uint32 max_array_size)
<a name="l00938"></a>00938         {
<a name="l00939"></a>00939             <span class="keywordflow">return</span> _pMM_Audit_Imp-&gt;MM_CreateAllocNodeInfo(max_array_size);
<a name="l00940"></a>00940         }
<a name="l00941"></a>00941         <span class="keywordtype">void</span> MM_ReleaseAllocNodeInfo(<a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* info)
<a name="l00942"></a>00942         {
<a name="l00943"></a>00943             _pMM_Audit_Imp-&gt;MM_ReleaseAllocNodeInfo(info);
<a name="l00944"></a>00944         }
<a name="l00945"></a>00945 
<a name="l00951"></a>00951         <span class="keywordtype">bool</span> MM_Validate(<span class="keyword">const</span> <span class="keywordtype">void</span> *ptrIn)
<a name="l00952"></a>00952         {
<a name="l00953"></a>00953             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l00954"></a>00954             iLock-&gt;Lock();
<a name="l00955"></a>00955 
<a name="l00956"></a>00956             <span class="keywordtype">bool</span> result = (_pMM_Audit_Imp-&gt;MM_Validate(ptrIn));
<a name="l00957"></a>00957 
<a name="l00958"></a>00958             iLock-&gt;Unlock();
<a name="l00959"></a>00959             <span class="keywordflow">return</span> result;
<a name="l00960"></a>00960         };
<a name="l00961"></a>00961 
<a name="l00966"></a>00966         uint32 MM_GetAllocNo(<span class="keywordtype">void</span>)
<a name="l00967"></a>00967         {
<a name="l00968"></a>00968             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;MM_GetAllocNo());
<a name="l00969"></a>00969         };
<a name="l00970"></a>00970 
<a name="l00975"></a>00975         <span class="keywordtype">void</span> MM_GetOverheadStats(<a class="code" href="structMM__AuditOverheadStats.html">MM_AuditOverheadStats</a>&amp; stats)
<a name="l00976"></a>00976         {
<a name="l00977"></a>00977             _pMM_Audit_Imp-&gt;MM_GetOverheadStats(stats);
<a name="l00978"></a>00978         };
<a name="l00979"></a>00979 
<a name="l00984"></a>00984         uint32 MM_GetNumAllocNodes()
<a name="l00985"></a>00985         {
<a name="l00986"></a>00986             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;MM_GetNumAllocNodes());
<a name="l00987"></a>00987         };
<a name="l00988"></a>00988 
<a name="l00992"></a>00992         uint32 MM_GetMode(<span class="keywordtype">void</span>)
<a name="l00993"></a>00993         {
<a name="l00994"></a>00994             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;MM_GetMode());
<a name="l00995"></a>00995         };
<a name="l00996"></a>00996 
<a name="l01001"></a>01001         uint8 MM_GetPrefillPattern(<span class="keywordtype">void</span>)
<a name="l01002"></a>01002         {
<a name="l01003"></a>01003             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;MM_GetPrefillPattern());
<a name="l01004"></a>01004         };
<a name="l01005"></a>01005 
<a name="l01010"></a>01010         uint32 MM_GetPostfillPattern(<span class="keywordtype">void</span>)
<a name="l01011"></a>01011         {
<a name="l01012"></a>01012             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;MM_GetPostfillPattern());
<a name="l01013"></a>01013         };
<a name="l01014"></a>01014 
<a name="l01018"></a>01018         <span class="keywordtype">void</span> MM_SetMode(uint32 inMode)
<a name="l01019"></a>01019         {
<a name="l01020"></a>01020             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l01021"></a>01021             iLock-&gt;Lock();
<a name="l01022"></a>01022 
<a name="l01023"></a>01023             _pMM_Audit_Imp-&gt;MM_SetMode(inMode);
<a name="l01024"></a>01024 
<a name="l01025"></a>01025             iLock-&gt;Unlock();
<a name="l01026"></a>01026         };
<a name="l01027"></a>01027 
<a name="l01031"></a>01031         <span class="keywordtype">void</span> MM_SetPrefillPattern(uint8 pattern)
<a name="l01032"></a>01032         {
<a name="l01033"></a>01033             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l01034"></a>01034             iLock-&gt;Lock();
<a name="l01035"></a>01035 
<a name="l01036"></a>01036             _pMM_Audit_Imp-&gt;MM_SetPrefillPattern(pattern);
<a name="l01037"></a>01037 
<a name="l01038"></a>01038             iLock-&gt;Unlock();
<a name="l01039"></a>01039         };
<a name="l01040"></a>01040 
<a name="l01044"></a>01044         <span class="keywordtype">void</span> MM_SetPostfillPattern(uint8 pattern)
<a name="l01045"></a>01045         {
<a name="l01046"></a>01046             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l01047"></a>01047             iLock-&gt;Lock();
<a name="l01048"></a>01048 
<a name="l01049"></a>01049             _pMM_Audit_Imp-&gt;MM_SetPostfillPattern(pattern);
<a name="l01050"></a>01050 
<a name="l01051"></a>01051             iLock-&gt;Unlock();
<a name="l01052"></a>01052         };
<a name="l01053"></a>01053 
<a name="l01058"></a>01058         <span class="keywordtype">void</span> MM_SetTagLevel(uint32 level)
<a name="l01059"></a>01059         {
<a name="l01060"></a>01060             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l01061"></a>01061             iLock-&gt;Lock();
<a name="l01062"></a>01062 
<a name="l01063"></a>01063             _pMM_Audit_Imp-&gt;MM_SetTagLevel(level);
<a name="l01064"></a>01064 
<a name="l01065"></a>01065             iLock-&gt;Unlock();
<a name="l01066"></a>01066         };
<a name="l01067"></a>01067 
<a name="l01074"></a>01074         <span class="keywordtype">bool</span> MM_SetFailurePoint(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn, uint32 alloc_number)
<a name="l01075"></a>01075         {
<a name="l01076"></a>01076             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l01077"></a>01077             iLock-&gt;Lock();
<a name="l01078"></a>01078 
<a name="l01079"></a>01079             <span class="keywordtype">bool</span> result = (_pMM_Audit_Imp-&gt;MM_SetFailurePoint(tagIn, alloc_number));
<a name="l01080"></a>01080 
<a name="l01081"></a>01081             iLock-&gt;Unlock();
<a name="l01082"></a>01082             <span class="keywordflow">return</span> result;
<a name="l01083"></a>01083         };
<a name="l01084"></a>01084 
<a name="l01085"></a>01085 
<a name="l01090"></a>01090         <span class="keywordtype">void</span> MM_UnsetFailurePoint(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
<a name="l01091"></a>01091         {
<a name="l01092"></a>01092             <span class="comment">// make sure lock is acquired and freed up upon return</span>
<a name="l01093"></a>01093             iLock-&gt;Lock();
<a name="l01094"></a>01094 
<a name="l01095"></a>01095             _pMM_Audit_Imp-&gt;MM_UnsetFailurePoint(tagIn);
<a name="l01096"></a>01096 
<a name="l01097"></a>01097             iLock-&gt;Unlock();
<a name="l01098"></a>01098         };
<a name="l01099"></a>01099 
<a name="l01100"></a>01100         int32 MM_GetRefCount()
<a name="l01101"></a>01101         {
<a name="l01102"></a>01102             int32 count;
<a name="l01103"></a>01103             iLock-&gt;Lock();
<a name="l01104"></a>01104             count = iRefCount;
<a name="l01105"></a>01105             iLock-&gt;Unlock();
<a name="l01106"></a>01106             <span class="keywordflow">return</span> count;
<a name="l01107"></a>01107         }
<a name="l01108"></a>01108 
<a name="l01114"></a>01114         <a class="code" href="classOsclLockBase.html">OsclLockBase</a>* GetLock()
<a name="l01115"></a>01115         {
<a name="l01116"></a>01116             <span class="keywordflow">return</span> iLock;
<a name="l01117"></a>01117         };
<a name="l01118"></a>01118 
<a name="l01119"></a>01119         <span class="comment">/*</span>
<a name="l01120"></a>01120 <span class="comment">        * The following are private member functions</span>
<a name="l01121"></a>01121 <span class="comment">        */</span>
<a name="l01122"></a>01122 
<a name="l01123"></a>01123     <span class="keyword">private</span>:
<a name="l01127"></a>01127         <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>* addAllocNode(<span class="keywordtype">void</span> *pMem, uint32 sizeIn, <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* pStatsNode,
<a name="l01128"></a>01128                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *pFileName, uint32 lineNumber)
<a name="l01129"></a>01129         {
<a name="l01130"></a>01130             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;addAllocNode(pMem, sizeIn, pStatsNode, pFileName, lineNumber));
<a name="l01131"></a>01131         }
<a name="l01132"></a>01132 
<a name="l01136"></a>01136         <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* removeAllocNode(<span class="keywordtype">void</span> *pMemBlockIn, uint32&amp; size)
<a name="l01137"></a>01137         {
<a name="l01138"></a>01138             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;removeAllocNode(pMemBlockIn, size));
<a name="l01139"></a>01139         }
<a name="l01140"></a>01140 
<a name="l01141"></a>01141         <span class="keywordtype">void</span> removeALLAllocNodes()
<a name="l01142"></a>01142         {
<a name="l01143"></a>01143             _pMM_Audit_Imp-&gt;removeALLAllocNodes();
<a name="l01144"></a>01144         }
<a name="l01145"></a>01145 
<a name="l01149"></a>01149         <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* createStatsNode(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn)
<a name="l01150"></a>01150         {
<a name="l01151"></a>01151             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;createStatsNode(tagIn));
<a name="l01152"></a>01152         }
<a name="l01153"></a>01153 
<a name="l01157"></a>01157         <span class="keywordtype">bool</span> updateStatsNode(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *pCurrStatsNode,
<a name="l01158"></a>01158                              <span class="keyword">const</span> <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>&amp; pDelta, <span class="keywordtype">bool</span> bAdd)
<a name="l01159"></a>01159         {
<a name="l01160"></a>01160             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;updateStatsNode(pCurrStatsNode, pDelta, bAdd));
<a name="l01161"></a>01161         }
<a name="l01162"></a>01162 
<a name="l01166"></a>01166         <span class="keywordtype">bool</span> updateStatsNodeInFailure(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
<a name="l01167"></a>01167         {
<a name="l01168"></a>01168             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;updateStatsNodeInFailure(tagIn));
<a name="l01169"></a>01169         }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171         <span class="keywordtype">bool</span> updateStatsNodeInFailure(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> * pStatsNode)
<a name="l01172"></a>01172         {
<a name="l01173"></a>01173             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;updateStatsNodeInFailure(pStatsNode));
<a name="l01174"></a>01174         }
<a name="l01175"></a>01175 
<a name="l01179"></a>01179         <span class="keywordtype">bool</span> pruneSubtree(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *pNode)
<a name="l01180"></a>01180         {
<a name="l01181"></a>01181             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;pruneSubtree(pNode));
<a name="l01182"></a>01182         }
<a name="l01183"></a>01183 
<a name="l01184"></a>01184         <span class="keywordtype">bool</span> pruneSubtree(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
<a name="l01185"></a>01185         {
<a name="l01186"></a>01186             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;pruneSubtree(tagIn));
<a name="l01187"></a>01187         }
<a name="l01188"></a>01188 
<a name="l01189"></a>01189         <span class="keywordtype">void</span> retrieveParentTag(<span class="keywordtype">char</span> *tag)
<a name="l01190"></a>01190         {
<a name="l01191"></a>01191             (_pMM_Audit_Imp-&gt;retrieveParentTag(tag));
<a name="l01192"></a>01192         }
<a name="l01193"></a>01193 
<a name="l01197"></a>01197         int32 retrieveParentTagLength(<span class="keyword">const</span> <span class="keywordtype">char</span> *tag, int32 bound)
<a name="l01198"></a>01198         {
<a name="l01199"></a>01199             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;retrieveParentTagLength(tag, bound));
<a name="l01200"></a>01200         }
<a name="l01201"></a>01201 
<a name="l01205"></a>01205         <span class="keywordtype">void</span> makeValidTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn, MMAuditCharAutoPtr&amp; autoptr)
<a name="l01206"></a>01206         {
<a name="l01207"></a>01207             (_pMM_Audit_Imp-&gt;makeValidTag(tagIn, autoptr));
<a name="l01208"></a>01208         }
<a name="l01209"></a>01209 
<a name="l01213"></a>01213         uint32 getTagActualSize(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
<a name="l01214"></a>01214         {
<a name="l01215"></a>01215             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;getTagActualSize(tagIn));
<a name="l01216"></a>01216         }
<a name="l01217"></a>01217 
<a name="l01221"></a>01221         <span class="keywordtype">bool</span> isSetFailure(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
<a name="l01222"></a>01222         {
<a name="l01223"></a>01223             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;isSetFailure(tagIn));
<a name="l01224"></a>01224         }
<a name="l01225"></a>01225 
<a name="l01226"></a>01226         <span class="keywordtype">bool</span> isSetFailure(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> * statsNode)
<a name="l01227"></a>01227         {
<a name="l01228"></a>01228             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;isSetFailure(statsNode));
<a name="l01229"></a>01229         }
<a name="l01230"></a>01230 
<a name="l01234"></a>01234         <span class="keywordtype">bool</span> validate(<span class="keywordtype">void</span> *ptrIn)
<a name="l01235"></a>01235         {
<a name="l01236"></a>01236             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;validate(ptrIn));
<a name="l01237"></a>01237         }
<a name="l01238"></a>01238 
<a name="l01242"></a>01242         <span class="keywordtype">bool</span> validate_all_heap()
<a name="l01243"></a>01243         {
<a name="l01244"></a>01244             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;validate_all_heap());
<a name="l01245"></a>01245         }
<a name="l01246"></a>01246 
<a name="l01247"></a>01247 
<a name="l01248"></a>01248     <span class="keyword">private</span>:
<a name="l01249"></a>01249 
<a name="l01250"></a>01250         <span class="comment">/*</span>
<a name="l01251"></a>01251 <span class="comment">        * The following are private data members</span>
<a name="l01252"></a>01252 <span class="comment">        */</span>
<a name="l01253"></a>01253 
<a name="l01254"></a>01254         <a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a> *_pMM_Audit_Imp;
<a name="l01255"></a>01255         <a class="code" href="classOsclLockBase.html">OsclLockBase</a> *iLock;
<a name="l01256"></a>01256 
<a name="l01260"></a>01260         _OsclBasicLock iSingletonLock;
<a name="l01261"></a>01261         int32 iRefCount;
<a name="l01262"></a>01262         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classOsclMemGlobalAuditObject.html">OsclMemGlobalAuditObject</a>;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264 };
<a name="l01265"></a>01265 <span class="preprocessor">#endif</span>
<a name="l01266"></a>01266 <span class="preprocessor"></span>
<a name="l01267"></a>01267 <span class="preprocessor">#endif //OSCL_MEM_AUDIT_H_INCLUDED</span>
<a name="l01268"></a>01268 <span class="preprocessor"></span>
</pre></div></div>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: CORE_9.005.1.1 </small>
</small></address>
</body>
</html>
