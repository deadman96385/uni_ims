/*
 * THIS IS AN UNPUBLISHED WORK CONTAINING D2 TECHNOLOGIES, INC. CONFIDENTIAL
 * AND PROPRIETARY INFORMATION.  IF PUBLICATION OCCURS, THE FOLLOWING NOTICE
 * APPLIES: "COPYRIGHT 2006-2010 D2 TECHNOLOGIES, INC. ALL RIGHTS RESERVED"
 *
 * $D2Tech$ $Rev: 30178 $ $Date: 2014-12-03 10:12:26 +0800 (Wed, 03 Dec 2014) $
 *
 */
#include "vtspr.h"
#include "_vtspr_private.h"

#ifdef VTSP_ENABLE_CODER_LOOPBACK
    uint8 bufferLoopBack[VTSP_BLOCK_MAX_SZ];
    vint  decTypeLoopBack;
    vint  pSizeLoopBack;
#endif

/*
 * ======== _VTSPR_msToFrames() ========
 *
 * Divide ms in a block by 10 to get frames
 * This routine works only for input values 0, 10, 20, 30, ... 60,
 * which are the allowed coding lengths in vPort.
 */
vint _VTSPR_msToFrames(vint ms)
{
    /*
     * return ((ms - (ms >> 3)) >> 3) this is faster
     */
    return (ms / 10);
}

/*
 * ======== _VTSPR_setBlockHdr() ========
 *
 * Set block header information for RTP for packing and sending out blocks
 * generated by the voice coders.
 */
void _VTSPR_setBlockHdr(
    VTSPR_StreamObj    *stream_ptr,
    VTSP_BlockHeader   *hdr_ptr,
    uvint               encType)
{
    vint maxFrames;

    /* Set default for APPEND and SEND */
    hdr_ptr->extension   &= ~(VTSP_MASK_EXT_APPEND | VTSP_MASK_EXT_SEND);

    /*
     * maxFrames is in 10 ms chunks, values from 0 frames to 6 frames
     * maxFrames is based on the current encoder, not encType which can be
     * switched to CN.
     */
    maxFrames = _VTSPR_msToFrames(stream_ptr->streamParam.encodeTime[
            stream_ptr->streamParam.encoder]);

    /*
     * Count silence frames, and set marker bit flag if the number of silence
     * frame exceeds maxFrames. This indicates that the marker bit should be
     * set in the next valid voice packet, for voice coders which support
     * silience supression.
     */
    if ((0 == stream_ptr->blockLen) || (VTSP_CODER_CN == encType)) {
        stream_ptr->silFrameCnt++;
        if (stream_ptr->silFrameCnt > maxFrames) {
            stream_ptr->marker = 1;
        }
    }
    else {
        stream_ptr->silFrameCnt = 0;
    }

    /*
     * For comfort noise. CoderType does not change for CN packet.
     * Send immediately.
     * No append to previous pkt.
     *
     * CN pkts are always 10 ms blocktime.
     * Application sets encodeTime[CN] to configure the CN periodic rate.
     */
    if (VTSP_CODER_CN == encType) {
        stream_ptr->framesSent = 1;
        hdr_ptr->extension |= VTSP_MASK_EXT_SEND;
        return;
    }

    /*
     * For changed coder.
     * Reset framesSent and silFrameCnt
     *
     * !!! Important Note !!
     * Always append, unless there is a change of coder type.
     * Different packet types can not append the payload.
     */
    if (0 != (VTSP_MASK_EXT_CODER_CHANGE & hdr_ptr->extension)) {
        stream_ptr->framesSent = 0;
        stream_ptr->silFrameCnt = 0;
    }
    else {
        hdr_ptr->extension   |= VTSP_MASK_EXT_APPEND;
    }

    switch (encType) {
#ifdef VTSP_ENABLE_ILBC
        case VTSP_CODER_ILBC_20MS:
            /*
             * Although ILBC does not support silence suppression, we need to
             * set the marker, if changing from silence from another packet
             * type.
             */
            if (1 == stream_ptr->marker) {
                hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                stream_ptr->marker = 0;
            }
            stream_ptr->cnPktTime = 10;

            stream_ptr->framesSent = 2;
            hdr_ptr->extension   |= VTSP_MASK_EXT_SEND;
            return;
        case VTSP_CODER_ILBC_30MS:
            /*
             * Although ILBC does not support silence suppression, we need to
             * set the marker, if changing from silence from another packet
             * type.
             */
            if (1 == stream_ptr->marker) {
                hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                stream_ptr->marker = 0;
            }
            stream_ptr->cnPktTime = 10;

            stream_ptr->framesSent = 3;
            hdr_ptr->extension   |= VTSP_MASK_EXT_SEND;
            return;
#endif
#ifdef VTSP_ENABLE_G723
        case VTSP_CODER_G723_30MS:
            /*
             * Blocklen varies according to the following examples:
             *
             * 6.3kb/s: 0, 0, 20, 0, 0, 20, 0, 0, 20, 0, 0, 20, ...
             *             voice,    voice,    voice,    voice, ..
             * w/ SID:  0, 0, 20, 0, 0,  4, 0, 0,  0, 0, 0, 20, ...
             *             voice,  silence,continuation, voice, ..
             * 5.3kb/s: 0, 0, 24, 0, 0, 24, 0, 0, 24, 0, 0, 24, ...
             *             voice,    voice,    voice,    voice, ..
             * w/ SID:  0, 0, 24, 0, 0,  4, 0, 0,  0, 0, 0, 24, ...
             *             voice,  silence,continuation, voice, ..
             */

            stream_ptr->framesSent = 3;
            hdr_ptr->extension   |= VTSP_MASK_EXT_SEND;

            if (VTSP_BLOCK_G723_SID_SZ < stream_ptr->blockLen) {
                /*
                 * Valid, voice packet, check to see if marker should be set.
                 */
                if (1 == stream_ptr->marker) {
                    hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                    stream_ptr->marker = 0;
                }
                stream_ptr->cnPktTime = 10;
            }

            return;
#endif
#ifdef VTSP_ENABLE_G722P1
        case VTSP_CODER_G722P1_20MS:
            if (1 == stream_ptr->marker) {
                hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                stream_ptr->marker = 0;
            }
            stream_ptr->cnPktTime = 10;

            stream_ptr->framesSent = 2;
            hdr_ptr->extension   |= VTSP_MASK_EXT_SEND;
            return;
#endif
#if defined(VTSP_ENABLE_GAMRNB) || defined(VTSP_ENABLE_GAMRNB_ACCELERATOR)
        case VTSP_CODER_GAMRNB_20MS_OA:
        case VTSP_CODER_GAMRNB_20MS_BE:
            if (0 == stream_ptr->blockLen) {
                stream_ptr->framesSent  = 2;
                hdr_ptr->extension     &= (~VTSP_MASK_EXT_MARKER);
                hdr_ptr->extension     &= (~VTSP_MASK_EXT_SEND);
                return;
            }
            else if (((VTSP_CODER_GAMRNB_20MS_OA == encType) &&
                    (VTSP_BLOCK_GAMRNB_20MS_OA_MRDTX_SZ ==
                    stream_ptr->blockLen)) ||
                    ((VTSP_CODER_GAMRNB_20MS_BE == encType) &&
                    (VTSP_BLOCK_GAMRNB_20MS_BE_MRDTX_SZ ==
                    stream_ptr->blockLen))) {
                stream_ptr->marker      = 1;
                stream_ptr->framesSent  = 2;
                hdr_ptr->extension     &= (~VTSP_MASK_EXT_MARKER);
                hdr_ptr->extension     |= VTSP_MASK_EXT_SEND;
                return;
            }
            else if (VTSP_BLOCK_GAMR_NODATA_SZ == stream_ptr->blockLen) {
                stream_ptr->marker      = 1;
                stream_ptr->framesSent  = 2;
                hdr_ptr->extension     &= (~VTSP_MASK_EXT_MARKER);
                hdr_ptr->extension     |= VTSP_MASK_EXT_SEND;
                return;
            }
            if (1 == stream_ptr->marker) {
                hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                stream_ptr->marker = 0;
            }
            stream_ptr->cnPktTime   = 10;
            stream_ptr->framesSent += 2;
            hdr_ptr->extension     |= VTSP_MASK_EXT_SEND;
            return;
#endif
#if defined(VTSP_ENABLE_GAMRWB) || defined(VTSP_ENABLE_GAMRWB_ACCELERATOR)
        case VTSP_CODER_GAMRWB_20MS_OA:
        case VTSP_CODER_GAMRWB_20MS_BE:
            if (0 == stream_ptr->blockLen) {
                stream_ptr->framesSent  = 2;
                hdr_ptr->extension     &= (~VTSP_MASK_EXT_MARKER);
                hdr_ptr->extension     &= (~VTSP_MASK_EXT_SEND);
                return;
            }
            else if (((VTSP_CODER_GAMRWB_20MS_OA == encType) &&
                    (VTSP_BLOCK_GAMRWB_20MS_OA_MRDTX_SZ ==
                    stream_ptr->blockLen)) ||
                    ((VTSP_CODER_GAMRWB_20MS_BE == encType) &&
                    (VTSP_BLOCK_GAMRWB_20MS_BE_MRDTX_SZ ==
                    stream_ptr->blockLen))) {
                stream_ptr->marker      = 1;
                stream_ptr->framesSent  = 2;
                hdr_ptr->extension     &= (~VTSP_MASK_EXT_MARKER);
                hdr_ptr->extension     |= VTSP_MASK_EXT_SEND;
                return;
            }
            else if (VTSP_BLOCK_GAMR_NODATA_SZ == stream_ptr->blockLen) {
                stream_ptr->marker      = 1;
                stream_ptr->framesSent  = 2;
                hdr_ptr->extension     &= (~VTSP_MASK_EXT_MARKER);
                hdr_ptr->extension     |= VTSP_MASK_EXT_SEND;
                return;
            }
            if (1 == stream_ptr->marker) {
                hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                stream_ptr->marker = 0;
            }
            stream_ptr->cnPktTime   = 10;
            stream_ptr->framesSent += 2;
            hdr_ptr->extension     |= VTSP_MASK_EXT_SEND;
            return;
#endif
#ifdef VTSP_ENABLE_SILK
        case VTSP_CODER_SILK_20MS_8K:
        case VTSP_CODER_SILK_20MS_16K:
        case VTSP_CODER_SILK_20MS_24K:
            if (1 == stream_ptr->marker) {
                hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                stream_ptr->marker = 0;
            }
            stream_ptr->cnPktTime = 10;

            stream_ptr->framesSent = 2;
            hdr_ptr->extension   |= VTSP_MASK_EXT_SEND;
            return;
#endif
#ifdef VTSP_ENABLE_G711P1
        case VTSP_CODER_G711P1U:
        case VTSP_CODER_G711P1A:
            if (1 == stream_ptr->marker) {
                hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                stream_ptr->marker = 0;
            }
            stream_ptr->cnPktTime = 10;

            stream_ptr->framesSent = 1;
            hdr_ptr->extension   |= VTSP_MASK_EXT_SEND;
            return;
#endif

#ifdef VTSP_ENABLE_G729
        case VTSP_CODER_G729:
            if (0 == stream_ptr->blockLen) {
                /*
                 * SID continuation (no data).
                 * Send current data immediately (if any - should be none).
                 * Hopefully the accumulated packet is already sent by the
                 * RTP, otherwise the G.729AB SID logic is wrong (follows).
                 *
                 * In the case of G.729 silence suppression, set the state when
                 * the coder signals that it does not have a packet to send.
                 * This only occurs after a G.729B packet has been sent.
                 */
                stream_ptr->framesSent = 1;
                hdr_ptr->extension |= VTSP_MASK_EXT_SEND;
                return;
            }
            else if (VTSP_BLOCK_G729_SID_SZ == stream_ptr->blockLen) {
                /*
                 * Always append SID.
                 * If RTP has nothing to append, it sends SID packet
                 * only.
                 */
                stream_ptr->framesSent = 1;
                hdr_ptr->extension |= VTSP_MASK_EXT_SEND;
                return;
            }
            /*
             * blockLen must be VTSP_BLOCK_G729_10MS_SZ.
             *
             * Warning: fall through switch statement to the G711 case.
             */
#endif
#ifdef VTSP_ENABLE_G726
        case VTSP_CODER_G726_32K:
#endif
#ifdef VTSP_ENABLE_G722
        case VTSP_CODER_G722:
#endif
        case VTSP_CODER_G711A:
        case VTSP_CODER_G711U:
            stream_ptr->framesSent += 1;
            stream_ptr->cnPktTime = 10;
            if (stream_ptr->framesSent >= maxFrames) {
                /*
                 * Boundary reached.
                 * Append to previous pkt (if any).
                 * Send the pkt.
                 */
                hdr_ptr->extension |= VTSP_MASK_EXT_SEND;
                /*
                 * If marker has been set, set the marker bit with the next
                 * packet. In addition, reset marker and set cnPktTime to 10 so
                 * that the next CN (silent suppression packet) will transmit as
                 * soon as detected.
                 */
                if (1 == stream_ptr->marker) {
                    hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                    stream_ptr->marker = 0;
                }
            }
            else {
                /*
                 * Boundary not reached yet.
                 * Don't send yet.
                 * Append to previous pkt.
                 */
            }
            return;

#ifdef VTSP_ENABLE_16K_MU
        case VTSP_CODER_16K_MU:
            /*
             * The following code is copied from the G711U case, above.
             * But, it supports ONLY 10 ms packets, not packets that
             * hold 20 ms or more of 16K sampled data.
             * So, maxFrames and framesSent not used.
             */
            stream_ptr->cnPktTime = 10;
            /*
             * Append to previous pkt (if any).  * Send the pkt.
             */
            stream_ptr->framesSent = 1;
            hdr_ptr->extension |= VTSP_MASK_EXT_SEND;
            /*
             * If marker has been set, set the marker bit with the next
             * packet. In addition, reset marker and set cnPktTime to 10 so
             * that the next CN (silent suppression packet) will transmit as
             * soon as detected.
             */
            if (1 == stream_ptr->marker) {
                hdr_ptr->extension |= VTSP_MASK_EXT_MARKER;
                stream_ptr->marker = 0;
            }
            return;
#endif /* end VTSP_ENABLE_16K_MU */

#if defined(VTSP_ENABLE_DTMFR) && !defined(VTSP_ENABLE_MP_LITE)
        case VTSP_CODER_DTMF:
            /* fall through */
        case VTSP_CODER_TONE:
            /*
             * Send DTMF if boundary reached and no append to previous pkt.
             * Always send end packets.
             * timestamp is set elsewhere.
             */
            if (0 == stream_ptr->blockLen) {
                break;
            }
            stream_ptr->framesSent++;
            if (stream_ptr->framesSent >= maxFrames) {
                hdr_ptr->extension |= VTSP_MASK_EXT_SEND;
                if (0 != stream_ptr->drEncodeObj.end) {
                    DR_increaseEnd(&stream_ptr->drEncodeObj);
                }
            }
            hdr_ptr->extension |= VTSP_MASK_EXT_DR;
            break;
#endif
        case VTSP_CODER_UNAVAIL:
            /* Fall-through */
        default:
            /*
             * May get here if application sets improper encoder.
             * Don't send anything.
             */
            stream_ptr->framesSent = 0;
            stream_ptr->blockLen = 0;
            break;
    }
}



/*
 * ======== _VTSPR_audioStreamDecode() ========
 *
 * Process audio payload from peer end on stream
 *
 * PLC, NFE
 * SID decode (NSE)
 * T.38 decode
 * G.7xx decode
 * G.7xx encode
 * TONE
 * MUTE
 */
void _VTSPR_audioStreamDecode(
    VTSPR_Obj    *vtspr_ptr,
    VTSPR_Queues *q_ptr,
    VTSPR_DSP    *dsp_ptr)
{
    VTSPR_ChanObj   *chan_ptr;
    VTSPR_StreamObj *stream_ptr;
    vint            *decOut_ptr;
    vint            *decIn_ptr;
#ifndef VTSP_ENABLE_MP_LITE
    PLC_Obj         *plc_ptr;
#endif
    JB_Pkt          *jbPkt_ptr;
    _VTSPR_FlowObj  *flow_ptr;
    uint32           streamMask;
    vint             streamId;
    vint             infc;           /* Must be signed */
    vint             pSize;
    vint             decType;
    vint             streamActive;
    vint             flowPlayState;
    uint32           chanMask;

    /*
     * Decode for all physical infc.
     */
    _VTSPR_FOR_ALL_INFC(infc) {
        chan_ptr   = _VTSPR_infcToChanPtr(dsp_ptr, infc);

        /*
         * Set stream active by default.
         */
        streamActive = 1;
        /*
         * Do for all streams on infc.
         */
        for (streamId = _VTSP_STREAM_PER_INFC - 1; streamId >= 0; streamId--) {
            stream_ptr = _VTSPR_streamIdToStreamPtr(dsp_ptr, infc, streamId);
            streamMask = stream_ptr->algStreamState;

            /*
             * RTCP packets are sent whenever the network is active. They are
             * not sent if the stream peer is local and stream dir is not ENDED.
             */
            if ((VTSP_STREAM_PEER_NETWORK == stream_ptr->streamParam.peer) &&
                    (_VTSP_STREAM_DIR_ENDED != stream_ptr->streamParam.dir)) {
                _VTSPR_rtcpSend(vtspr_ptr, q_ptr, dsp_ptr,
                        stream_ptr, infc, streamId);
            }

            if (VTSP_CODER_T38 == stream_ptr->streamParam.encoder) {
                /*
                 * This coder is not handled in normal stream processing.
                 */
                continue;
            }

            /*
             * XXX: Currently flows and streams are mapped identically. If the
             * mapping changes, this code MUST change.
             */
            flow_ptr = _VTSPR_streamIdToFlowPtr(dsp_ptr, infc, streamId);
            flowPlayState = flow_ptr->playState;

            if (VTSP_STREAM_PEER_NETWORK != stream_ptr->streamParam.peer) {
                /*
                 * Local peer.  This audio is already decoded. If a flow is
                 * sharing the stream, process the flow.
                 */
                if ((_VTSPR_FLOW_STATE_IDLE != flowPlayState) &&
                        (((VTSP_FLOW_DIR_LOCAL_PLAY & flow_ptr->flowDir) != 0)||
                        ((VTSP_FLOW_DIR_PEER_PLAY & flow_ptr->flowDir) != 0))) {
                    streamActive = 0;
                }
                else {
                    continue;
                }
            }

            if ((VTSP_STREAM_DIR_RECVONLY != stream_ptr->streamParam.dir) &&
                    (VTSP_STREAM_DIR_SENDRECV != stream_ptr->streamParam.dir)) {
                /*
                 * Skip stream if not receiving. If the flow is active, process
                 * the flow.
                 */

                if ((_VTSPR_FLOW_STATE_IDLE != flowPlayState) &&
                        (((VTSP_FLOW_DIR_LOCAL_PLAY & flow_ptr->flowDir) != 0)||
                        ((VTSP_FLOW_DIR_PEER_PLAY & flow_ptr->flowDir) != 0))) {
                    streamActive = 0;
                }
                else {
                    continue;
                }
            }

            /*
             * If the stream is active, get the current packet from jitter
             * buffer.  If valid packet from JB is received, turn off PLC bit,
             * otherwise set it.
             */
            jbPkt_ptr = &dsp_ptr->jbPkt;
            if (streamActive != 0) {
                if (0 != (VTSPR_ALG_STREAM_JB & streamMask)) {
                    /*
                     * XXX:
                     * Possible context switch here.
                     */
#ifdef VTSP_ENABLE_BENCHMARK
                    _VTSPR_benchmarkStart(vtspr_ptr,
                            _VTSPR_BENCHMARK_JB_GET, 1);
#endif
                    JB_getPkt(&stream_ptr->jbObj, jbPkt_ptr);
#ifdef VTSP_ENABLE_BENCHMARK
                    _VTSPR_benchmarkStop(vtspr_ptr,
                            _VTSPR_BENCHMARK_JB_GET, 1);
#endif
                }
                else {
                    /*
                     * Bypass JB
                     *
                     * XXX not  implemented.
                     */
                }
            }
#ifndef VTSP_ENABLE_MP_LITE
            /*
             * Process JB packet.
             * Decode far end data and place in proper stream array.
             * Get a pointer decOut_ptr for writing data into audio
             * Assume BPI cleared.
             */
            plc_ptr            = &stream_ptr->plcObj;
            plc_ptr->ctrlStat &= ~(PLC_CTRL_BPI);
#endif
            /*
             * Only use packet if valid, and if this interface is not doing
             * CIDCWS or processing and active flow.
             */

            chanMask = _VTSPR_getAlgStateChan(chan_ptr, infc);
            if ((JB_PKT_VALID == jbPkt_ptr->valid) &&
                    (0 == (chanMask & VTSPR_ALG_CHAN_CIDCWS)) &&
                    (_VTSPR_FLOW_STATE_IDLE == flowPlayState)) {
                decIn_ptr  = (vint  *)jbPkt_ptr->payload;
                pSize      = jbPkt_ptr->pSize;
                decType    = _VTSPR_jbCoderToLocalCoder(jbPkt_ptr->type, pSize);
                if (pSize > 0) {
                    if (jbPkt_ptr->seqn % 50 == 0) {
                        /* Notify audio RTP timestamp once for every 50 packets. */
                        // OSAL_logMsg("VTSPR notify audio RTP timestamp:%u\n", jbPkt_ptr->tsOrig);
                        _VTSPR_LipSync_rtpTs(infc, q_ptr, jbPkt_ptr);
                    }

                    /*
                     * Save the current decoding TS and atime.
                     */
                    stream_ptr->lastTimeStamp = jbPkt_ptr->ts;
                    stream_ptr->lastTimeArrival = jbPkt_ptr->atime;
                    /*
                     * Payload size must be greater than zero to change coder
                     * type.  Check if coder type has changed, init old coder
                     * type.  Set new decoder type in object.
                     */
                    if (decType != stream_ptr->decoderType) {
                        /*
                         * Init the coder if there was a change. Do not init
                         * if this packet is a comfort noise packet.
                         */
                        if (VTSP_CODER_CN != decType) {
                            _VTSPR_initCoder(dsp_ptr, stream_ptr, VTSPR_DECODER,
                                    decType);
                        }
                        if ((VTSP_CODER_DTMF == stream_ptr->decoderType) ||
                                (VTSP_CODER_TONE == stream_ptr->decoderType)) {
                            /*
                             * Changed coder from DTMF to something
                             * else.
                             *
                             * Init PLC here by turning it off, then
                             * turning it on.
                             */
                            _VTSPR_algStateStream(dsp_ptr, infc,
                                    streamId, VTSPR_ALG_STREAM_PLC, 0);
                            _VTSPR_algStateStream(dsp_ptr, infc,
                                    streamId, 0, VTSPR_ALG_STREAM_PLC);

                            /* Clear the channel algorithm state for DTMFR */
                            _VTSPR_algStateChan( dsp_ptr, infc,
                                   VTSPR_ALG_CHAN_DR_DEC, 0);
                        }
                        if ((VTSP_CODER_DTMF == decType) ||
                                (VTSP_CODER_TONE == decType)) {
                            /*
                             * Changed from another coder type to DTMF.
                             * Set the channel algorithm state for DTMFR.
                             */
                            _VTSPR_algStateChan( dsp_ptr, infc,
                                   0, VTSPR_ALG_CHAN_DR_DEC);
                        }
                        stream_ptr->decoderType = decType;
                    }
                }
                else {
                    /*
                     * Valid Pkt with zero length.
                     *
                     * If this is CN/G729-VAD/ILBC continuation,
                     * continue with the old decoder.
                     */
                    if ((VTSP_CODER_CN == stream_ptr->decoderType)
                            || (VTSP_CODER_G729 == stream_ptr->decoderType)
#ifdef VTSP_ENABLE_ILBC
                            || (VTSP_CODER_ILBC_20MS == stream_ptr->decoderType)
                            || (VTSP_CODER_ILBC_30MS == stream_ptr->decoderType)
#endif
#ifdef VTSP_ENABLE_G723
                            || (VTSP_CODER_G723_30MS == stream_ptr->decoderType)
#endif
#ifdef VTSP_ENABLE_G722
                            || (VTSP_CODER_G722 == stream_ptr->decoderType)
#endif
#ifdef VTSP_ENABLE_G722P1
                          || (VTSP_CODER_G722P1_20MS == stream_ptr->decoderType)
#endif
#ifdef VTSP_ENABLE_SILK
                        || (VTSP_CODER_SILK_20MS_8K == stream_ptr->decoderType)
                        || (VTSP_CODER_SILK_20MS_16K == stream_ptr->decoderType)
                        || (VTSP_CODER_SILK_20MS_24K == stream_ptr->decoderType)
#endif

                            ) {
                        decType = stream_ptr->decoderType;
                    }
#ifndef VTSP_ENABLE_MP_LITE
                    else {
                        /*
                         * This packet is lost, PLC with G711U PLC method.
                         */
                        plc_ptr->ctrlStat |= PLC_CTRL_BPI;
                        decType = VTSP_CODER_G711U;
                    }
#endif
                }
            }
            else if ((_VTSPR_FLOW_STATE_IDLE != flowPlayState) &&
                    (((VTSP_FLOW_DIR_LOCAL_PLAY & flow_ptr->flowDir) != 0) ||
                    ((VTSP_FLOW_DIR_PEER_PLAY & flow_ptr->flowDir) != 0))) {

                /*
                 * If the flow is not idle, get the coded audio and set the
                 * proper parameters to decode it.
                 */
                decType = _VTSPR_flowPlayNext(dsp_ptr, q_ptr, flow_ptr,
                        stream_ptr, (void **)&decIn_ptr);
                pSize = flow_ptr->playSize;
            }
            else {
                /*
                 * Invalid Pkt (no pkt) from JB.
                 * decType is same as previous decoder.
                 *
                 * decIn_ptr is not valid and must not be used.
                 * Set to NULL.
                 */
                pSize      = 0;
                decIn_ptr  = NULL;
                decType    = stream_ptr->decoderType;
                if (VTSP_CODER_DTMF == stream_ptr->decoderType) {
                    /*
                     * JB ensures that DTMF end is given if
                     * pkt loss occurs within DTMF stream.
                     *
                     * Pkt loss only occurs after DTMF end.
                     * Must init PLC history, as running PLC
                     * would contain tone.
                     *
                     * DR_Decode generates silence if pSize == 0.
                     *
                     * Initialize PLC here by turning it off, then
                     * back on.
                     */
                    _VTSPR_algStateStream(dsp_ptr, infc,
                            streamId, VTSPR_ALG_STREAM_PLC, 0);
                    _VTSPR_algStateStream(dsp_ptr, infc,
                            streamId, 0, VTSPR_ALG_STREAM_PLC);
                    _VTSPR_algStateChan(
                            dsp_ptr,
                            infc,
                            VTSPR_ALG_CHAN_DR_DEC,
                            0);

                    decType = VTSP_CODER_G711U;
                    stream_ptr->decoderType = decType;
                }
            }
            decOut_ptr   = stream_ptr->streamDecOut_ary;

#ifdef VTSP_ENABLE_CODER_LOOPBACK
            decType   = decTypeLoopBack;
            pSize     = pSizeLoopBack;
            if (0 != pSizeLoopBack) {
                decIn_ptr = (vint *) bufferLoopBack;
            }
            else {
                decIn_ptr = NULL;
            }
#endif
#ifndef VTSP_ENABLE_MP_LITE
            _VTSPR_audioCodedToLinear(vtspr_ptr, stream_ptr, decIn_ptr,
                    decOut_ptr, pSize, decType, plc_ptr, infc);
#else
            _VTSPR_audioCodedToLinear(vtspr_ptr, stream_ptr, decIn_ptr,
                    decOut_ptr, pSize, decType, infc);
#endif
#ifdef VTSP_ENABLE_STREAM_16K
            /* If NB coder then upsample to 16K conf rate, else just copy */
            if (_VTSPR_isCoderWb(decType)) {
                COMM_copy(stream_ptr->streamDec_ary,
                        stream_ptr->streamDecOut_ary, VTSPR_NSAMPLES_STREAM);
            }
#ifndef VTSP_ENABLE_MP_LITE
            else {
                _VTSPR_upSample(&stream_ptr->udsStreamUp,
                       stream_ptr->streamDec_ary, stream_ptr->streamDecOut_ary);
            }
#endif
#else /* not VTSP_ENABLE_STREAM_16k */
            COMM_copy(stream_ptr->streamDec_ary,
                    stream_ptr->streamDecOut_ary, VTSPR_NSAMPLES_STREAM);
#endif /* end VTSP_ENABLE_STREAM_16K */

        }
    }
}

/*
 * ======== _VTSPR_audioStreamEncode() ========
 *
 * Process audio to peer end on stream
 *
 * PLC, NFE
 * SID decode (NSE)
 * SID encode
 * T.38 decode
 * T.38 encode
 * G.7xx decode
 * G.7xx encode
 * TONE
 * MUTE
 */
void _VTSPR_audioStreamEncode(
    VTSPR_Obj          *vtspr_ptr,
    VTSPR_DSP          *dsp_ptr,
    vint                infc,
    VTSPR_StreamObj    *stream_ptr)
{
    VTSPR_ChanObj    *chan_ptr;
    VTSP_BlockHeader  blockHeader;
    VTSPR_NetObj     *net_ptr;
    _VTSPR_RtpObject *rtp_ptr;
    vint             *encOut_ptr;
    vint             *encIn_ptr; /* ptr to samps, either 160 or 80 */
    vint              voiceActive;
    vint              encType;
    vint              offset;
    uint32            chanMask;
    vint              rateChange;
    vint              lastExt;
    vint              curExt;
    vint              encoder;
    vint              offsetInc;
#if !defined(VTSP_ENABLE_MP_LITE) || defined(VTSP_ENABLE_NFE) || defined(VTSP_ENABLE_AEC)
    vint              noiseFloor;
#endif
    /*
     * - For the stream, sum all active peer streams, and
     * put the sum in a dsp_ptr->confBuffer (a stack buffer) for encoding to
     * that stream.
     *
     * - Mute audio when necessary just prior to encode
     *
     */
    chan_ptr   = _VTSPR_infcToChanPtr(dsp_ptr, infc);
#ifdef VTSP_ENABLE_NFE
    noiseFloor = chan_ptr->nfeInfcObj.noiseFloor; /* For CN */
#else
#ifdef VTSP_ENABLE_AEC
    noiseFloor = chan_ptr->aec_ptr->aecNearObj.noiseFloor / 10; /* For CN */
#else
#ifndef VTSP_ENABLE_MP_LITE
    noiseFloor = chan_ptr->bndNear_ptr->bndNoise / 10; /* For CN */
#endif /* VTSP_ENABLE_MP_LITE */
#endif
#endif
    chanMask   = _VTSPR_getAlgStateChan(chan_ptr, infc);
    /*
     * Check for SEND stream direction.
     */
    if ((VTSP_STREAM_DIR_SENDONLY != stream_ptr->streamParam.dir) &&
            (VTSP_STREAM_DIR_SENDRECV != stream_ptr->streamParam.dir)) {
        /*
         * Not sending; skip encode
         *
         * Should never get here
         */
        return;
    }
    /*
     * Set default 'extension' in header
     */
    blockHeader.extension = 0;

    if ((VTSP_CODER_T38 == stream_ptr->streamParam.encoder)
            && (stream_ptr->lastEncoder != VTSP_CODER_T38)) {
#ifdef VTSP_ENABLE_T38
        /*
         * Initialize FR38 that is allocated on a channel
         */
        _VTSPR_initCoder(dsp_ptr, stream_ptr, VTSPR_ENCODER,
                VTSP_CODER_T38);

        /*
         * Also initialize the last Encoder and Decoder
         */
        _VTSPR_initCoder(dsp_ptr, stream_ptr, VTSPR_ENCODER,
                stream_ptr->lastEncoder);
        _VTSPR_initCoder(dsp_ptr, stream_ptr, VTSPR_DECODER,
                stream_ptr->decoderType);

        stream_ptr->lastEncoder  = stream_ptr->streamParam.encoder;
        blockHeader.extension   |= VTSP_MASK_EXT_CODER_CHANGE;
#endif
        return;
    }

    if (VTSP_CODER_T38 == stream_ptr->streamParam.encoder) {
        /*
         * This coder is not handled within normal stream processing.
         */
        return;
    }

    net_ptr = vtspr_ptr->net_ptr;

    /*
     * buffer pointed by dsp_ptr->confBuffer is available for
     * encoding as src buffer.
     * buffer pointed by encOut_ptr is available for encoding as
     * dst buffer.
     *
     * encOut_ptr points to the available block buffer for the
     * RTP interface.
     */
    encOut_ptr = (vint  *)net_ptr->blockToNet;

    /*
     * If configured to do so, switch to VTSP_CODER_G711U if
     * a FAX tone has been detected on this interface.
     *
     * XXX: Disable silence compression during fax session. Note that silence
     * suppression does not resume unless the stream parameters are updated
     * (VTSP_streamStart() and  VTSP_streamModify() only).
     */
    if ((0 != (VTSPR_ALG_CHAN_FAX & chanMask)) &&
                (stream_ptr->streamParam.extension &
                 VTSP_MASK_EXT_FAX_64K) ) {
        stream_ptr->streamParam.encoder = VTSP_CODER_G711U;
        stream_ptr->streamParam.silenceComp &= (~VTSP_MASK_CODER_G711U);
    }

    /*
     * If configured on stream, save the current encoder and switch to
     * VTSP_CODER_DTMF if DTMF digit(s) have been detected on this
     * interface's audio channel.
     *
     * If DTMF digit has ended, switch back to previous coder.
     */
#ifdef VTSP_ENABLE_DTMFR
    if ((VTSP_CODER_DTMF != stream_ptr->streamParam.encoder) &&
            (VTSP_CODER_TONE != stream_ptr->streamParam.encoder)) {
        /*
         * Voice encoder is active
         */
        if (0 != (stream_ptr->streamParam.dtmfRelay &
                (1 << stream_ptr->streamParam.encoder)) &&
                (0 == (VTSPR_ALG_CHAN_FAX & chanMask))) {
            /*
             * DTMF relay is enabled for this encoder
             * and channel is not FAX
             */
            if ((0 != chan_ptr->drEventObj.event) &&
                    (0 == (stream_ptr->drEncodeObj.status & DR_IN_DIGIT))) {
                /*
                 * New LE DTMF event active.
                 * Change coder to DTMF
                 */
                blockHeader.extension |= (VTSP_MASK_EXT_CODER_CHANGE |
                        VTSP_MASK_EXT_DR);
                stream_ptr->drEncodeObj.prevCoder =
                        stream_ptr->streamParam.encoder;
                if (DR_RELAY_MODE_EVENT == chan_ptr->drEventObj.relayMode) {
                    stream_ptr->streamParam.encoder = VTSP_CODER_DTMF;
                } else {
                    stream_ptr->streamParam.encoder = VTSP_CODER_TONE;
                }
            }
        }
    }
    else {
        /*
         * encoder is DTMF
         */
        if ((0 == (DR_IN_DIGIT & stream_ptr->drEncodeObj.status))) {
            /*
             * Trailing edge DTMF - switch encoder back
             */
            encoder = stream_ptr->streamParam.encoder;
            stream_ptr->streamParam.encoder = stream_ptr->drEncodeObj.prevCoder;
            stream_ptr->drEncodeObj.prevCoder = encoder;
       }
    }
#endif

    /*
     * Check encoder type.
     */
    encType = stream_ptr->streamParam.encoder;
    rateChange = 0;
    lastExt = 0;
    curExt = 0;
    /* Check if G723 or G722P1 coder rate has changed */
    if (VTSP_CODER_G723_30MS == encType) {
        lastExt = stream_ptr->lastExtension & VTSP_MASK_EXT_G723_53;
        curExt  = stream_ptr->streamParam.extension & VTSP_MASK_EXT_G723_53;
    }
    else if (VTSP_CODER_G722P1_20MS == encType) {
        lastExt = stream_ptr->lastExtension & VTSP_MASK_EXT_G722P1_32;
        curExt = stream_ptr->streamParam.extension & VTSP_MASK_EXT_G722P1_32;
    }
    else if ((VTSP_CODER_GAMRNB_20MS_OA == encType) ||
            (VTSP_CODER_GAMRNB_20MS_BE == encType)) {
        /* XXX GAMRNB rate switching via extension word not implemented yet */
    }
    else if ((VTSP_CODER_GAMRWB_20MS_OA == encType) ||
            (VTSP_CODER_GAMRWB_20MS_BE == encType)) {
        /* XXX GAMRWB rate switching via extension word not implemented yet */
    }

    if (lastExt != curExt) {
        rateChange = 1;
    }
    stream_ptr->lastExtension = stream_ptr->streamParam.extension;

    /* If encoder type or bitRate changed, init the new encoder */
    if ((encType != stream_ptr->lastEncoder) || rateChange) {
        _VTSPR_initCoder(dsp_ptr, stream_ptr, VTSPR_ENCODER, encType);
        if ((VTSP_CODER_DTMF == stream_ptr->lastEncoder) ||
                (VTSP_CODER_TONE == stream_ptr->lastEncoder)) {
            blockHeader.extension |= VTSP_MASK_EXT_DR;
        }
        stream_ptr->lastEncoder = encType;
        blockHeader.extension |= VTSP_MASK_EXT_CODER_CHANGE;
    }

    /*
     * Generate dual/single tone to net if requested.
     * Overwrite audio.
     */
    _VTSPR_audioPeerTone(dsp_ptr, infc, stream_ptr);

    /*
     * Encode.
     * encType may change temporarily (for CN)
     */
    stream_ptr->countEncode++;
    stream_ptr->count.encodePkt++;
    stream_ptr->count.encodeBytes += stream_ptr->blockLen;

    if ((stream_ptr->streamParam.encodeType[encType] != VTSP_CODER_UNAVAIL)) {
        /*
         *  change the pointer to audio data, depending on WB and encType
         */
#ifdef VTSP_ENABLE_STREAM_16K
        if (_VTSPR_isCoderWb(encType)) {
             encIn_ptr = stream_ptr->confPeer_ary;
        }
        else {
#ifndef VTSP_ENABLE_MP_LITE
            _VTSPR_downSample(&stream_ptr->udsStreamDown,
                   stream_ptr->streamEncIn_ary, stream_ptr->confPeer_ary);
            encIn_ptr = stream_ptr->streamEncIn_ary;
#endif
        }
#else
        encIn_ptr = stream_ptr->confPeer_ary;
#endif
        voiceActive = _VTSPR_infcToVadStatus(chan_ptr, infc);
        /*
         * Encode speeech, and note that encType can change to CN
         */
        encType = _VTSPR_audioLinearToCoded(
                stream_ptr,
                encIn_ptr,   /* points to either 80 or 160 vints */
                encOut_ptr,
                encType,
                voiceActive,
#ifdef VTSP_ENABLE_DTMFR
                &chan_ptr->drEventObj,
#endif
#if !defined(VTSP_ENABLE_MP_LITE) || defined(VTSP_ENABLE_NFE) || defined(VTSP_ENABLE_AEC)
                noiseFloor, /* For CN */
#endif
                infc);
    }

#ifdef VTSP_ENABLE_CODER_LOOPBACK
    pSizeLoopBack = stream_ptr->blockLen;
    COMM_octetCopy(bufferLoopBack, (uint8 *) encOut_ptr, pSizeLoopBack);
    decTypeLoopBack = encType;
#endif
    /*
     * Fill in BlockHeader here
     */
    _VTSPR_setBlockHdr(stream_ptr, &blockHeader, encType);
    blockHeader.dynamicCoder = _VTSPR_localToDynamicEncoder(
            &stream_ptr->streamParam, encType);
    blockHeader.localCoder = encType;
    blockHeader.infc         = infc;
    blockHeader.streamId     = stream_ptr->streamParam.streamId;

    rtp_ptr = _VTSPR_streamIdToRtpPtr(net_ptr, infc,
            stream_ptr->streamParam.streamId);

    if ((encType != VTSP_CODER_DTMF) && (encType != VTSP_CODER_TONE)) {
        /*
         * Call _VTSPR_rtpSend() every 10ms. This allows RTP send to keep track
         * of the duration of a packet. This is used to fix a problem where a
         * multiframe packet is interrupted. The timestamp for the subsequent
         * packet can be calculated based on the duration of the multiframe
         * packet.
         *
         * Call _VTSPR_rtpSend() to transmit data to network.
         * The block data is in network byte order.
         */
        _VTSPR_rtpSend(vtspr_ptr, rtp_ptr, &blockHeader, (uint8 *)encOut_ptr,
                stream_ptr->blockLen, (COMM_MAX(stream_ptr->framesSent,1) - 1));
        if ((blockHeader.extension & VTSP_MASK_EXT_SEND) != 0) {
            /*
             * If the payload was sent, then clear framesSent
             */
            stream_ptr->framesSent = 0;
        }
    }
#ifdef VTSP_ENABLE_DTMFR
    else {
        if (encType == VTSP_CODER_DTMF) {
            offsetInc = DR_NUM_BYTES_EVENT;
        }
        else {
            offsetInc = DR_NUM_BYTES_TONE;
        }
        /*
         * DTMF/Tone relay encoder supplies multiple payloads in a single call.
         * each payload must be sent to RTP separately.  In the header,
         * only the timestamp needs updating.
         */
        for (offset = 0; offset < stream_ptr->blockLen; offset += offsetInc) {
            /*
             * call _VTSPR_rtpSend() to transmit multiple DTMF Relay packets to
             * the network.
             * framesM1 is not used for DTMF packets
             */
            _VTSPR_rtpSend(vtspr_ptr, rtp_ptr, &blockHeader,
                    ((uint8 *)(encOut_ptr)) + offset, stream_ptr->blockLen, 0);
        }
        if ((blockHeader.extension & VTSP_MASK_EXT_SEND) != 0) {
            stream_ptr->framesSent = 0;
        }
    }
#endif
}
