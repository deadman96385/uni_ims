<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>oscl: OSCL Memory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>OSCL Memory</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMem.html">OsclMem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclAuditCB.html">OsclAuditCB</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemAllocDestructDealloc.html">OsclMemAllocDestructDealloc&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemBasicAllocDestructDealloc.html">OsclMemBasicAllocDestructDealloc&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemGlobalAuditObject.html">OsclMemGlobalAuditObject</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classHeapBase.html">HeapBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMM__Stats__t.html">MM_Stats_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMM__FailInsertParam.html">MM_FailInsertParam</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMM__Stats__CB.html">MM_Stats_CB</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMM__AllocInfo.html">MM_AllocInfo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMM__AllocNode.html">MM_AllocNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMM__AuditOverheadStats.html">MM_AuditOverheadStats</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMM__Audit__Imp.html">MM_Audit_Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemAudit.html">OsclMemAudit</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMM__AllocBlockHdr.html">MM_AllocBlockHdr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMM__AllocBlockFence.html">MM_AllocBlockFence</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr&lt; T, _Allocator &gt;</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The oscl_auto_ptr class is a template class that defines a pointer like object intended to be assigned an address obtanined (directly or or indirectly) by new. When the oscl_auto_ptr expires, its destructor uses delete to free the memory.  <a href="classOSCLMemAutoPtr.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemPoolFixedChunkAllocatorObserver.html">OsclMemPoolFixedChunkAllocatorObserver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemPoolFixedChunkAllocator.html">OsclMemPoolFixedChunkAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemPoolResizableAllocatorObserver.html">OsclMemPoolResizableAllocatorObserver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemPoolResizableAllocatorMemoryObserver.html">OsclMemPoolResizableAllocatorMemoryObserver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclMemPoolResizableAllocator.html">OsclMemPoolResizableAllocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classallocator.html">allocator</a></td></tr>
<tr><td colspan="2"><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__mem__basic__functions_8h.html">oscl_mem_basic_functions.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file contains prototypes for the basic memory functions. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__mem_8h.html">oscl_mem.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file contains basic memory definitions for common use across platforms. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__mem__audit_8h.html">oscl_mem_audit.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file contains the definition and partial implementation of MM_Audit class. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__mem__audit__internals_8h.html">oscl_mem_audit_internals.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file contains the internal definitions for the mem audit library. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__mem__auto__ptr_8h.html">oscl_mem_auto_ptr.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file defines the oscl_mem_auto_ptr template class. This class is used to avoid any potential memory leaks that may arise while returning from methods in case of error. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__mem__mempool_8h.html">oscl_mem_mempool.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This file contains the definition of memory pool allocators. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga9fcc278d0a7a8d1c95f95c3bd7067994">OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga9fcc278d0a7a8d1c95f95c3bd7067994">OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gae92c2c0f2f9ac61cc741efc88c67264d">OSCL_CLEANUP_BASE_CLASS</a>(T)&nbsp;&nbsp;&nbsp;_OSCL_CLEANUP_BASE_CLASS(T)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gadf4b04d6c6c95fbeb0fdbe2c70ecb93a">OSCL_ALLOC_NEW</a>(T_allocator, T, params)&nbsp;&nbsp;&nbsp;new(T_allocator.allocate(1)) T params</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga86a28832146864af539f81cac7aabc98">OSCL_TRAP_ALLOC_NEW</a>(T_ptr, T_allocator, T, params)&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(T_allocator.allocate(1),T_allocator.deallocate,T_ptr,T,params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gabc57a479922c1847e023cc109436c5c7">OSCL_ALLOC_DELETE</a>(ptr, T_allocator, T)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gaad47d106cc1abb0dfd1537624a853bb9">OSCL_MALLOC</a>(count)&nbsp;&nbsp;&nbsp;_oscl_malloc(count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga62f4f8f35a828108fafb74763a77e982">oscl_malloc</a>(a)&nbsp;&nbsp;&nbsp;OSCL_MALLOC(a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gaeacd31255b9df354cff629d3be15254e">OSCL_DEFAULT_MALLOC</a>(x)&nbsp;&nbsp;&nbsp;OSCL_MALLOC(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga938ceee8172e01d3a07d912ab890f354">OSCL_AUDIT_MALLOC</a>(auditCB, count)&nbsp;&nbsp;&nbsp;_oscl_malloc(count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gaa31d8d7f56f28a804d0477a8e3b7187d">OSCL_CALLOC</a>(num, size)&nbsp;&nbsp;&nbsp;_oscl_calloc(num,size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga2f18a90c9bd6f42979c24ff4fe9c6af8">oscl_calloc</a>(a, b)&nbsp;&nbsp;&nbsp;OSCL_CALLOC(a,b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gab326396170985b0576e2fbdf6db37e12">OSCL_AUDIT_CALLOC</a>(auditCB, num, size)&nbsp;&nbsp;&nbsp;_oscl_calloc(num,size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga3f7525d7b5b6271c8ed1126f440f7207">OSCL_REALLOC</a>(ptr, new_size)&nbsp;&nbsp;&nbsp;_oscl_realloc(ptr,new_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gabba179de4366364caeced4ff07da4498">oscl_realloc</a>(a, b)&nbsp;&nbsp;&nbsp;OSCL_REALLOC(a,b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gaad322da2c7b8bca314e8d8821693af2d">OSCL_AUDIT_REALLOC</a>(auditCB, ptr, new_size)&nbsp;&nbsp;&nbsp;_oscl_realloc(ptr,new_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gaa894caeca157b3af4322127dabd3517b">OSCL_FREE</a>(ptr)&nbsp;&nbsp;&nbsp;_oscl_free(ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga5111350e6bd7e7271250036d57a74415">oscl_free</a>(x)&nbsp;&nbsp;&nbsp;OSCL_FREE(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga6ce74633d169d36bf72af0a15ab30220">OSCL_DEFAULT_FREE</a>(x)&nbsp;&nbsp;&nbsp;OSCL_FREE(x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gaa6688a3dbf6c7555f8d54bc45445cf89">OSCL_NEW</a>(T, params)&nbsp;&nbsp;&nbsp;new T params</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga4bf8a56280e6377de56a030a453bb447">OSCL_PLACEMENT_NEW</a>(ptr, constructor)&nbsp;&nbsp;&nbsp;new(ptr) constructor</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga7241ae171c8204aaac0e676448ad1a2d">OSCL_TRAP_NEW</a>(T_ptr, T, params)&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(_oscl_default_new(sizeof(T)),_oscl_free,T_ptr,T,params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga3902cc39c0c2b1fbb14e7c766c582baa">OSCL_AUDIT_NEW</a>(auditCB, T, params)&nbsp;&nbsp;&nbsp;new(_oscl_default_new(sizeof(T))) T params</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga0994c7d54254eb8c26345875a36f1199">OSCL_TRAP_AUDIT_NEW</a>(T_ptr, auditCB, T, params)&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(_oscl_default_new(sizeof(T)),_oscl_free,T_ptr,T,params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga1a1abac94dc334b1b865949f6f250b0f">OSCL_DELETE</a>(ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga4d6fdce3b21c895572f55e83036a5218">OSCL_AUDIT_ARRAY_NEW</a>(auditCB, T, count)&nbsp;&nbsp;&nbsp;new(_oscl_default_new(sizeof(T)*(count))) T</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gaad051c81e38be8309c6c55f1c722a8d7">OSCL_ARRAY_NEW</a>(T, count)&nbsp;&nbsp;&nbsp;new T[count]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gadae9885f5ec2c7425e04e2c98cde4569">OSCL_ARRAY_DELETE</a>(ptr)&nbsp;&nbsp;&nbsp;delete [] ptr</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga78e9f1a2eb0b94459e5eabf2567fb411">_OSCL_TRAP_NEW</a>(exp, freeFunc, T_ptr, T, params)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga2e43fc73e266e6625fc0bcf2b567b9ce">_OSCL_CLEANUP_BASE_CLASS</a>(T)&nbsp;&nbsp;&nbsp;this-&gt;T::~T()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga9fcc278d0a7a8d1c95f95c3bd7067994">OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga41c317c81cc0cf56f9a6268a647b1a11">MM_ALLOC_MAX_QUERY_FILENAME_LEN</a>&nbsp;&nbsp;&nbsp;128</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga8ec1573266de990b64234c7696a69930">MM_ALLOC_MAX_QUERY_TAG_LEN</a>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga54a16ec57774bf2c149180fb5a3cec18">MM_AUDIT_VALIDATE_BLOCK</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga441caaaf6c5ac0d6027c4a9a1b2f310f">MM_AUDIT_PREFILL_FLAG</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga420334bb2ce96ace4235292f6cd0c2f7">MM_AUDIT_POSTFILL_FLAG</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga6d3fedc4b1ba7555e3fc1cf639fa77e1">MM_AUDIT_VALIDATE_ALL_HEAP_FLAG</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gac96cf1894ab7f8f462f1810c37b6968f">MM_AUDIT_VALIDATE_ON_FREE_FLAG</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga039081ebef2726cb323a253758383d76">MM_AUDIT_ALLOC_NODE_ENABLE_FLAG</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga5fc5d0440912bd427b639f6826e82251">MM_AUDIT_SUPPRESS_FILENAME_FLAG</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga2030b79099921eaccb563d748ae8fc94">DEFAULT_MM_AUDIT_MODE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga9fcc278d0a7a8d1c95f95c3bd7067994">OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga6d86accdb1569e3f2ec5fad1a1da0813">MM_AUDIT_ALLOC_NODE_SUPPORT</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga98b727807dd99d6c95b89d18e21150e1">MM_AUDIT_FENCE_SUPPORT</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga4f5110c4b2d4aa30332fea0887597e13">MM_AUDIT_INCLUDE_ALL_HEAP_VALIDATION</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga1638931c2a45998d41117c63d98aaaa3">MM_AUDIT_FILL_SUPPORT</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gac413e0f53ebf7604754e70243d7e50aa">MM_AUDIT_FAILURE_SIMULATION_SUPPORT</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga8ecb0ce053d85e9cabb073d977fe8217">FENCE_PATTERN</a>&nbsp;&nbsp;&nbsp;0xAA</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga0d410e6faeceb9aee4bfa7de0a81f846">MIN_FENCE_SIZE</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga0c5dc9a73108accd8c796abc8272861a">MEM_ALIGN_SIZE</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga7a5bfe186fa6607f8e0a655b27756a95">COMPUTE_MEM_ALIGN_SIZE</a>(x, y, z)&nbsp;&nbsp;&nbsp;(y+(((x+y)%z) ? (z - (x+y)%z) : 0))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga8b370fbf428f95f949b00e449a26fe9a">DEFAULT_PREFILL_PATTERN</a>&nbsp;&nbsp;&nbsp;0x96</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga7d6a16209a451acbc39aa26024ef6b7b">DEFAULT_POSTFILL_PATTERN</a>&nbsp;&nbsp;&nbsp;0x5A</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga9fcc278d0a7a8d1c95f95c3bd7067994">OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga52df9cd30fae914a27342a653bc56e37">OSCL_DISABLE_WARNING_RETURN_TYPE_NOT_UDT</a></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt; char, <br class="typebreak"/>
<a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt; char, <br class="typebreak"/>
<a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gaf66c1777f28e18dd3c7f935481cbf453">MMAuditCharAutoPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt; uint8, <br class="typebreak"/>
<a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt; uint8, <br class="typebreak"/>
<a class="el" href="class__OsclBasicAllocator.html">_OsclBasicAllocator</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gaef861d5c7d2bc396e389426e7d5475ff">MMAuditUint8AutoPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a><br class="typebreak"/>
&lt; <a class="el" href="structMM__AllocNode.html">MM_AllocNode</a>, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a><br class="typebreak"/>
&lt; <a class="el" href="structMM__AllocNode.html">MM_AllocNode</a>, <br class="typebreak"/>
<a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga8072c1242865d5bc7f5c10c85bf84198">MM_AllocNodeAutoPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <br class="typebreak"/>
<a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt; <a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <br class="typebreak"/>
<a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gaffc3054a3e8a75823bca68ad5d2694e3">MM_StatsNodeTagTreeType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a><br class="typebreak"/>
&lt; <a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <br class="typebreak"/>
<a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt; <a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <br class="typebreak"/>
<a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gab71b84d6f0d3d4710086b903d7c3fbe9">OsclMemStatsNodeAutoPtr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a><br class="typebreak"/>
&lt; <a class="el" href="classOSCLMemAutoPtr.html">MM_StatsNodeTagTreeType</a>, <br class="typebreak"/>
<a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga42232be54b13e608ad6b0cf7bfa43050">TagTree_Allocator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classOscl__TagTree.html">Oscl_TagTree</a><br class="typebreak"/>
&lt; <a class="el" href="classOSCLMemAutoPtr.html">MM_StatsNodeTagTreeType</a>, <br class="typebreak"/>
<a class="el" href="classOscl__TAlloc.html">TagTree_Allocator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga85218bbcb0f0b13d29e84fce5cf779a9">OsclTagTreeType</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gac26198ea976235d69f4140bcc63246a0">_oscl_malloc</a> (int32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga66341a26dd72dbfa5e35438230e48567">_oscl_calloc</a> (int32 nelems, int32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga53051a2a75c4ffdc9e6b0b6654a63000">_oscl_realloc</a> (void *src, int32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga952e5011acf2fddbf25c0791f54963cb">_oscl_free</a> (void *src)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga606d9161b80b1aaf42fa61bd1544f2f8">oscl_memcpy</a> (void *dest, const void *src, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga39b1fcfe72fe3aa2b1daaec55bc7a531">oscl_memmove</a> (void *dest, const void *src, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gab0db2312b7e14938730e9fae6fa85442">oscl_memmove32</a> (void *dest, const void *src, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga93ce8ea351e601f7d68094199190178b">oscl_memset</a> (void *dest, uint8 val, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga5e8a109274f928d29e771f940faf9908">oscl_memcmp</a> (const void *buf1, const void *buf2, uint32 count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_COND_IMPORT_REF <a class="el" href="group__osclbase.html#ga91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gafc84155a0fe1f007724c2ba84f4ab49e">oscl_mem_aligned_size</a> (<a class="el" href="group__osclbase.html#ga91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gae7baa332d3b04c960012a6f9ee48c529">OsclMemInit</a> (<a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;auditCB)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gadbb314ea54c51f3ba9f9360b372f74a2">_oscl_default_new</a> (size_t nBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga63aa026bc049b4be1d9f37e74c44547b">operator new</a> (size_t aSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gabdecd5532f7e93535072e2767b6d3d02">operator delete</a> (void *aPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga688aaaff7516e3b9c98c9d92087dffab">operator new[]</a> (size_t aSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#gabdce7034b7215d3cbf51b776437f1b04">operator delete[]</a> (void *aPtr)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclmemory.html#ga8fec96057b23accc66a5d60d4ef5d819">MM_AllocBlockHdr::ALLOC_NODE_FLAG</a> = 0x80000000</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ga2e43fc73e266e6625fc0bcf2b567b9ce"></a><!-- doxytag: member="oscl_mem.h::_OSCL_CLEANUP_BASE_CLASS" ref="ga2e43fc73e266e6625fc0bcf2b567b9ce" args="(T)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _OSCL_CLEANUP_BASE_CLASS</td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;this-&gt;T::~T()</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro is used to cleanup the base class in a derived-class constructor just before a leave occurs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T,:</em>&nbsp;</td><td>base class name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga78e9f1a2eb0b94459e5eabf2567fb411"></a><!-- doxytag: member="oscl_mem.h::_OSCL_TRAP_NEW" ref="ga78e9f1a2eb0b94459e5eabf2567fb411" args="(exp, freeFunc, T_ptr, T, params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define _OSCL_TRAP_NEW</td>
          <td>(</td>
          <td class="paramtype">exp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">freeFunc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
    int32 __err;\
    <a class="code" href="group__osclbase.html#ga3bac54662348f5e6c08b97ca97066b89" title="The OsclAny is meant to be used the context of a generic pointer (i.e., no specific...">OsclAny</a>*__ptr=exp;\
    <a class="code" href="group__osclerror.html#gaf93293163f5b1baf3d3bbba81c79b165" title="This macro will be used to set up a try block.">OSCL_TRY</a>(__err,T_ptr=<span class="keyword">new</span>(__ptr) T params;);\
    <span class="keywordflow">if</span>(__err){\
        freeFunc(__ptr);\
        T_ptr=<a class="code" href="group__osclbase.html#ga070d2ce7b6bb7e5c05602aa8c308d0c4" title="The NULL_TERM_CHAR is used to terminate c-style strings.">NULL</a>;\
        <a class="code" href="classOsclError.html#a652293eaffb0691632c7b5e360a8e5f8">OsclError::Leave</a>(__err);\
    }\
}
</pre></div><p>Internal-use macro to catch leaves in constructors. If the constructor leaves, this will free the memory before allowing the leave to propagate to the next level. It is the constructor's responsibility to cleanup any memory in the partially constructed object before leaving. This cleanup may include cleaning up the base class using the OSCL_CLEANUP_BASE_CLASS macro.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exp,:</em>&nbsp;</td><td>expression to allocate memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Tptr:variable</em>&nbsp;</td><td>to hold result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T,:</em>&nbsp;</td><td>type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params,:</em>&nbsp;</td><td>constructor arg list </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freeFunc,:</em>&nbsp;</td><td>delete or free function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a5bfe186fa6607f8e0a655b27756a95"></a><!-- doxytag: member="oscl_mem_audit_internals.h::COMPUTE_MEM_ALIGN_SIZE" ref="ga7a5bfe186fa6607f8e0a655b27756a95" args="(x, y, z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COMPUTE_MEM_ALIGN_SIZE</td>
          <td>(</td>
          <td class="paramtype">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">z&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(y+(((x+y)%z) ? (z - (x+y)%z) : 0))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2030b79099921eaccb563d748ae8fc94"></a><!-- doxytag: member="oscl_mem_audit.h::DEFAULT_MM_AUDIT_MODE" ref="ga2030b79099921eaccb563d748ae8fc94" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_MM_AUDIT_MODE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7d6a16209a451acbc39aa26024ef6b7b"></a><!-- doxytag: member="oscl_mem_audit_internals.h::DEFAULT_POSTFILL_PATTERN" ref="ga7d6a16209a451acbc39aa26024ef6b7b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_POSTFILL_PATTERN&nbsp;&nbsp;&nbsp;0x5A</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8b370fbf428f95f949b00e449a26fe9a"></a><!-- doxytag: member="oscl_mem_audit_internals.h::DEFAULT_PREFILL_PATTERN" ref="ga8b370fbf428f95f949b00e449a26fe9a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_PREFILL_PATTERN&nbsp;&nbsp;&nbsp;0x96</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8ecb0ce053d85e9cabb073d977fe8217"></a><!-- doxytag: member="oscl_mem_audit_internals.h::FENCE_PATTERN" ref="ga8ecb0ce053d85e9cabb073d977fe8217" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FENCE_PATTERN&nbsp;&nbsp;&nbsp;0xAA</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="oscl__mem__audit__internals_8h_source.html#l00106">MM_AllocBlockFence::check_fence()</a>, and <a class="el" href="oscl__mem__audit__internals_8h_source.html#l00101">MM_AllocBlockFence::fill_fence()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c5dc9a73108accd8c796abc8272861a"></a><!-- doxytag: member="oscl_mem_audit_internals.h::MEM_ALIGN_SIZE" ref="ga0c5dc9a73108accd8c796abc8272861a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_ALIGN_SIZE&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0d410e6faeceb9aee4bfa7de0a81f846"></a><!-- doxytag: member="oscl_mem_audit_internals.h::MIN_FENCE_SIZE" ref="ga0d410e6faeceb9aee4bfa7de0a81f846" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN_FENCE_SIZE&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga41c317c81cc0cf56f9a6268a647b1a11"></a><!-- doxytag: member="oscl_mem_audit.h::MM_ALLOC_MAX_QUERY_FILENAME_LEN" ref="ga41c317c81cc0cf56f9a6268a647b1a11" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_ALLOC_MAX_QUERY_FILENAME_LEN&nbsp;&nbsp;&nbsp;128</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8ec1573266de990b64234c7696a69930"></a><!-- doxytag: member="oscl_mem_audit.h::MM_ALLOC_MAX_QUERY_TAG_LEN" ref="ga8ec1573266de990b64234c7696a69930" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_ALLOC_MAX_QUERY_TAG_LEN&nbsp;&nbsp;&nbsp;64</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga039081ebef2726cb323a253758383d76"></a><!-- doxytag: member="oscl_mem_audit.h::MM_AUDIT_ALLOC_NODE_ENABLE_FLAG" ref="ga039081ebef2726cb323a253758383d76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_ALLOC_NODE_ENABLE_FLAG&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6d86accdb1569e3f2ec5fad1a1da0813"></a><!-- doxytag: member="oscl_mem_audit_internals.h::MM_AUDIT_ALLOC_NODE_SUPPORT" ref="ga6d86accdb1569e3f2ec5fad1a1da0813" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_ALLOC_NODE_SUPPORT&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac413e0f53ebf7604754e70243d7e50aa"></a><!-- doxytag: member="oscl_mem_audit_internals.h::MM_AUDIT_FAILURE_SIMULATION_SUPPORT" ref="gac413e0f53ebf7604754e70243d7e50aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_FAILURE_SIMULATION_SUPPORT&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga98b727807dd99d6c95b89d18e21150e1"></a><!-- doxytag: member="oscl_mem_audit_internals.h::MM_AUDIT_FENCE_SUPPORT" ref="ga98b727807dd99d6c95b89d18e21150e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_FENCE_SUPPORT&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1638931c2a45998d41117c63d98aaaa3"></a><!-- doxytag: member="oscl_mem_audit_internals.h::MM_AUDIT_FILL_SUPPORT" ref="ga1638931c2a45998d41117c63d98aaaa3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_FILL_SUPPORT&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4f5110c4b2d4aa30332fea0887597e13"></a><!-- doxytag: member="oscl_mem_audit_internals.h::MM_AUDIT_INCLUDE_ALL_HEAP_VALIDATION" ref="ga4f5110c4b2d4aa30332fea0887597e13" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_INCLUDE_ALL_HEAP_VALIDATION&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga420334bb2ce96ace4235292f6cd0c2f7"></a><!-- doxytag: member="oscl_mem_audit.h::MM_AUDIT_POSTFILL_FLAG" ref="ga420334bb2ce96ace4235292f6cd0c2f7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_POSTFILL_FLAG&nbsp;&nbsp;&nbsp;0x2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga441caaaf6c5ac0d6027c4a9a1b2f310f"></a><!-- doxytag: member="oscl_mem_audit.h::MM_AUDIT_PREFILL_FLAG" ref="ga441caaaf6c5ac0d6027c4a9a1b2f310f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_PREFILL_FLAG&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5fc5d0440912bd427b639f6826e82251"></a><!-- doxytag: member="oscl_mem_audit.h::MM_AUDIT_SUPPRESS_FILENAME_FLAG" ref="ga5fc5d0440912bd427b639f6826e82251" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_SUPPRESS_FILENAME_FLAG&nbsp;&nbsp;&nbsp;0x20</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6d3fedc4b1ba7555e3fc1cf639fa77e1"></a><!-- doxytag: member="oscl_mem_audit.h::MM_AUDIT_VALIDATE_ALL_HEAP_FLAG" ref="ga6d3fedc4b1ba7555e3fc1cf639fa77e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_VALIDATE_ALL_HEAP_FLAG&nbsp;&nbsp;&nbsp;0x4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga54a16ec57774bf2c149180fb5a3cec18"></a><!-- doxytag: member="oscl_mem_audit.h::MM_AUDIT_VALIDATE_BLOCK" ref="ga54a16ec57774bf2c149180fb5a3cec18" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_VALIDATE_BLOCK&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac96cf1894ab7f8f462f1810c37b6968f"></a><!-- doxytag: member="oscl_mem_audit.h::MM_AUDIT_VALIDATE_ON_FREE_FLAG" ref="gac96cf1894ab7f8f462f1810c37b6968f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MM_AUDIT_VALIDATE_ON_FREE_FLAG&nbsp;&nbsp;&nbsp;0x8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabc57a479922c1847e023cc109436c5c7"></a><!-- doxytag: member="oscl_mem.h::OSCL_ALLOC_DELETE" ref="gabc57a479922c1847e023cc109436c5c7" args="(ptr, T_allocator, T)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_ALLOC_DELETE</td>
          <td>(</td>
          <td class="paramtype">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_allocator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
  ptr-&gt;~T();\
  T_allocator.deallocate(ptr);\
  }
</pre></div><p>Deletes the object of type T using the given allocator</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T_allocator</em>&nbsp;</td><td>allocator for objects of type T </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>type of object to delete </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to previously created object</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>none,unless</em>&nbsp;</td><td>thrown by the given allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadf4b04d6c6c95fbeb0fdbe2c70ecb93a"></a><!-- doxytag: member="oscl_mem.h::OSCL_ALLOC_NEW" ref="gadf4b04d6c6c95fbeb0fdbe2c70ecb93a" args="(T_allocator, T, params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_ALLOC_NEW</td>
          <td>(</td>
          <td class="paramtype">T_allocator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;new(T_allocator.allocate(1)) T params</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>******************************************************* Macros for new/delete with a given allocator/deallocator. Creates an object of type T using the given allocator to acquire the memory needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T_allocator</em>&nbsp;</td><td>allocator for objects of type T, must be an Oscl_TAlloc&lt;T, Allocator&gt;, where Allocator is an <a class="el" href="classOscl__DefAlloc.html">Oscl_DefAlloc</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>type of object to create </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>object initialization parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to created object</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>none,unless</em>&nbsp;</td><td>thrown by the given allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadae9885f5ec2c7425e04e2c98cde4569"></a><!-- doxytag: member="oscl_mem.h::OSCL_ARRAY_DELETE" ref="gadae9885f5ec2c7425e04e2c98cde4569" args="(ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_ARRAY_DELETE</td>
          <td>(</td>
          <td class="paramtype">ptr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;delete [] ptr</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Oscl array delete operator..</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to memory block previously allocated with OSCL_ARRAY_NEW</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="gaad051c81e38be8309c6c55f1c722a8d7"></a><!-- doxytag: member="oscl_mem.h::OSCL_ARRAY_NEW" ref="gaad051c81e38be8309c6c55f1c722a8d7" args="(T, count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_ARRAY_NEW</td>
          <td>(</td>
          <td class="paramtype">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">count&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;new T[count]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Oscl array "new" operator. This uses the global memory audit object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>data type for 'new' operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of elements to create</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the newly created object array of type T</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>may</em>&nbsp;</td><td>leave with code = bad alloc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4d6fdce3b21c895572f55e83036a5218"></a><!-- doxytag: member="oscl_mem.h::OSCL_AUDIT_ARRAY_NEW" ref="ga4d6fdce3b21c895572f55e83036a5218" args="(auditCB, T, count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_AUDIT_ARRAY_NEW</td>
          <td>(</td>
          <td class="paramtype">auditCB, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">count&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;new(_oscl_default_new(sizeof(T)*(count))) T</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>******************************************************* Macros for array new/delete with memory management. These only work for simple array types and cannot be used for class types with constructor/destructors.</p>
<p>Note: some compilers do not support placement array new operator, so these macros don't use it. Oscl array "new" operator. This uses the input memory audit object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>auditCB</em>&nbsp;</td><td>input memory management audit object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>data type for 'new' operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of elements to create</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the newly created object array of type T</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>may</em>&nbsp;</td><td>leave with code = bad alloc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab326396170985b0576e2fbdf6db37e12"></a><!-- doxytag: member="oscl_mem.h::OSCL_AUDIT_CALLOC" ref="gab326396170985b0576e2fbdf6db37e12" args="(auditCB, num, size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_AUDIT_CALLOC</td>
          <td>(</td>
          <td class="paramtype">auditCB, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">num, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_oscl_calloc(num,size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a memory block using the specified audit object. The block is initialized to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>auditCB</em>&nbsp;</td><td>input memory management audit object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>number of elements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>number of bytes to allocate for each element</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a void pointer to the allocated space, or NULL if there is insufficient memory available.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>none</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga938ceee8172e01d3a07d912ab890f354"></a><!-- doxytag: member="oscl_mem.h::OSCL_AUDIT_MALLOC" ref="ga938ceee8172e01d3a07d912ab890f354" args="(auditCB, count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_AUDIT_MALLOC</td>
          <td>(</td>
          <td class="paramtype">auditCB, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">count&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_oscl_malloc(count)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a memory block using the given audit object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>auditCB</em>&nbsp;</td><td>input memory management audit object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of bytes to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a void pointer to the allocated space, or NULL if there is insufficient memory available.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>none</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3902cc39c0c2b1fbb14e7c766c582baa"></a><!-- doxytag: member="oscl_mem.h::OSCL_AUDIT_NEW" ref="ga3902cc39c0c2b1fbb14e7c766c582baa" args="(auditCB, T, params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_AUDIT_NEW</td>
          <td>(</td>
          <td class="paramtype">auditCB, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;new(_oscl_default_new(sizeof(T))) T params</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Oscl "new" operator. This uses the specified memory audit object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>auditCB</em>&nbsp;</td><td>input memory management audit object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>data type for 'new' operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>object initialization parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the newly created object of type T</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>may</em>&nbsp;</td><td>leave with code = bad alloc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaad322da2c7b8bca314e8d8821693af2d"></a><!-- doxytag: member="oscl_mem.h::OSCL_AUDIT_REALLOC" ref="gaad322da2c7b8bca314e8d8821693af2d" args="(auditCB, ptr, new_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_AUDIT_REALLOC</td>
          <td>(</td>
          <td class="paramtype">auditCB, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">new_size&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_oscl_realloc(ptr,new_size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Re-Allocates a memory block using the specified audit object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>auditCB</em>&nbsp;</td><td>input memory management audit object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>original memory block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_size</em>&nbsp;</td><td>New size of the block</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a void pointer to the allocated space, or NULL if there is insufficient memory available.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>none</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f18a90c9bd6f42979c24ff4fe9c6af8"></a><!-- doxytag: member="oscl_mem.h::oscl_calloc" ref="ga2f18a90c9bd6f42979c24ff4fe9c6af8" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oscl_calloc</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;OSCL_CALLOC(a,b)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa31d8d7f56f28a804d0477a8e3b7187d"></a><!-- doxytag: member="oscl_mem.h::OSCL_CALLOC" ref="gaa31d8d7f56f28a804d0477a8e3b7187d" args="(num, size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_CALLOC</td>
          <td>(</td>
          <td class="paramtype">num, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_oscl_calloc(num,size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a memory block using the memory management's global audit object. The block is initialized to zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td>number of elements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>number of bytes to allocate for each element</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a void pointer to the allocated space, or NULL if there is insufficient memory available.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>none</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae92c2c0f2f9ac61cc741efc88c67264d"></a><!-- doxytag: member="oscl_mem.h::OSCL_CLEANUP_BASE_CLASS" ref="gae92c2c0f2f9ac61cc741efc88c67264d" args="(T)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_CLEANUP_BASE_CLASS</td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_OSCL_CLEANUP_BASE_CLASS(T)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cleans up the base class of a partially-constructed derived class. This macro will call the destructor if necessary, based on the error-handling implementation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T,:</em>&nbsp;</td><td>name of the base class. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6ce74633d169d36bf72af0a15ab30220"></a><!-- doxytag: member="oscl_mem.h::OSCL_DEFAULT_FREE" ref="ga6ce74633d169d36bf72af0a15ab30220" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DEFAULT_FREE</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;OSCL_FREE(x)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Another back-compatibility definition. </p>

</div>
</div>
<a class="anchor" id="gaeacd31255b9df354cff629d3be15254e"></a><!-- doxytag: member="oscl_mem.h::OSCL_DEFAULT_MALLOC" ref="gaeacd31255b9df354cff629d3be15254e" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DEFAULT_MALLOC</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;OSCL_MALLOC(x)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Another back-compatibility definition. </p>

</div>
</div>
<a class="anchor" id="ga1a1abac94dc334b1b865949f6f250b0f"></a><!-- doxytag: member="oscl_mem.h::OSCL_DELETE" ref="ga1a1abac94dc334b1b865949f6f250b0f" args="(ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DELETE</td>
          <td>(</td>
          <td class="paramtype">ptr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{\
    <span class="keywordflow">if</span>(ptr){<span class="keyword">delete</span>(ptr);}\
}
</pre></div><p>Oscl "delete" operator.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to memory block previously allocated with OSCL_NEW</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

<p>Referenced by <a class="el" href="oscl__file__async__read_8h_source.html#l00150">OsclBuf::Delete()</a>, <a class="el" href="oscl__file__async__read_8h_source.html#l00138">OsclBuf::NewL()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00348">MM_AllocNode::~MM_AllocNode()</a>, and <a class="el" href="oscl__mem__audit_8h_source.html#l00197">OsclMemStatsNode::~OsclMemStatsNode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga52df9cd30fae914a27342a653bc56e37"></a><!-- doxytag: member="oscl_mem_auto_ptr.h::OSCL_DISABLE_WARNING_RETURN_TYPE_NOT_UDT" ref="ga52df9cd30fae914a27342a653bc56e37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_RETURN_TYPE_NOT_UDT</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fcc278d0a7a8d1c95f95c3bd7067994"></a><!-- doxytag: member="oscl_mem_auto_ptr.h::OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE" ref="ga9fcc278d0a7a8d1c95f95c3bd7067994" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fcc278d0a7a8d1c95f95c3bd7067994"></a><!-- doxytag: member="oscl_mem_audit_internals.h::OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE" ref="ga9fcc278d0a7a8d1c95f95c3bd7067994" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fcc278d0a7a8d1c95f95c3bd7067994"></a><!-- doxytag: member="oscl_mem_audit.h::OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE" ref="ga9fcc278d0a7a8d1c95f95c3bd7067994" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fcc278d0a7a8d1c95f95c3bd7067994"></a><!-- doxytag: member="oscl_mem.h::OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE" ref="ga9fcc278d0a7a8d1c95f95c3bd7067994" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Previously this was in oscl_mem_imp.h </p>

</div>
</div>
<a class="anchor" id="ga9fcc278d0a7a8d1c95f95c3bd7067994"></a><!-- doxytag: member="oscl_mem.h::OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE" ref="ga9fcc278d0a7a8d1c95f95c3bd7067994" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Previously this was in oscl_mem_imp.h </p>

</div>
</div>
<a class="anchor" id="ga5111350e6bd7e7271250036d57a74415"></a><!-- doxytag: member="oscl_mem.h::oscl_free" ref="ga5111350e6bd7e7271250036d57a74415" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oscl_free</td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;OSCL_FREE(x)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa894caeca157b3af4322127dabd3517b"></a><!-- doxytag: member="oscl_mem.h::OSCL_FREE" ref="gaa894caeca157b3af4322127dabd3517b" args="(ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_FREE</td>
          <td>(</td>
          <td class="paramtype">ptr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_oscl_free(ptr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deallocates or frees a memory block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>pointer to previously allocated memory block using the given audit object </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="oscl__mem_8h_source.html#l00759">OsclMemAllocator::deallocate()</a>, and <a class="el" href="oscl__file__async__read_8h_source.html#l00150">OsclBuf::Delete()</a>.</p>

</div>
</div>
<a class="anchor" id="ga62f4f8f35a828108fafb74763a77e982"></a><!-- doxytag: member="oscl_mem.h::oscl_malloc" ref="ga62f4f8f35a828108fafb74763a77e982" args="(a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oscl_malloc</td>
          <td>(</td>
          <td class="paramtype">a&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;OSCL_MALLOC(a)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaad47d106cc1abb0dfd1537624a853bb9"></a><!-- doxytag: member="oscl_mem.h::OSCL_MALLOC" ref="gaad47d106cc1abb0dfd1537624a853bb9" args="(count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_MALLOC</td>
          <td>(</td>
          <td class="paramtype">count&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_oscl_malloc(count)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocates a memory block using the memory management's global audit object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of bytes to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a void pointer to the allocated space, or NULL if there is insufficient memory available.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>none</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="oscl__file__async__read_8h_source.html#l00138">OsclBuf::NewL()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa6688a3dbf6c7555f8d54bc45445cf89"></a><!-- doxytag: member="oscl_mem.h::OSCL_NEW" ref="gaa6688a3dbf6c7555f8d54bc45445cf89" args="(T, params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_NEW</td>
          <td>(</td>
          <td class="paramtype">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;new T params</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>******************************************************* Macros for new/delete with memory management. Oscl "new" operator. This uses the global memory audit object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>data type for 'new' operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>object initialization parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the newly created object of type T</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>may</em>&nbsp;</td><td>leave with code = bad alloc </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="oscl__file__async__read_8h_source.html#l00138">OsclBuf::NewL()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4bf8a56280e6377de56a030a453bb447"></a><!-- doxytag: member="oscl_mem.h::OSCL_PLACEMENT_NEW" ref="ga4bf8a56280e6377de56a030a453bb447" args="(ptr, constructor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_PLACEMENT_NEW</td>
          <td>(</td>
          <td class="paramtype">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">constructor&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;new(ptr) constructor</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="oscl__timer_8h_source.html#l00194">OsclTimer&lt; Alloc &gt;::OsclTimer()</a>.</p>

</div>
</div>
<a class="anchor" id="gabba179de4366364caeced4ff07da4498"></a><!-- doxytag: member="oscl_mem.h::oscl_realloc" ref="gabba179de4366364caeced4ff07da4498" args="(a, b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define oscl_realloc</td>
          <td>(</td>
          <td class="paramtype">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">b&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;OSCL_REALLOC(a,b)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3f7525d7b5b6271c8ed1126f440f7207"></a><!-- doxytag: member="oscl_mem.h::OSCL_REALLOC" ref="ga3f7525d7b5b6271c8ed1126f440f7207" args="(ptr, new_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_REALLOC</td>
          <td>(</td>
          <td class="paramtype">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">new_size&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_oscl_realloc(ptr,new_size)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Re-Allocates a memory block using the memory management's global audit object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ptr</em>&nbsp;</td><td>original memory block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_size</em>&nbsp;</td><td>New size of the block</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a void pointer to the allocated space, or NULL if there is insufficient memory available.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>none</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga86a28832146864af539f81cac7aabc98"></a><!-- doxytag: member="oscl_mem.h::OSCL_TRAP_ALLOC_NEW" ref="ga86a28832146864af539f81cac7aabc98" args="(T_ptr, T_allocator, T, params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_TRAP_ALLOC_NEW</td>
          <td>(</td>
          <td class="paramtype">T_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T_allocator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(T_allocator.allocate(1),T_allocator.deallocate,T_ptr,T,params)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates an object of type T using the given allocator to acquire the memory needed. This macro is similar to OSCL_ALLOC_NEW except that it handles constructors that leave. If the constructor leaves, the destructor will be called, and allocated memory will be freed before allowing the leave to propagate to the next level.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T_ptr</em>&nbsp;</td><td>variable to hold return value-- pointer to new object of type T. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T_allocator</em>&nbsp;</td><td>allocator for objects of type T, must be an Oscl_TAlloc&lt;T, Allocator&gt;, where Allocator is an <a class="el" href="classOscl__DefAlloc.html">Oscl_DefAlloc</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>type of object to create </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>object initialization parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to created object</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>none,unless</em>&nbsp;</td><td>thrown by the given allocator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0994c7d54254eb8c26345875a36f1199"></a><!-- doxytag: member="oscl_mem.h::OSCL_TRAP_AUDIT_NEW" ref="ga0994c7d54254eb8c26345875a36f1199" args="(T_ptr, auditCB, T, params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_TRAP_AUDIT_NEW</td>
          <td>(</td>
          <td class="paramtype">T_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">auditCB, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(_oscl_default_new(sizeof(T)),_oscl_free,T_ptr,T,params)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Oscl "new" operator. This uses the specified memory audit object. This macro is similar to OSCL_AUDIT_NEW except that it will handle constructors that leave. If the constructor leaves, the destructor will be called, and allocated memory will be freed before allowing the leave to propagate to the next level.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T_ptr</em>&nbsp;</td><td>variable to hold return value-- pointer to new object of type T. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auditCB</em>&nbsp;</td><td>input memory management audit object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>data type for 'new' operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>object initialization parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the newly created object of type T</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>may</em>&nbsp;</td><td>leave with code = bad alloc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7241ae171c8204aaac0e676448ad1a2d"></a><!-- doxytag: member="oscl_mem.h::OSCL_TRAP_NEW" ref="ga7241ae171c8204aaac0e676448ad1a2d" args="(T_ptr, T, params)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_TRAP_NEW</td>
          <td>(</td>
          <td class="paramtype">T_ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">params&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(_oscl_default_new(sizeof(T)),_oscl_free,T_ptr,T,params)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Oscl "new" operator. This uses the global memory audit object. This operator is similar to OSCL_NEW except that it will handle constructors that leave. If the constructor leaves, the destructor will be called, and allocated memory will be freed before allowing the leave to propagate to the next level.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>T_ptr</em>&nbsp;</td><td>variable to hold return value-- pointer to new object of type T. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>T</em>&nbsp;</td><td>data type for 'new' operation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>params</em>&nbsp;</td><td>object initialization parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the newly created object of type T</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>may</em>&nbsp;</td><td>leave with code = bad alloc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga8072c1242865d5bc7f5c10c85bf84198"></a><!-- doxytag: member="oscl_mem_audit.h::MM_AllocNodeAutoPtr" ref="ga8072c1242865d5bc7f5c10c85bf84198" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt;<a class="el" href="structMM__AllocNode.html">MM_AllocNode</a>, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;<a class="el" href="structMM__AllocNode.html">MM_AllocNode</a>, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a>&gt; &gt; <a class="el" href="classOSCLMemAutoPtr.html">MM_AllocNodeAutoPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaffc3054a3e8a75823bca68ad5d2694e3"></a><!-- doxytag: member="oscl_mem_audit.h::MM_StatsNodeTagTreeType" ref="gaffc3054a3e8a75823bca68ad5d2694e3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt;<a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;<a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a>&gt; &gt; <a class="el" href="classOSCLMemAutoPtr.html">MM_StatsNodeTagTreeType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf66c1777f28e18dd3c7f935481cbf453"></a><!-- doxytag: member="oscl_mem_audit.h::MMAuditCharAutoPtr" ref="gaf66c1777f28e18dd3c7f935481cbf453" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt;char, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;char, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a>&gt; &gt; <a class="el" href="classOSCLMemAutoPtr.html">MMAuditCharAutoPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaef861d5c7d2bc396e389426e7d5475ff"></a><!-- doxytag: member="oscl_mem_audit.h::MMAuditUint8AutoPtr" ref="gaef861d5c7d2bc396e389426e7d5475ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt;uint8, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;uint8, <a class="el" href="class__OsclBasicAllocator.html">_OsclBasicAllocator</a>&gt; &gt; <a class="el" href="classOSCLMemAutoPtr.html">MMAuditUint8AutoPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab71b84d6f0d3d4710086b903d7c3fbe9"></a><!-- doxytag: member="oscl_mem_audit.h::OsclMemStatsNodeAutoPtr" ref="gab71b84d6f0d3d4710086b903d7c3fbe9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt;<a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;<a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a>&gt; &gt; <a class="el" href="classOSCLMemAutoPtr.html">OsclMemStatsNodeAutoPtr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga85218bbcb0f0b13d29e84fce5cf779a9"></a><!-- doxytag: member="oscl_mem_audit.h::OsclTagTreeType" ref="ga85218bbcb0f0b13d29e84fce5cf779a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOscl__TagTree.html">Oscl_TagTree</a>&lt;<a class="el" href="classOSCLMemAutoPtr.html">MM_StatsNodeTagTreeType</a>, <a class="el" href="classOscl__TAlloc.html">TagTree_Allocator</a>&gt; <a class="el" href="classOscl__TagTree.html">OsclTagTreeType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga42232be54b13e608ad6b0cf7bfa43050"></a><!-- doxytag: member="oscl_mem_audit.h::TagTree_Allocator" ref="ga42232be54b13e608ad6b0cf7bfa43050" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;<a class="el" href="classOSCLMemAutoPtr.html">MM_StatsNodeTagTreeType</a>, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a>&gt; <a class="el" href="classOscl__TAlloc.html">TagTree_Allocator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga66341a26dd72dbfa5e35438230e48567"></a><!-- doxytag: member="oscl_mem_basic_functions.h::_oscl_calloc" ref="ga66341a26dd72dbfa5e35438230e48567" args="(int32 nelems, int32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF void* _oscl_calloc </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>nelems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadbb314ea54c51f3ba9f9360b372f74a2"></a><!-- doxytag: member="oscl_mem.h::_oscl_default_new" ref="gadbb314ea54c51f3ba9f9360b372f74a2" args="(size_t nBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void* _oscl_default_new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nBytes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>******************************************************* Macros for malloc/free with memory management. </p>

<p>Referenced by <a class="el" href="oscl__mem_8h_source.html#l00926">HeapBase::operator new()</a>, <a class="el" href="oscl__mem_8h_source.html#l00263">operator new()</a>, <a class="el" href="oscl__mem_8h_source.html#l00932">HeapBase::operator new[]()</a>, and <a class="el" href="oscl__mem_8h_source.html#l00297">operator new[]()</a>.</p>

</div>
</div>
<a class="anchor" id="ga952e5011acf2fddbf25c0791f54963cb"></a><!-- doxytag: member="oscl_mem_basic_functions.h::_oscl_free" ref="ga952e5011acf2fddbf25c0791f54963cb" args="(void *src)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF void _oscl_free </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>src</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="oscl__mem_8h_source.html#l00793">OsclMemBasicAllocator::deallocate()</a>, <a class="el" href="oscl__mem_8h_source.html#l00962">HeapBase::operator delete()</a>, <a class="el" href="oscl__mem_8h_source.html#l00276">operator delete()</a>, <a class="el" href="oscl__mem_8h_source.html#l00971">HeapBase::operator delete[]()</a>, and <a class="el" href="oscl__mem_8h_source.html#l00310">operator delete[]()</a>.</p>

</div>
</div>
<a class="anchor" id="gac26198ea976235d69f4140bcc63246a0"></a><!-- doxytag: member="oscl_mem_basic_functions.h::_oscl_malloc" ref="gac26198ea976235d69f4140bcc63246a0" args="(int32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF void* _oscl_malloc </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>count</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="oscl__mem_8h_source.html#l00783">OsclMemBasicAllocator::allocate()</a>, and <a class="el" href="oscl__mem_8h_source.html#l00727">OsclMemAllocator::allocate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga53051a2a75c4ffdc9e6b0b6654a63000"></a><!-- doxytag: member="oscl_mem_basic_functions.h::_oscl_realloc" ref="ga53051a2a75c4ffdc9e6b0b6654a63000" args="(void *src, int32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF void* _oscl_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabdecd5532f7e93535072e2767b6d3d02"></a><!-- doxytag: member="oscl_mem.h::operator delete" ref="gabdecd5532f7e93535072e2767b6d3d02" args="(void *aPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__osclmemory.html#ga952e5011acf2fddbf25c0791f54963cb">_oscl_free()</a>.</p>

</div>
</div>
<a class="anchor" id="gabdce7034b7215d3cbf51b776437f1b04"></a><!-- doxytag: member="oscl_mem.h::operator delete[]" ref="gabdce7034b7215d3cbf51b776437f1b04" args="(void *aPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operator delete[] </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aPtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__osclmemory.html#ga952e5011acf2fddbf25c0791f54963cb">_oscl_free()</a>.</p>

</div>
</div>
<a class="anchor" id="ga63aa026bc049b4be1d9f37e74c44547b"></a><!-- doxytag: member="oscl_mem.h::operator new" ref="ga63aa026bc049b4be1d9f37e74c44547b" args="(size_t aSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>aSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__osclmemory.html#gadbb314ea54c51f3ba9f9360b372f74a2">_oscl_default_new()</a>.</p>

</div>
</div>
<a class="anchor" id="ga688aaaff7516e3b9c98c9d92087dffab"></a><!-- doxytag: member="oscl_mem.h::operator new[]" ref="ga688aaaff7516e3b9c98c9d92087dffab" args="(size_t aSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operator new[] </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>aSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>References <a class="el" href="group__osclmemory.html#gadbb314ea54c51f3ba9f9360b372f74a2">_oscl_default_new()</a>.</p>

</div>
</div>
<a class="anchor" id="gafc84155a0fe1f007724c2ba84f4ab49e"></a><!-- doxytag: member="oscl_mem.h::oscl_mem_aligned_size" ref="gafc84155a0fe1f007724c2ba84f4ab49e" args="(uint size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF <a class="el" href="group__osclbase.html#ga91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> oscl_mem_aligned_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#ga91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get memory-aligned size of an object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of object</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>memory-aligned size </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e8a109274f928d29e771f940faf9908"></a><!-- doxytag: member="oscl_mem_basic_functions.h::oscl_memcmp" ref="ga5e8a109274f928d29e771f940faf9908" args="(const void *buf1, const void *buf2, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF int oscl_memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buf2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare characters in two buffers</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf1</em>&nbsp;</td><td>first buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf2</em>&nbsp;</td><td>second buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of bytes to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 buf1 less than buf2 0 buf1 equal to buf2 &gt;0 buf1 greater than buf2 </dd></dl>

</div>
</div>
<a class="anchor" id="ga606d9161b80b1aaf42fa61bd1544f2f8"></a><!-- doxytag: member="oscl_mem_basic_functions.h::oscl_memcpy" ref="ga606d9161b80b1aaf42fa61bd1544f2f8" args="(void *dest, const void *src, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF void* oscl_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copies characters between buffers The oscl_memcpy function copies count bytes of src to dest. If the source and destination overlap, this function does not ensure that the original source bytes in the overlapping region are copied before being overwritten. Use oscl_memmove to handle overlapping regions</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>new buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>buffer to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value of dest </dd></dl>

<p>Referenced by <a class="el" href="oscl__media__data_8h_source.html#l00377">MediaData&lt; ChainClass, max_frags, local_bufsize &gt;::AddLocalFragment()</a>, <a class="el" href="oscl__uuid_8h_source.html#l00056">OsclUuid::operator=()</a>, and <a class="el" href="oscl__uuid_8h_source.html#l00051">OsclUuid::OsclUuid()</a>.</p>

</div>
</div>
<a class="anchor" id="ga39b1fcfe72fe3aa2b1daaec55bc7a531"></a><!-- doxytag: member="oscl_mem_basic_functions.h::oscl_memmove" ref="ga39b1fcfe72fe3aa2b1daaec55bc7a531" args="(void *dest, const void *src, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF void* oscl_memmove </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Moves chars from one buffer to another The memmove function copies count bytes of characters from src to dest. If some regions of the source area and the destination overlap, memmove ensures that the original source bytes in the overlapping region are copied before being overwritten.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>new buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>buffer to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value of dest </dd></dl>

<p>Referenced by <a class="el" href="oscl__media__data_8h_source.html#l00196">BufFragGroup&lt; ChainClass, max_frags &gt;::AddFragment()</a>, <a class="el" href="oscl__media__data_8h_source.html#l00377">MediaData&lt; ChainClass, max_frags, local_bufsize &gt;::AddLocalFragment()</a>, and <a class="el" href="oscl__file__async__read_8h_source.html#l00122">OsclPtr::Append()</a>.</p>

</div>
</div>
<a class="anchor" id="gab0db2312b7e14938730e9fae6fa85442"></a><!-- doxytag: member="oscl_mem_basic_functions.h::oscl_memmove32" ref="gab0db2312b7e14938730e9fae6fa85442" args="(void *dest, const void *src, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF void* oscl_memmove32 </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Same functionality as oscl_memmove, yet optimized for memory alligned on 32-bit boundary</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>new buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>buffer to copy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of bytes to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value of dest </dd></dl>

</div>
</div>
<a class="anchor" id="ga93ce8ea351e601f7d68094199190178b"></a><!-- doxytag: member="oscl_mem_basic_functions.h::oscl_memset" ref="ga93ce8ea351e601f7d68094199190178b" args="(void *dest, uint8 val, uint32 count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_COND_IMPORT_REF void* oscl_memset </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the bytes of a buffer to a specified character</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dest</em>&nbsp;</td><td>buffer to modify </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>character to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>number of bytes to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the value of dest </dd></dl>

<p>Referenced by <a class="el" href="oscl__mem_8h_source.html#l00783">OsclMemBasicAllocator::allocate()</a>, <a class="el" href="oscl__mem_8h_source.html#l00727">OsclMemAllocator::allocate()</a>, <a class="el" href="oscl__media__data_8h_source.html#l00138">BufFragGroup&lt; ChainClass, max_frags &gt;::BufFragGroup()</a>, <a class="el" href="oscl__media__data_8h_source.html#l00314">MediaData&lt; ChainClass, max_frags, local_bufsize &gt;::Clear()</a>, <a class="el" href="oscl__media__data_8h_source.html#l00182">BufFragGroup&lt; ChainClass, max_frags &gt;::Clear()</a>, <a class="el" href="oscl__mem__audit__internals_8h_source.html#l00101">MM_AllocBlockFence::fill_fence()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00296">MM_AllocInfo::MM_AllocInfo()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00343">MM_AllocNode::MM_AllocNode()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00135">MM_FailInsertParam::MM_FailInsertParam()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00239">MM_Stats_CB::MM_Stats_CB()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00056">MM_Stats_t::MM_Stats_t()</a>, <a class="el" href="oscl__uuid_8h_source.html#l00030">OsclUuid::OsclUuid()</a>, <a class="el" href="oscl__mem__audit_8h_source.html#l00140">MM_FailInsertParam::reset()</a>, and <a class="el" href="oscl__mem__audit_8h_source.html#l00069">MM_Stats_t::reset()</a>.</p>

</div>
</div>
<a class="anchor" id="gae7baa332d3b04c960012a6f9ee48c529"></a><!-- doxytag: member="oscl_mem.h::OsclMemInit" ref="gae7baa332d3b04c960012a6f9ee48c529" args="(OsclAuditCB &amp;auditCB)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclMemInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>auditCB</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize an <a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> object. Sets the stats node pointer to null, and sets the audit pointer to the global audit object.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>auditCB</em>&nbsp;</td><td>memory management audit object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga8fec96057b23accc66a5d60d4ef5d819"></a><!-- doxytag: member="MM_AllocBlockHdr::ALLOC_NODE_FLAG" ref="ga8fec96057b23accc66a5d60d4ef5d819" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint32 <a class="el" href="group__osclmemory.html#ga8fec96057b23accc66a5d60d4ef5d819">MM_AllocBlockHdr::ALLOC_NODE_FLAG</a> = 0x80000000<code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Referenced by <a class="el" href="oscl__mem__audit__internals_8h_source.html#l00074">MM_AllocBlockHdr::isAllocNodePtr()</a>, and <a class="el" href="oscl__mem__audit__internals_8h_source.html#l00078">MM_AllocBlockHdr::setAllocNodeFlag()</a>.</p>

</div>
</div>
</div>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: CORE_9.005.1.1 </small>
</small></address>
</body>
</html>
