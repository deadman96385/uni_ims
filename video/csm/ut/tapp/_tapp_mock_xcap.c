/*
 * THIS IS AN UNPUBLISHED WORK CONTAINING D2 TECHNOLOGIES, INC. CONFIDENTIAL
 * AND PROPRIETARY INFORMATION.  IF PUBLICATION OCCURS, THE FOLLOWING NOTICE
 * APPLIES: "COPYRIGHT 2004 D2 TECHNOLOGIES, INC. ALL RIGHTS RESERVED"
 *
 * $D2Tech$ $Rev$ $Date$
 *
 */

#include <osal.h>
#include <xcap.h>
#include <xcap_resources.h>
#include <isi.h>
#include <isip.h>
#include <csm_event.h>
#include "_tapp.h"
#include "_tapp_mock_xcap.h"

extern TAPP_GlobalObj *global_ptr;

/* 
 * ======== XCAP_allocate() ========
 * This function is Mock XCAP initial.
 * This function will call the mock xcap initial function
 * The mock inside TAPP will do the looper simulating xcap task
 * 
 * Return Values:
 *   1: initialize successfully.
 *   0: initialize fialed.
 */
int XCAP_allocate(
    XCAP_Obj *obj_ptr,
    int       timeoutsec)
{
    obj_ptr->exit = 0;
    obj_ptr->timeoutsec = timeoutsec;
    if (TAPP_PASS != TAPP_mockXcapInit(global_ptr, obj_ptr)) {
        return(0);
    }
    return (1);
}

/*
 * ======== XCAP_start() ========
 *
 * Public routine for starting the XCAP module tasks/actions
 * The mock inside TAPP will do the looper simulating xcap task
 *
 * Returns:
 *      OSAL_SUCCESS: function exits normally.
 *      OSAL_FAIL: in case of error
 */
vint XCAP_start(
     XCAP_Obj *obj_ptr)
{
    return (1);
}

/* 
 * ======== XCAP_destroy() ========
 * This function must be called last before exitting an application to free
 * resources. This will free up TAPP XCAP mock resource
 * @param obj_ptr XCAP object initialized by #XCAP_init
 * @return 0: failed, 1: passed
 */
int XCAP_destroy(
     XCAP_Obj *obj_ptr)
{
    if (TAPP_PASS != TAPP_mockXcapShutdown(global_ptr, obj_ptr)) {
        return(-1);
    }
    return (0);
}
/* 
 * ======== XCAP_sendCmd() ========
 * This function is called to send a command to the XCAP mock task (in TAPP).
 * Each command simulate an XCAP transaction with a server.
 * Usually this will be verified by TAPP validate_xcap sequence
 *
 * @param obj_ptr XCAP object initialized by #XCAP_init
 * @param cmd_ptr A pointer to an XCAP_Cmd structure populated as,\n
 * XCAP_Cmd.op: operation\n
 * XCAP_Cmd.opType: type of operation\n
 * XCAP_Cmd.cond: condition (must also set etag_ptr to an ETag) - optional\n
 * XCAP_Cmd.uri_ptr: pointer to the HTTP URI, use function #XCAP_helperMakeUri\n
 * XCAP_Cmd.auid_ptr: pointer to the AUID, must match AUID in uri_ptr\n
 * XCAP_Cmd.etag_ptr: pointer to ETag if XCAP_Cmd.cond is set\n
 * XCAP_Cmd.src_ptr: pointer to document buffer - required for
 *  #XCAP_OPERATION_CREATE_REPLACE, optional for other ops\n
 * XCAP_Cmd.srcSz: size of the document pointed by XCAP_Cmd.src_ptr
 * @return 0: failed, 1: passed
 */
int XCAP_sendCmd(
     XCAP_Obj *obj_ptr,
     XCAP_Cmd *cmd_ptr)
{
    if (NULL == obj_ptr) {
        return (0);
    }
    if (NULL == cmd_ptr) {
        return (0);
    }

    if (OSAL_SUCCESS == OSAL_msgQSend(obj_ptr->cmdq,
            (char *)cmd_ptr,
            sizeof(XCAP_Cmd),
            OSAL_WAIT_FOREVER,
            NULL)) {
        TAPP_dbgPrintf("%s:%d", __FILE__, __LINE__);
        return (1);
    }
    TAPP_dbgPrintf("%s:%d", __FILE__, __LINE__);
    return (0);
}

/* 
 * ======== XCAP_getEvt() ========
 *
 * This function is called to get an event from an XCAP mock task.
 * Each command sent by function #XCAP_sendCmd starts an XCAP transaction
 * with a server, which generates exactly one event.
 * Usually this event is generated by TAPP issue_xcap sequence
 *
 * Application reads from event then disposes the event using call to
 * function #XCAP_disposeEvt.
 * @param obj_ptr XCAP object initialized by #XCAP_init
 * @param evt_ptr Location where event will be written on return
 * @param msTimeout Wait for the event in millieconds, -1 forever
 * @return 0: failed, 1: passed
 */
int XCAP_getEvt(
     XCAP_Obj *obj_ptr,
     XCAP_Evt *evt_ptr,
     int       msTimeout)
{
    if (NULL == obj_ptr) {
        return (0);
    }
    if (NULL == evt_ptr) {
        return (0);
    }

    evt_ptr->hdr_ptr = NULL;
    evt_ptr->body_ptr = NULL;
    evt_ptr->error = XCAP_EVT_ERR_LAST;
    if (sizeof(XCAP_Evt) != OSAL_msgQRecv(obj_ptr->evtq,
            (char *)evt_ptr,
            sizeof(XCAP_Evt),
            msTimeout < 0 ? OSAL_WAIT_FOREVER : msTimeout,
            NULL)) {
        return (0);
    }
    TAPP_dbgPrintf("%s:%d", __FILE__, __LINE__);
    return (1);
}

/* 
 * ======== XCAP_disposeEvt() ========
 *
 * Dispose an event we got from function call #XCAP_getEvt.
 * Note: dispose event only if function returns success and,
 * XCAP_Evt.error == #XCAP_EVT_ERR_NONE.
 * @param evt_ptr As passed in #XCAP_getEvt call.
 * @return 0: failed, 1: passed
 */
int XCAP_disposeEvt(
     XCAP_Evt *evt_ptr)
{
    if (NULL == evt_ptr) {
        return (0);
    }

    // we used the action buffer, no need to free in tapp mock xcap event
    
    TAPP_dbgPrintf("%s:%d", __FILE__, __LINE__);
    return (1);
}


/* mock implementation */

/*
 * ======== TAPP_mockXcapInit() ========
 *
 * This function is used to initialize and configure Mock Xcap.
 * 
 * 
 * Return Values:
 *   TAPP_PASS: initialize successfully.
 *   TAPP_FAIL: initialize fialed.
 */
vint TAPP_mockXcapInit(
    TAPP_GlobalObj *global_ptr,
    XCAP_Obj *obj_ptr)
{
    if (NULL == global_ptr) {
        return (TAPP_FAIL);
    }

    /*
     * Create command queue
     */
    obj_ptr->cmdq = OSAL_msgQCreate(XCAP_CMD_Q_NAME,
            OSAL_MODULE_TAPP, OSAL_MODULE_TAPP, OSAL_DATA_STRUCT_XCAP_Cmd,
            4, /* _XCAP_TASK_CMD_Q_LEN in private _xcap_task.h */
            sizeof(XCAP_Cmd),
            0);
    if (NULL == obj_ptr->cmdq) {
        return (-1);
    }
    global_ptr->queue.xcapCmd = obj_ptr->cmdq;

    /*
     * Create event queue
     */
    obj_ptr->evtq = OSAL_msgQCreate(XCAP_EVT_Q_NAME,
            OSAL_MODULE_TAPP, OSAL_MODULE_TAPP, OSAL_DATA_STRUCT_XCAP_Evt,
            4, /* _XCAP_TASK_EVT_Q_LEN in private _xcap_task.h */
            sizeof(XCAP_Evt),
            0);
    if (NULL == obj_ptr->evtq) {
        OSAL_msgQDelete(obj_ptr->cmdq);
        global_ptr->queue.xcapCmd = NULL;
        return (-1);
    }
    global_ptr->queue.xcapEvt = obj_ptr->evtq;
    
    return (TAPP_PASS);
}

/*
 * ======== TAPP_mockXcapShutdown() ========
 *
 * This function is used to shutdown Mock Xcap.
 * 
 * Return Values:
 *   TAPP_PASS: shutdown sucessfully.
 *   TAPP_FAIL: shutdown failed
 */
vint TAPP_mockXcapShutdown(
    TAPP_GlobalObj *global_ptr,
    XCAP_Obj *obj_ptr) 
{
    vint resultok;
    
    if (NULL == global_ptr) {
        return (TAPP_FAIL);
    }
    /* Tell TAPP that we are going down */
    if (NULL == obj_ptr) {
        return (0);
    }
    
    /* XXX: handle shutdown in TAPP */
//     XCAP_Cmd cmd;
//     obj_ptr->exit = 1;
//     XCAP_sendCmd(obj_ptr, &cmd);
    /* tapp main should do this check */
//     if (obj_ptr->exit) {
//         goto _XCAP_TASK_EXIT;
//     }
    
    /* Delete queues. */
    resultok = (OSAL_SUCCESS == OSAL_msgQDelete(obj_ptr->cmdq));
    global_ptr->queue.xcapCmd = obj_ptr->cmdq = NULL;

    resultok &= (OSAL_SUCCESS == OSAL_msgQDelete(global_ptr->queue.isiEvt));
    global_ptr->queue.xcapEvt = obj_ptr->evtq = NULL;
    
    if (!resultok) {
        return (TAPP_FAIL);
    }
    return (TAPP_PASS);
}

/*
 * ======== TAPP_mockXcapIssueEvt() ========
 *
 * This function is used to issue an Xcap event.
 * 
 * Return Values:
 *   TAPP_PASS:send event message sucessfully.
 *   TAPP_FAIL: send event message failed.
 */
vint TAPP_mockXcapIssueEvt(
    TAPP_GlobalObj *global_ptr,
    TAPP_mockXcapEvt *mockXcapEvt_ptr)
{
    XCAP_Evt         evt;
    
    evt.error = mockXcapEvt_ptr->error;
    evt.hdr_ptr = mockXcapEvt_ptr->hdr;
    evt.body_ptr = mockXcapEvt_ptr->body;
    if (OSAL_SUCCESS != OSAL_msgQSend(global_ptr->queue.xcapEvt,
            (char *)&evt,
            sizeof(XCAP_Evt),
            OSAL_WAIT_FOREVER,
            NULL)) {
        TAPP_dbgPrintf("%s:%d", __FILE__, __LINE__);

        // OSAL_memFree(evt.hdr_ptr, 0);
        // OSAL_memFree(evt.body_ptr, 0);
    }
    return TAPP_PASS;
}

/*
 * ======== TAPP_mockXcapIssueCmd() ========
 *
 * This function is used to validate cmd message.
 * 
 * Return Values:
 *   TAPP_PASS: the result is same the expected value.
 *   TAPP_FAIL: the result is different with the expected value.
 */
vint TAPP_mockXcapValidateCmd(
    TAPP_GlobalObj *global_ptr,
    TAPP_Action    *action_ptr)
{
    TAPP_Event   *tappEvt_ptr;
    XCAP_Cmd    *xcapCmd_ptr;
    TAPP_mockXcapCmd *mockXcapCmd_ptr;

    tappEvt_ptr = &global_ptr->tappEvt;
    mockXcapCmd_ptr = &action_ptr->msg.mockXcapCmd;

    if (TAPP_PASS != TAPP_getInputEvent(global_ptr, action_ptr,
            tappEvt_ptr, action_ptr->u.timeout)) {
        return (TAPP_FAIL);
    }
    if (TAPP_EVENT_TYPE_XCAP != tappEvt_ptr->type) {
        return (TAPP_FAIL);
    }
    xcapCmd_ptr = &tappEvt_ptr->msg.xcapCmd;
    
    if (mockXcapCmd_ptr->op != xcapCmd_ptr->op) {
        return (TAPP_FAIL);
    }
    if (mockXcapCmd_ptr->opType != xcapCmd_ptr->opType) {
        return (TAPP_FAIL);
    }
    if (mockXcapCmd_ptr->cond != xcapCmd_ptr->cond) {
        return (TAPP_FAIL);
    }
    if (OSAL_strncmp(mockXcapCmd_ptr->uri, xcapCmd_ptr->uri_ptr,
            TAPP_MOCK_XCAP_HEADER_SZ)) {
        return (TAPP_FAIL);
    }
    
    /* XXX */
    /* username, password, x3gpp, auid, etag */

    if (0 != OSAL_strcmp(mockXcapCmd_ptr->body, "")) {
        TAPP_dbgPrintf("TAPP_mockXcapValidateCmd: xcapCmd xml=\n%s\n",
                xcapCmd_ptr->src_ptr);
        if (0 != OSAL_strncmp(mockXcapCmd_ptr->body, xcapCmd_ptr->src_ptr,
                OSAL_strlen(xcapCmd_ptr->src_ptr))) {
            TAPP_dbgPrintf("TAPP_mockXcapValidateCmd: failed body:\n%s\n",
                    mockXcapCmd_ptr->body);
            return (TAPP_FAIL);
        }
    }
    
    return TAPP_PASS;
}
