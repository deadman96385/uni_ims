
#include "sci_types.h"
#include "vp8_entropy.h"
#include "vp8dec_basic.h"
#include "vp8dec_mode.h"
// #include "vp8dec_detokenize.h"
#include "vp8dec_dboolhuff.h"
#include "video_common.h"//weihu
#include "common_global.h" //derek

#define BR_COUNT 8
#define BOOL_DATA uint8
#define OCB_X PREV_COEF_CONTEXTS * ENTROPY_NODES
uint16 vp8_coef_bands_x[16] = { 0, 1 * OCB_X, 2 * OCB_X, 3 * OCB_X, 6 * OCB_X, 4 * OCB_X, 5 * OCB_X, 
	6 * OCB_X, 6 * OCB_X, 6 * OCB_X, 6 * OCB_X, 6 * OCB_X, 6 * OCB_X, 6 * OCB_X, 6 * OCB_X, 7 * OCB_X};
#define EOB_CONTEXT_NODE            0
#define ZERO_CONTEXT_NODE           1
#define ONE_CONTEXT_NODE            2
#define LOW_VAL_CONTEXT_NODE        3
#define TWO_CONTEXT_NODE            4
#define THREE_CONTEXT_NODE          5
#define HIGH_LOW_CONTEXT_NODE       6
#define CAT_ONE_CONTEXT_NODE        7
#define CAT_THREEFOUR_CONTEXT_NODE  8
#define CAT_THREE_CONTEXT_NODE      9
#define CAT_FIVE_CONTEXT_NODE       10

static const TOKENEXTRABITS vp8d_token_extra_bits2[MAX_ENTROPY_TOKENS] =	// derek 20120918
//const TOKENEXTRABITS vp8d_token_extra_bits2[MAX_ENTROPY_TOKENS] =
{
    {  0, -1, { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   } },  //ZERO_TOKEN
    {  1, 0, { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   } },   //ONE_TOKEN
    {  2, 0, { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   } },   //TWO_TOKEN
    {  3, 0, { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   } },   //THREE_TOKEN
    {  4, 0, { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   } },   //FOUR_TOKEN
    {  5, 0, { 159, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   } },  //DCT_VAL_CATEGORY1
    {  7, 1, { 145, 165, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0   } }, //DCT_VAL_CATEGORY2
    { 11, 2, { 140, 148, 173, 0,  0,  0,  0,  0,  0,  0,  0,  0   } }, //DCT_VAL_CATEGORY3
    { 19, 3, { 135, 140, 155, 176, 0,  0,  0,  0,  0,  0,  0,  0   } }, //DCT_VAL_CATEGORY4
    { 35, 4, { 130, 134, 141, 157, 180, 0,  0,  0,  0,  0,  0,  0   } }, //DCT_VAL_CATEGORY5
    { 67, 10, { 129, 130, 133, 140, 153, 177, 196, 230, 243, 254, 254, 0   } }, //DCT_VAL_CATEGORY6
    {  0, -1, { 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   } },  // EOB TOKEN
};

extern const unsigned int vp8dx_bitreader_norm[256];

int16 c;
int16 v;
int16 val;
const vp8_prob *coef_probs;
const vp8_prob *Prob;
const int *scan;
int16 *qcoeff_ptr;


void NORMALIZE(BOOL_DECODER *br)
{
	register unsigned int shift = vp8dx_bitreader_norm[br->range];

	br->range <<= shift;
	br->value <<= shift;
	br->count -= shift;
	if(br->count <= 0)
	{
		br->count += BR_COUNT ;
		br->value |= (*br->read_ptr++) << (BR_COUNT-br->count);
	}
}


void DECODE_AND_APPLYSIGN(BOOL_DECODER *br, int16 value_to_sign)
{
	unsigned int split;

	split = (br->range + 1) >> 1;
	if ( (br->value >> 8) < split )
	{
		br->range = split;
		v = value_to_sign;
	}
	else
	{
		br->range -= split;
		br->value -= (split<<8);
		v = -value_to_sign;
	}
	br->range += br->range;
	br->value += br->value;
	if (!--br->count)
	{
		br->count = BR_COUNT;
		br->value |= *br->read_ptr++;
    }
}


uint32 DECODE_AND_BRANCH_IF_ZERO(BOOL_DECODER *br, int probability)
{
    unsigned int split;
	
    split = 1 + (((br->range - 1) * probability) >> 8);

	if ( (br->value >> 8) < split )
	{
		br->range = split;
		NORMALIZE(br);
		return 1;
	}
	br->value -= (split<<8);
	br->range -= split;
	NORMALIZE(br);
	return 0;
}


uint32 DECODE_AND_LOOP_IF_ZERO(BOOL_DECODER *br, int probability)
{
	unsigned int split;

	split = 1 + (((br->range - 1) * probability) >> 8);

	if ( (br->value >> 8) < split )
	{
		br->range = split;
		NORMALIZE(br);
		Prob = coef_probs;
		if(c<15)
		{
			++c;
			Prob += vp8_coef_bands_x[c];
			return 1;
		}
		return 2;/*for malformed input */
	}
	br->value -= (split<<8);
	br->range -= split;
	NORMALIZE(br);
	return 0;
}


uint32 DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(BOOL_DECODER *br, int16 val)
{
    DECODE_AND_APPLYSIGN(br, val);
    Prob = coef_probs + (ENTROPY_NODES*2);
    if(c < 15)
	{
		qcoeff_ptr [ scan[c] ] = (int16) v;
		++c;
		return 1;
	}
    qcoeff_ptr [ scan[15] ] = (int16) v;
    return 0;
}


void DECODE_EXTRABIT_AND_ADJUST_VAL(BOOL_DECODER *br, int16 t, int16 bits_count)
{
	unsigned int split;

    split = 1 +  (((br->range-1) * vp8d_token_extra_bits2[t].Probs[bits_count]) >> 8);
    if(br->value >= (split<<8))
	{
		br->range -= split;
		br->value -= (split<<8);
		val += ((uint16)1<<bits_count);
	}
    else
	{
		br->range = split;
	}
    NORMALIZE(br);
}


int vp8_decode_mb_tokens(VP8D_COMP *dx, MACROBLOCKD *x)
{
    ENTROPY_CONTEXT **const A = x->above_context;
    ENTROPY_CONTEXT(* const L)[4] = x->left_context;
    const VP8_COMMON *const oc = & dx->common;

    BOOL_DECODER *bc = x->current_bc;

    ENTROPY_CONTEXT *a;
    ENTROPY_CONTEXT *l;
    int i;
	int type;
    int stop;
	int16 t;
	int16 bits_count;

    int eobtotal = 0;

	uint32 branch;

    type = 3;
    i = 0;
    stop = 16;

    if (x->mbmi.mode != B_PRED && x->mbmi.mode != SPLITMV)
    {
        i = 24;
        stop = 24;
        type = 1;
        qcoeff_ptr = &x->qcoeff[24*16];
        scan = vp8_default_zig_zag1d;
        eobtotal -= 16;
    }
    else
    {
        scan = vp8_default_zig_zag1d;
        qcoeff_ptr = &x->qcoeff[0];
    }

    coef_probs = oc->fc.coef_probs [type] [ 0 ] [0];

BLOCK_LOOP:
    a = A[ vp8_block2context[i] ] + vp8_block2above[i];
    l = L[ vp8_block2context[i] ] + vp8_block2left[i];
    c = (int16)(!type);		// Initial entry coeff pos
	
//    VP8_COMBINEENTROPYCONTEXTS(t, *a, *l);
	t = ((*a)!=0) + ((*l)!=0);
    Prob = coef_probs;
    Prob += t * ENTROPY_NODES;

DO_WHILE:
    Prob += vp8_coef_bands_x[c];
    branch = DECODE_AND_BRANCH_IF_ZERO(bc, Prob[EOB_CONTEXT_NODE]);
	if(branch)
		goto BLOCK_FINISHED;

CHECK_0_:
    branch = DECODE_AND_LOOP_IF_ZERO(bc, Prob[ZERO_CONTEXT_NODE]);
	if(branch==1)
		goto CHECK_0_;
	else if(branch==2)
		goto BLOCK_FINISHED;
    branch = DECODE_AND_BRANCH_IF_ZERO(bc, Prob[ONE_CONTEXT_NODE]);
	if(branch)
		goto ONE_CONTEXT_NODE_0_;
    branch = DECODE_AND_BRANCH_IF_ZERO(bc, Prob[LOW_VAL_CONTEXT_NODE]);
	if(branch)
		goto LOW_VAL_CONTEXT_NODE_0_;
    branch = DECODE_AND_BRANCH_IF_ZERO(bc, Prob[HIGH_LOW_CONTEXT_NODE]);
	if(branch)
		goto HIGH_LOW_CONTEXT_NODE_0_;
    branch = DECODE_AND_BRANCH_IF_ZERO(bc, Prob[CAT_THREEFOUR_CONTEXT_NODE]);
	if(branch)
		goto CAT_THREEFOUR_CONTEXT_NODE_0_;
    branch = DECODE_AND_BRANCH_IF_ZERO(bc, Prob[CAT_FIVE_CONTEXT_NODE]);
	if(branch)
		goto CAT_FIVE_CONTEXT_NODE_0_;
    val = vp8d_token_extra_bits2[DCT_VAL_CATEGORY6].min_val;
    bits_count = vp8d_token_extra_bits2[DCT_VAL_CATEGORY6].Length;

    do
    {
        DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY6, bits_count);
        bits_count -- ;
    }
    while (bits_count >= 0);

    branch = DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(bc, val);
	if(branch)
		goto DO_WHILE;
	else
		goto BLOCK_FINISHED;

CAT_FIVE_CONTEXT_NODE_0_:
    val = vp8d_token_extra_bits2[DCT_VAL_CATEGORY5].min_val;
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY5, 4);
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY5, 3);
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY5, 2);
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY5, 1);
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY5, 0);
    branch = DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(bc, val);
	if(branch)
		goto DO_WHILE;
	else
		goto BLOCK_FINISHED;

CAT_THREEFOUR_CONTEXT_NODE_0_:
    branch = DECODE_AND_BRANCH_IF_ZERO(bc, Prob[CAT_THREE_CONTEXT_NODE]);
	if(branch)
		goto CAT_THREE_CONTEXT_NODE_0_;
    val = vp8d_token_extra_bits2[DCT_VAL_CATEGORY4].min_val;
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY4, 3);
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY4, 2);
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY4, 1);
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY4, 0);
    branch = DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(bc, val);
	if(branch)
		goto DO_WHILE;
	else
		goto BLOCK_FINISHED;

CAT_THREE_CONTEXT_NODE_0_:
    val = vp8d_token_extra_bits2[DCT_VAL_CATEGORY3].min_val;
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY3, 2);
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY3, 1);
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY3, 0);
    branch = DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(bc, val);
	if(branch)
		goto DO_WHILE;
	else
		goto BLOCK_FINISHED;

HIGH_LOW_CONTEXT_NODE_0_:
    branch = DECODE_AND_BRANCH_IF_ZERO(bc, Prob[CAT_ONE_CONTEXT_NODE]);
	if(branch)
		goto CAT_ONE_CONTEXT_NODE_0_;

    val = vp8d_token_extra_bits2[DCT_VAL_CATEGORY2].min_val;
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY2, 1);
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY2, 0);
    branch = DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(bc, val);
	if(branch)
		goto DO_WHILE;
	else
		goto BLOCK_FINISHED;

CAT_ONE_CONTEXT_NODE_0_:
    val = vp8d_token_extra_bits2[DCT_VAL_CATEGORY1].min_val;
    DECODE_EXTRABIT_AND_ADJUST_VAL(bc, DCT_VAL_CATEGORY1, 0);
    branch = DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(bc, val);
	if(branch)
		goto DO_WHILE;
	else
		goto BLOCK_FINISHED;

LOW_VAL_CONTEXT_NODE_0_:
    branch = DECODE_AND_BRANCH_IF_ZERO(bc, Prob[TWO_CONTEXT_NODE]);
	if(branch)
		goto TWO_CONTEXT_NODE_0_;
    branch = DECODE_AND_BRANCH_IF_ZERO(bc, Prob[THREE_CONTEXT_NODE]);
	if(branch)
		goto THREE_CONTEXT_NODE_0_;
    branch = DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(bc, 4);
	if(branch)
		goto DO_WHILE;
	else
		goto BLOCK_FINISHED;

THREE_CONTEXT_NODE_0_:
    branch = DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(bc, 3);
	if(branch)
		goto DO_WHILE;
	else
		goto BLOCK_FINISHED;

TWO_CONTEXT_NODE_0_:
    branch = DECODE_SIGN_WRITE_COEFF_AND_CHECK_EXIT(bc, 2);
	if(branch)
		goto DO_WHILE;
	else
		goto BLOCK_FINISHED;

ONE_CONTEXT_NODE_0_:
    DECODE_AND_APPLYSIGN(bc, 1);
    Prob = coef_probs + ENTROPY_NODES;

    if (c < 15)
    {
        qcoeff_ptr [ scan[c] ] = (int16) v;
        ++c;
        goto DO_WHILE;
    }

    qcoeff_ptr [ scan[15] ] = (int16) v;
BLOCK_FINISHED:
    t = ((x->block[i].eob = c) != !type);   // any nonzero data?
    eobtotal += x->block[i].eob;
    *a = *l = t;
    qcoeff_ptr += 16;

#ifdef TV_OUT
	g_isyn_buf_ptr->ISYN_CFG1 |= (t << i);
#endif

    i++;

	if(i == 21)
		printf("");
	
    if (i < stop)
        goto BLOCK_LOOP;

    if (i == 25)
    {
        scan = vp8_default_zig_zag1d;//x->scan_order1d;
        type = 0;
        i = 0;
        stop = 16;
        coef_probs = oc->fc.coef_probs [type] [ 0 ] [0];
        qcoeff_ptr = &x->qcoeff[0];
        goto BLOCK_LOOP;
    }

    if (i == 16)
    {
        type = 2;
        coef_probs = oc->fc.coef_probs [type] [ 0 ] [0];
        stop = 24;
        goto BLOCK_LOOP;
    }
    return eobtotal;
}

void vp8_reset_mb_tokens_context(MACROBLOCKD *x)
{
    ENTROPY_CONTEXT **const A = x->above_context;
    ENTROPY_CONTEXT(* const L)[4] = x->left_context;

    ENTROPY_CONTEXT *a;
    ENTROPY_CONTEXT *l;
    int i;

    for (i = 0; i < 24; i++)
    {

        a = A[ vp8_block2context[i] ] + vp8_block2above[i];
        l = L[ vp8_block2context[i] ] + vp8_block2left[i];

        *a = *l = 0;
    }

    if (x->mbmi.mode != B_PRED && x->mbmi.mode != SPLITMV)
    {
        a = A[Y2CONTEXT] + vp8_block2above[24];
        l = L[Y2CONTEXT] + vp8_block2left[24];
        *a = *l = 0;
    }
}