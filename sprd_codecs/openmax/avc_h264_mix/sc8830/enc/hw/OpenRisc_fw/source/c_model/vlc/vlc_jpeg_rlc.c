/************************************************************
description:
	huffman coding for one event including luma_dc, luma_ac, chroma_dc, 
	chroma_ac, eob_luma, eob_chroma, escape_luma, escape_chroma

  huffman table: only for ac coeff's run/size:
					0/1~0/a
					1/1~1/a
					2/1~2/a
					...
					f/1~f/a

  huffman table size is 160 word, the left 16 bits for chroma, and right 16 bits for luma,
  and the code_word is left align in its 16 bits

  dc coefficient is coded by combinational logic
  eob 0/0, and escape f/0 is coded by combinational logic
  ac size is generated by combinational logic
*************************************************************/
#include "sc6800x_video_header.h"

void jpeg_vlc (
			   int			blk_id, 
			   int			is_dc, 
			   int			run, 
			   int16		level
			   )
{
	int		is_chroma;
	int		size;
	int		abs_level;
	int		code_word;
	int		code_len;
	int		run_size;
	int16	dc_diff;
	
	int		vlc_bsm_wr;
	int32   u_block_num = g_block_num_in_one_mcu - 2;


	is_chroma = (blk_id >= u_block_num) ? 1 : 0;

	if (is_dc)
	{
		if (blk_id < u_block_num)
		{
			dc_diff = level - g_enc_dc_pred_y;
			g_enc_dc_pred_y = level;
		}
		else if (blk_id == u_block_num)
		{
			dc_diff = level - g_enc_dc_pred_u;
			g_enc_dc_pred_u = level;
		}
		else 
		{
			dc_diff = level - g_enc_dc_pred_v;
			g_enc_dc_pred_v = level;
		}

		level = dc_diff;
	}
	
	abs_level  = (level < 0) ? -(level--) : level;

	/*get size of coeffcient*/
	size = 0;
	while (abs_level)
	{
		abs_level >>= 1;
		size++;
	}

	run_size = (run << 4) | size;
	
	if (is_dc)
	{
		/*encoding dc coefficient by combinational logic*/
		if (!is_chroma)
		{
			switch(size)
			{
			case 0:
				code_word = 0;
				break;
			case 1:
				code_word = 0x2;
				break;
			case 2:
				code_word = 0x3;
				break;
			case 3:
				code_word = 0x4;
				break;
			case 4:
				code_word = 0x5;
				break;
			case 5:
				code_word = 0x6;
				break;
			case 6:
				code_word = 0xe;
				break;
			case 7:
				code_word = 0x1e;
				break;
			case 8:
				code_word = 0x3e;
				break;
			case 9:
				code_word = 0x7e;
				break;
			case 10:
				code_word = 0xfe;
				break;
			case 11:
				code_word = 0x1fe;
				break;
			default:
				code_word = 0;
			}

			if (size == 0)
				code_len = 2;
			else if ((size > 0) && (size < 6))
				code_len = 3;
			else
				code_len = size - 2;
		}
		else
		{
			switch(size)
			{
			case 0:
				code_word = 0;
				break;
			case 1:
				code_word = 0x1;
				break;
			case 2:
				code_word = 0x2;
				break;
			case 3:
				code_word = 0x6;
				break;
			case 4:
				code_word = 0xe;
				break;
			case 5:
				code_word = 0x1e;
				break;
			case 6:
				code_word = 0x3e;
				break;
			case 7:
				code_word = 0x7e;
				break;
			case 8:
				code_word = 0xfe;
				break;
			case 9:
				code_word = 0x1fe;
				break;
			case 10:
				code_word = 0x3fe;
				break;
			case 11:
				code_word = 0x7fe;
				break;
			default:
				code_word = 0;
			}

			if (size < 3)
				code_len = 2;
			else
				code_len = size;
		}
	}
	else if (run_size == 0x00)
	{
		/*encoding eob*/
		code_word = !is_chroma ? 0xa : 0x0;
		code_len  = !is_chroma ? 4 : 2;
	}
	else if (run_size == 0xf0)
	{
		code_word = !is_chroma ? 0x7f9 : 0x3fa;
		code_len  = !is_chroma ? 11 : 10;
	}
	else
	{
		int		vlc_tbuf_addr;
		uint32	vlc_tbuf_rdata = 0;
		
		/*look up table to get code word*/
		vlc_tbuf_addr = run*10 + (size-1);
#if defined(JPEG_ENC)		
		vlc_tbuf_rdata = g_huff_tab_enc [vlc_tbuf_addr];
#endif
		
		code_word = (vlc_tbuf_rdata >> (is_chroma*16)) & 0xffff;
	}

	/*code length is computed by combinational logic*/
	if (!is_dc && (run_size != 0x00) && (run_size != 0xf0))
	{
		if (!is_chroma)
		{
			switch(run_size) 
			{
			case 0x01:
			case 0x02:
				code_len = 2;
				break;

			case 0x03:
				code_len = 3;
				break;

			case 0x04:
			case 0x11:
				code_len = 4;
				break;

			case 0x05:
			case 0x12:
			case 0x21:
				code_len = 5;
				break;

			case 0x31:
			case 0x41:
				code_len = 6;
				break;

			case 0x06:
			case 0x13:
			case 0x51:
			case 0x61:				
				code_len = 7;
				break;

			case 0x07:
			case 0x22:
			case 0x71:
				code_len = 8;
				break;

			case 0x14:
			case 0x32:
			case 0x81:
			case 0x91:
			case 0xa1:
				code_len = 9;
				break;

			case 0x08:
			case 0x23:
			case 0x42:
			case 0xb1:
			case 0xc1:				
				code_len = 10;
				break;

			case 0x15:
			case 0x52:
			case 0xd1:				
				code_len = 11;
				break;

			case 0x24:
			case 0x33:
			case 0x62:
			case 0x72:
				code_len = 12;
				break;

			case 0x82:
				code_len = 15;
				break;

			default:
				code_len = 16;
				break;
			}			
		}
		else
		{
			switch(run_size)
			{
			case 0x01:
				code_len = 2;
				break;

			case 0x02:
				code_len = 3;
				break;

			case 0x03:
			case 0x11:
				code_len = 4;
				break;

			case 0x04:
			case 0x05:
			case 0x21:
			case 0x31:
				code_len = 5;
				break;

			case 0x06:
			case 0x12:
			case 0x41:
			case 0x51:
				code_len = 6;
				break;

			case 0x07:
			case 0x61:
			case 0x71:
				code_len = 7;
				break;

			case 0x13:
			case 0x22:
			case 0x32:
			case 0x81:				
				code_len = 8;
				break;

			case 0x08:
			case 0x14:
			case 0x42:
			case 0x91:
			case 0xa1:
			case 0xb1:
			case 0xc1:
				code_len = 9;
				break;

			case 0x09:
			case 0x23:
			case 0x33:
			case 0x52:
				code_len = 10;
				break;

			case 0x15:
			case 0x62:
			case 0x72:
			case 0xd1:
				code_len = 11;
				break;

			case 0x0a:
			case 0x16:
			case 0x24:
			case 0x34:
				code_len = 12;
				break;

			case 0xe1:
				code_len = 14;
				break;

			case 0x25:
			case 0xf1:
				code_len = 15;
				break;
				
			default:
				code_len = 16;
				break;
			}
		}
		
		code_word = code_word >> (16-code_len);
	}

// 	printf("%0x,%0x,%0x,%0x\n", code_word, code_len, (uint16) level, size);

	/*out vlc code*/
	write_nbits (code_word, code_len, 1);
	vlc_bsm_wr		= 1;

	if ((run_size != 0x00) && (run_size != 0xf0)) // not eob or run<15
	{
		/*out fix length code, */
		write_nbits (level, size, 1);
		vlc_bsm_wr		= 1;		//one pulse for writing code to bsm
	}
}























































