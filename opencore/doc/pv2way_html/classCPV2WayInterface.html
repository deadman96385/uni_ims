<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pv2way_engine: CPV2WayInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CPV2WayInterface Class Reference</h1><!-- doxytag: class="CPV2WayInterface" -->
<p><code>#include &lt;<a class="el" href="pv__2way__interface_8h_source.html">pv_2way_interface.h</a>&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a527bb1e253aff5c6fd77992be4dee838">~CPV2WayInterface</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#ac1f1b38a3d57f4f431bf0abd3739b388">GetSDKInfo</a> (PVSDKInfo &amp;aSDKInfo, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a6b7de3d51dc52508fabc10dc90087e15">GetSDKModuleInfo</a> (PVSDKModuleInfo &amp;aSDKModuleInfo, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a3f925c1944bb84a32b92f797b33a700b">Init</a> (<a class="el" href="classPV2WayInitInfo.html">PV2WayInitInfo</a> &amp;aInitInfo, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a9667ab6f87d960e3291a750441d7e2b3">Reset</a> (OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a76e71b906b59d40eb82099a12fafc6e7">AddDataSource</a> (<a class="el" href="pv__2way__basic__types_8h.html#a022c1dc5949f6008004878e5ae663de4">PVTrackId</a> aTrackId, PVMFNodeInterface &amp;aDataSource, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#ab0328af85d59d6b26504f62990146f02">RemoveDataSource</a> (PVMFNodeInterface &amp;aDataSource, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a06a813ed7b1989246f8cd77e60cf742b">AddDataSink</a> (<a class="el" href="pv__2way__basic__types_8h.html#a022c1dc5949f6008004878e5ae663de4">PVTrackId</a> aTrackId, PVMFNodeInterface &amp;aDataSink, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a961f8ebbd4f25e7559c0f31880227502">RemoveDataSink</a> (PVMFNodeInterface &amp;aDataSink, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a59cff4eff03845aa93df8691124e9385">Connect</a> (const <a class="el" href="classPV2WayConnectOptions.html">PV2WayConnectOptions</a> &amp;aOptions, PVMFNodeInterface *aCommServer=NULL, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a13a93403242eab4763835d66c6bc3ef2">Disconnect</a> (OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a791dd03ed115b0037c52e1ca2e375cf1">GetState</a> (<a class="el" href="pv__2way__basic__types_8h.html#aa30e8f44267fe77fd99d7923b498cd43">PV2WayState</a> &amp;aState, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a5f41a487dcabd61ef7ad3cc3468f049e">Pause</a> (<a class="el" href="pv__2way__basic__types_8h.html#ac317ca49ff6a168a50adbda432171232">PV2WayDirection</a> aDirection, <a class="el" href="pv__2way__basic__types_8h.html#a022c1dc5949f6008004878e5ae663de4">PVTrackId</a> aTrackId, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a1f7e2359a8a3678930e02a45566f7c9e">Resume</a> (<a class="el" href="pv__2way__basic__types_8h.html#ac317ca49ff6a168a50adbda432171232">PV2WayDirection</a> aDirection, <a class="el" href="pv__2way__basic__types_8h.html#a022c1dc5949f6008004878e5ae663de4">PVTrackId</a> aTrackId, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#aa53f5eba3cce928a716d7d12e82cc590">SetLogAppender</a> (const char *aTag, OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;aAppender, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#ad13f6c374394badf181cb235dfb888b0">RemoveLogAppender</a> (const char *aTag, OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;aAppender, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a6c2e1d10d98af47bbaaeb6a82fecb6a8">SetLogLevel</a> (const char *aTag, int32 aLevel, bool aSetSubtree=false, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a2d330ea36479d66184753d3d418593b6">GetLogLevel</a> (const char *aTag, int32 &amp;aLogInfo, OsclAny *aContextData=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a37537c1aba8cc700d6f3267617a05286">QueryInterface</a> (const PVUuid &amp;aUuid, PVInterface *&amp;aInterfacePtr, OsclAny *aContext=NULL)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual OSCL_IMPORT_REF PVCommandId&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCPV2WayInterface.html#a2438d83d8d96c7354f06458e5b608984">CancelAllCommands</a> (OsclAny *aContextData=NULL)=0</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classCPV2WayInterface.html">CPV2WayInterface</a> Class</p>
<p><a class="el" href="classCPV2WayInterface.html">CPV2WayInterface</a> is the interface to the pv2way SDK, which allows initialization, control, and termination of a two-way (3g-324m, SIP) terminal. The application is expected to contain and maintain a pointer to the <a class="el" href="classCPV2WayInterface.html">CPV2WayInterface</a> instance at all times that a call is active. The CPV2WayFactory factory class is to be used to create and delete instances of this class </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a527bb1e253aff5c6fd77992be4dee838"></a><!-- doxytag: member="CPV2WayInterface::~CPV2WayInterface" ref="a527bb1e253aff5c6fd77992be4dee838" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual CPV2WayInterface::~CPV2WayInterface </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Object destructor function Releases Resources prior to destruction </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a06a813ed7b1989246f8cd77e60cf742b"></a><!-- doxytag: member="CPV2WayInterface::AddDataSink" ref="a06a813ed7b1989246f8cd77e60cf742b" args="(PVTrackId aTrackId, PVMFNodeInterface &amp;aDataSink, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::AddDataSink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pv__2way__basic__types_8h.html#a022c1dc5949f6008004878e5ae663de4">PVTrackId</a>&nbsp;</td>
          <td class="paramname"> <em>aTrackId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function allows the user to specify the media sink for an incoming track. AddDataSinkL can be called only for established incoming tracks identified by a unique track id. Incoming tracks are initiated by the peer and their establishment is indicated using the PVT_INDICATION_INCOMING_TRACK notification which provides the media type and a unique track id. The format type is indicated using the PV2WayTrackInfoInterface extension interface in the PVAsyncInformationalEvent. Data sinks could be of the following types: a)raw media sinks like video display sinks for RGB and YUV formats, audio rendering sinks for PCM. b)sources of compressed data like file, combined decode and render devices.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTrackId</em>&nbsp;</td><td>Indicates the unique track id to be associated with this sink. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aDataSink</em>&nbsp;</td><td>The data sink to be added </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a76e71b906b59d40eb82099a12fafc6e7"></a><!-- doxytag: member="CPV2WayInterface::AddDataSource" ref="a76e71b906b59d40eb82099a12fafc6e7" args="(PVTrackId aTrackId, PVMFNodeInterface &amp;aDataSource, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::AddDataSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pv__2way__basic__types_8h.html#a022c1dc5949f6008004878e5ae663de4">PVTrackId</a>&nbsp;</td>
          <td class="paramname"> <em>aTrackId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function allows the user to specify the media source for an outgoing track. Sources should be added after the PVT_INDICATION_OUTGOING_TRACK is received which specifies the format type and the unique track id. The format type is indicated using the PV2WayTrackInfoInterface extension interface in the PVAsyncInformationalEvent. Data sources could be of the following types: a)raw media sources like camera, microphone etc. b)sources of compressed data like file, combined capture and encode devices.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTrackId</em>&nbsp;</td><td>The outgoing track id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aDataSource</em>&nbsp;</td><td>Reference to the data source for this track </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes PVMFErrNotSupported if the format of the sources/sinks is incomtible with what the SDK can handle KPVErrInvalidState if invoked in the incorrect state KErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a2438d83d8d96c7354f06458e5b608984"></a><!-- doxytag: member="CPV2WayInterface::CancelAllCommands" ref="a2438d83d8d96c7354f06458e5b608984" args="(OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::CancelAllCommands </td>
          <td>(</td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is to allow the user to cancel all pending requests. The current request being processed, if any, will also be aborted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a59cff4eff03845aa93df8691124e9385"></a><!-- doxytag: member="CPV2WayInterface::Connect" ref="a59cff4eff03845aa93df8691124e9385" args="(const PV2WayConnectOptions &amp;aOptions, PVMFNodeInterface *aCommServer=NULL, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::Connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPV2WayConnectOptions.html">PV2WayConnectOptions</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVMFNodeInterface *&nbsp;</td>
          <td class="paramname"> <em>aCommServer</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function can be invoked only in the ESetup state. The terminal starts connecting with the remote terminal based on the specified options and capabilities. Incoming tracks may be opened before ConnectL completes and will be indicated via the PVT_INDICATION_INCOMING_TRACK event.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aOptions</em>&nbsp;</td><td>Optional additional information for call setup. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCommServer</em>&nbsp;</td><td>An optional pointer to a comm server to provide comm source and sink end-points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a13a93403242eab4763835d66c6bc3ef2"></a><!-- doxytag: member="CPV2WayInterface::Disconnect" ref="a13a93403242eab4763835d66c6bc3ef2" args="(OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::Disconnect </td>
          <td>(</td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The Disconnect call is valid only when invoked in the EConnecting, and EConnected states. It causes the terminal to transition to the EDisconnecting state. All the media tracks both incoming and outgoing will be closed on invoking Disconnect. On completion, the terminal goes to the ESetup state. The statistics of the previous call shall still be available until Connect is invoked again.</p>
<p>It is a no-op when called in any other state.</p>
<p>The post disconnect option specifies what this terminal wishes to do after the data call is terminated, whether it wants to disconnect the line or continue the call as a voice only call.</p>
<p>This is an asynchronous request.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a2d330ea36479d66184753d3d418593b6"></a><!-- doxytag: member="CPV2WayInterface::GetLogLevel" ref="a2d330ea36479d66184753d3d418593b6" args="(const char *aTag, int32 &amp;aLogInfo, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::GetLogLevel </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 &amp;&nbsp;</td>
          <td class="paramname"> <em>aLogInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the logging level to be queried for a particular logging tag. A larger log level will result in more messages being logged.</p>
<p>In the asynchronous response, this should return the log level along with an indication of where the level was inherited (i.e., the ancestor tag).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the log level should be retrieved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aLogInfo</em>&nbsp;</td><td>an output parameter which will be filled in with the log level information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memory_error</em>&nbsp;</td><td>leaves on memory allocation error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ac1f1b38a3d57f4f431bf0abd3739b388"></a><!-- doxytag: member="CPV2WayInterface::GetSDKInfo" ref="ac1f1b38a3d57f4f431bf0abd3739b388" args="(PVSDKInfo &amp;aSDKInfo, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::GetSDKInfo </td>
          <td>(</td>
          <td class="paramtype">PVSDKInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>aSDKInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns version information about the SDK</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aSDKInfo</em>&nbsp;</td><td>A reference to a PVSDKInfo structure which contains the product label and date </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes PVMFErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a6b7de3d51dc52508fabc10dc90087e15"></a><!-- doxytag: member="CPV2WayInterface::GetSDKModuleInfo" ref="a6b7de3d51dc52508fabc10dc90087e15" args="(PVSDKModuleInfo &amp;aSDKModuleInfo, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::GetSDKModuleInfo </td>
          <td>(</td>
          <td class="paramtype">PVSDKModuleInfo &amp;&nbsp;</td>
          <td class="paramname"> <em>aSDKModuleInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns information about all modules currently used by the SDK.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aSDKModuleInfo</em>&nbsp;</td><td>A reference to a PVSDKModuleInfo structure which contains the number of modules currently used by pv2way SDK and the PV UID and description string for each module. The PV UID and description string for modules will be returned in one string buffer allocated by the client. If the string buffer is not large enough to hold the all the module's information, the information will be written up to the length of the buffer and truncated. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes PVMFErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a791dd03ed115b0037c52e1ca2e375cf1"></a><!-- doxytag: member="CPV2WayInterface::GetState" ref="a791dd03ed115b0037c52e1ca2e375cf1" args="(PV2WayState &amp;aState, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::GetState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pv__2way__basic__types_8h.html#aa30e8f44267fe77fd99d7923b498cd43">PV2WayState</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aState</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the current state of the pv2way. Application may use this info for updating display or determine if the pv2way is ready for the next request.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aState</em>&nbsp;</td><td>Reflects the state of the PV 2Way engine when the command was received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>value indicating the current pv2way state </dd></dl>

</div>
</div>
<a class="anchor" id="a3f925c1944bb84a32b92f797b33a700b"></a><!-- doxytag: member="CPV2WayInterface::Init" ref="a3f925c1944bb84a32b92f797b33a700b" args="(PV2WayInitInfo &amp;aInitInfo, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPV2WayInitInfo.html">PV2WayInitInfo</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aInitInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is valid only in the EIdle state. It is a no-op when invoked in any other state. It causes the pv2way to transition to the ESetup state. The terminal remains in the EInitializing state during the transition.</p>
<p>While initializing, the pv2way tries to allocate system resources needed for a two-way call. If it fails for some reason, and the pv2way reverts to the EIdle state. All the resources are de-allocated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aInitInfo</em>&nbsp;</td><td>A reference to a CPV2WayInitInfo structure which contains the capabilities of the applications sinks and sources to handle compressed and uncompressed formats. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes PVMFErrArgument if more tx and rx codecs are set than engine can handle, or the mandatory codecs are not in the list. PVMFErrNotSupported if the format of the sources/sinks is incomtible with what the SDK can handle PVMFErrInvalidState if invoked in the incorrect state PVMFErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a5f41a487dcabd61ef7ad3cc3468f049e"></a><!-- doxytag: member="CPV2WayInterface::Pause" ref="a5f41a487dcabd61ef7ad3cc3468f049e" args="(PV2WayDirection aDirection, PVTrackId aTrackId, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::Pause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pv__2way__basic__types_8h.html#ac317ca49ff6a168a50adbda432171232">PV2WayDirection</a>&nbsp;</td>
          <td class="paramname"> <em>aDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pv__2way__basic__types_8h.html#a022c1dc5949f6008004878e5ae663de4">PVTrackId</a>&nbsp;</td>
          <td class="paramname"> <em>aTrackId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For an incoming track this function pauses sending media to the sink (output device) and stops the sink.</p>
<p>For outgoing, it pauses the sending of media from the source and stops the source.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDirection</em>&nbsp;</td><td>Specifies the direction of the track - incoming or outgoing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTrackId</em>&nbsp;</td><td>Specifies which track is to be paused. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a37537c1aba8cc700d6f3267617a05286"></a><!-- doxytag: member="CPV2WayInterface::QueryInterface" ref="a37537c1aba8cc700d6f3267617a05286" args="(const PVUuid &amp;aUuid, PVInterface *&amp;aInterfacePtr, OsclAny *aContext=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::QueryInterface </td>
          <td>(</td>
          <td class="paramtype">const PVUuid &amp;&nbsp;</td>
          <td class="paramname"> <em>aUuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PVInterface *&amp;&nbsp;</td>
          <td class="paramname"> <em>aInterfacePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContext</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is to allow for extensibility of the pv2way interface. It allows a caller to ask for an instance of a particular interface object to be returned. The mechanism is analogous to the COM IUnknown method. The interfaces are identified with an interface ID that is a UUID as in DCE and a pointer to the interface object is returned if it is supported. Otherwise the returned pointer is NULL. TBD: Define the UIID, InterfacePtr structures </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aUuid</em>&nbsp;</td><td>The UUID of the desired interface </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aInterfacePtr</em>&nbsp;</td><td>The output pointer to the desired interface </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>not_supported</em>&nbsp;</td><td>leaves if the specified interface id is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a961f8ebbd4f25e7559c0f31880227502"></a><!-- doxytag: member="CPV2WayInterface::RemoveDataSink" ref="a961f8ebbd4f25e7559c0f31880227502" args="(PVMFNodeInterface &amp;aDataSink, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::RemoveDataSink </td>
          <td>(</td>
          <td class="paramtype">PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function unbinds a previously added sink.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSink</em>&nbsp;</td><td>pointer to the media sink node </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ab0328af85d59d6b26504f62990146f02"></a><!-- doxytag: member="CPV2WayInterface::RemoveDataSource" ref="ab0328af85d59d6b26504f62990146f02" args="(PVMFNodeInterface &amp;aDataSource, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::RemoveDataSource </td>
          <td>(</td>
          <td class="paramtype">PVMFNodeInterface &amp;&nbsp;</td>
          <td class="paramname"> <em>aDataSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function unbinds a previously added source.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDataSource</em>&nbsp;</td><td>pointer to the media source node</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="ad13f6c374394badf181cb235dfb888b0"></a><!-- doxytag: member="CPV2WayInterface::RemoveLogAppender" ref="ad13f6c374394badf181cb235dfb888b0" args="(const char *aTag, OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;aAppender, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::RemoveLogAppender </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aAppender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows a logging appender to be removed from the logger tree at the point specified by the input tag. The input tag cannot be NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the appender should be removed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aAppender</em>&nbsp;</td><td>The log appender to remove. Must be a reference to the same object that was set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memory_error</em>&nbsp;</td><td>leaves on memory allocation error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a9667ab6f87d960e3291a750441d7e2b3"></a><!-- doxytag: member="CPV2WayInterface::Reset" ref="a9667ab6f87d960e3291a750441d7e2b3" args="(OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::Reset </td>
          <td>(</td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is valid only in the ESetup and EInitializing state. It is a no-op when invoked in the EIdle state and returns PVMFErrInvalidState if invoked in any other state.</p>
<p>It causes the pv2way to transition back to the EIdle state. The terminal remains in the EResetting state during the transition.</p>
<p>While resetting, the pv2way de-allocates all resources resources that had been previously allocated. When it completes, ResetComplete is called and the pv2way reverts to the EIdle state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response  This method can leave with one of the following error codes PVMFErrInvalidState if invoked in the incorrect state PVMFErrNoMemory if the SDK failed to allocate memory during this operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a1f7e2359a8a3678930e02a45566f7c9e"></a><!-- doxytag: member="CPV2WayInterface::Resume" ref="a1f7e2359a8a3678930e02a45566f7c9e" args="(PV2WayDirection aDirection, PVTrackId aTrackId, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::Resume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="pv__2way__basic__types_8h.html#ac317ca49ff6a168a50adbda432171232">PV2WayDirection</a>&nbsp;</td>
          <td class="paramname"> <em>aDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pv__2way__basic__types_8h.html#a022c1dc5949f6008004878e5ae663de4">PVTrackId</a>&nbsp;</td>
          <td class="paramname"> <em>aTrackId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resume a previously paused incoming or outgoing track. For incoming, this function starts resumes playing out the media to the appropriate sink based on the current settings. For outgoing it resumes encoding and sending media from the source.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aDirection</em>&nbsp;</td><td>Specifies the direction of the track - incoming or outgoing </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTrackId</em>&nbsp;</td><td>Specifies which track is to be paused. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="aa53f5eba3cce928a716d7d12e82cc590"></a><!-- doxytag: member="CPV2WayInterface::SetLogAppender" ref="aa53f5eba3cce928a716d7d12e82cc590" args="(const char *aTag, OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;aAppender, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::SetLogAppender </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclSharedPtr&lt; PVLoggerAppender &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>aAppender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows a logging appender to be attached at some point in the logger tag tree. The location in the tag tree is specified by the input tag string. A single appender can be attached multiple times in the tree, but it may result in duplicate copies of log messages if the appender is not attached in disjoint portions of the tree. A logging appender is responsible for actually writing the log message to its final location (e.g., memory, file, network, etc). This API can be called anytime after creation of the terminal.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the appender should be attached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aAppender</em>&nbsp;</td><td>The log appender to attach. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memory_error</em>&nbsp;</td><td>leaves on memory allocation error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<a class="anchor" id="a6c2e1d10d98af47bbaaeb6a82fecb6a8"></a><!-- doxytag: member="CPV2WayInterface::SetLogLevel" ref="a6c2e1d10d98af47bbaaeb6a82fecb6a8" args="(const char *aTag, int32 aLevel, bool aSetSubtree=false, OsclAny *aContextData=NULL)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OSCL_IMPORT_REF PVCommandId CPV2WayInterface::SetLogLevel </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aSetSubtree</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsclAny *&nbsp;</td>
          <td class="paramname"> <em>aContextData</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the logging level to be set for the logging node specified by the tag. A larger log level will result in more messages being logged. A message will only be logged if its level is LESS THAN or equal to the current log level. The set_subtree flag will allow an entire subtree, with the specified tag as the root, to be reset to the specified value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTag</em>&nbsp;</td><td>Specifies the logger tree tag where the log level should be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aLevel</em>&nbsp;</td><td>Specifies the log level to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aSetSubtree</em>&nbsp;</td><td>Specifies whether the entire subtree with aTag as the root should be reset to the log level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aContextData</em>&nbsp;</td><td>Optional opaque data that will be passed back to the user with the command response</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>memory_error</em>&nbsp;</td><td>leaves on memory allocation error.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A unique command id for asynchronous completion </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="pv__2way__interface_8h_source.html">pv_2way_interface.h</a></li>
</ul>
</div>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>PV2Way Engine</small>
<address style="align: left;"><small>Posting Version: CORE_9.005.1.1 </small>
</small></address>
</body>
</html>
