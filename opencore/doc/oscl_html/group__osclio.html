<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>oscl: OSCL IO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>OSCL IO</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclDNSObserver.html">OsclDNSObserver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclDNS.html">OsclDNS</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclFileCacheBuffer.html">OsclFileCacheBuffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclFileCache.html">OsclFileCache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoscl__fsstat.html">oscl_fsstat</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoscl__stat__buf.html">oscl_stat_buf</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__FileFind.html">Oscl_FileFind</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclFileHandle.html">OsclFileHandle</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__File.html">Oscl_File</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclFileManager.html">OsclFileManager</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclNativeFile.html">OsclNativeFile</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOscl__FileServer.html">Oscl_FileServer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclFileStatsItem.html">OsclFileStatsItem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclFileStats.html">OsclFileStats</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclNativeFileParams.html">OsclNativeFileParams</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclSocketServ.html">OsclSocketServ</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclUDPSocket.html">OsclUDPSocket</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsclTCPSocket.html">OsclTCPSocket</a></td></tr>
<tr><td colspan="2"><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__dns_8h.html">oscl_dns.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__socket_8h.html" title="The file oscl_socket.h defines the OSCL Socket APIs.">oscl_socket.h</a> defines the OSCL DNS APIs. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__file__cache_8h.html">oscl_file_cache.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__file__cache_8h.html" title="The file oscl_file_cache.h defines the class OsclFileCache.">oscl_file_cache.h</a> defines the class <a class="el" href="classOsclFileCache.html">OsclFileCache</a>. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__file__dir__utils_8h.html">oscl_file_dir_utils.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__file__dir__utils_8h.html" title="The file oscl_file_dir_utils.h defines some unix-style directory ops.">oscl_file_dir_utils.h</a> defines some unix-style directory ops. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__file__find_8h.html">oscl_file_find.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__file__find_8h.html" title="The file oscl_file_find.h defines the class Oscl_FileFind.">oscl_file_find.h</a> defines the class <a class="el" href="classOscl__FileFind.html">Oscl_FileFind</a>. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__file__handle_8h.html">oscl_file_handle.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__file__handle_8h.html" title="The file oscl_file_handle.h defines the class OsclFileHandle.">oscl_file_handle.h</a> defines the class <a class="el" href="classOsclFileHandle.html">OsclFileHandle</a>. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__file__io_8h.html">oscl_file_io.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__file__io_8h.html" title="The file oscl_file_io.h defines the class Oscl_File. This is the public API to the...">oscl_file_io.h</a> defines the class <a class="el" href="classOscl__File.html">Oscl_File</a>. This is the public API to the basic file I/O operations. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__file__manager_8h.html">oscl_file_manager.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>File management class. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__file__native_8h.html">oscl_file_native.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__file__native_8h.html" title="The file oscl_file_native.h defines the class OsclNativeFile. This is the porting...">oscl_file_native.h</a> defines the class <a class="el" href="classOsclNativeFile.html">OsclNativeFile</a>. This is the porting layer for basic file I/O operations. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__file__server_8h.html">oscl_file_server.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__file__server_8h.html" title="The file oscl_file_server.h defines the class Oscl_FileServer. This is the porting...">oscl_file_server.h</a> defines the class <a class="el" href="classOscl__FileServer.html">Oscl_FileServer</a>. This is the porting layer for file server implementations. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__file__stats_8h.html">oscl_file_stats.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>File stats class. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__file__types_8h.html">oscl_file_types.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__file__types_8h.html" title="The file oscl_file_types.h defines some constants and types for file I/O implementations...">oscl_file_types.h</a> defines some constants and types for file I/O implementations. Anything that needs to be shared across implementation modules can go here. </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="oscl__socket_8h.html">oscl_socket.h</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The file <a class="el" href="oscl__socket_8h.html" title="The file oscl_socket.h defines the OSCL Socket APIs.">oscl_socket.h</a> defines the OSCL Socket APIs. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga32797bf7b13b0e5a52c356af13a4eebb">TOsclFileOffsetInt32</a>&nbsp;&nbsp;&nbsp;int32</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga34c8a106fe300de026af3c35da5d4db0">OSCL_FILE_STATS_LOGGER_NODE</a>&nbsp;&nbsp;&nbsp;&quot;OsclFileStats&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga586e2bacd0c3a3e75ddd4029379b237c">OSCL_IO_FILENAME_MAXLEN</a>&nbsp;&nbsp;&nbsp;512</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga5ed976264cf1003efd4a758a02d41a82">OSCL_IO_EXTENSION_MAXLEN</a>&nbsp;&nbsp;&nbsp;512</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga684e82a8e4f55bda98caacf6a390b7ff">OSCL_FILE_WCHAR_PATH_DELIMITER</a>&nbsp;&nbsp;&nbsp;_STRLIT(&quot;/&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaea100e01c32ea2162b946c08c7d8751f">OSCL_FILE_CHAR_PATH_DELIMITER</a>&nbsp;&nbsp;&nbsp;_STRLIT_CHAR(&quot;/&quot;)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structoscl__fsstat.html">oscl_fsstat</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gae5dc50ecd713b39db3e41c6af7120d00">OSCL_FSSTAT</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structoscl__stat__buf.html">oscl_stat_buf</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga5f071e77b9997cac7b583968bb6c9814">OSCL_STAT_BUF</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef FILE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga9b12ccba57a60b0ed79f20652995ff5f">TOsclFileHandle</a></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga8c2ea6404a214241178a4ca83f9d9a7c">TPVDNSFxn</a> { <a class="el" href="group__osclio.html#gga8c2ea6404a214241178a4ca83f9d9a7ca5cd080e81647c4dfe2332aa3fb119f74">EPVDNSGetHostByName</a>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gace3a79456572c0e719f50c8c6dc5e445">TPVDNSEvent</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggace3a79456572c0e719f50c8c6dc5e445aaaadce1ec5e87f8253ceb7f5e749959b">EPVDNSSuccess</a>, 
<a class="el" href="group__osclio.html#ggace3a79456572c0e719f50c8c6dc5e445ab79a27c87cf50ae28c2d3d76e500c235">EPVDNSPending</a>, 
<a class="el" href="group__osclio.html#ggace3a79456572c0e719f50c8c6dc5e445a4a1c212c698220cae749737b69bc0e99">EPVDNSTimeout</a>, 
<a class="el" href="group__osclio.html#ggace3a79456572c0e719f50c8c6dc5e445abb532d737fe56e0128da89da0898b0ec">EPVDNSFailure</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggace3a79456572c0e719f50c8c6dc5e445a2d11589798258a79b7b05240110c03ef">EPVDNSCancel</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga0a6210100e2b9b5d8edf7f416b2d11c7">OSCL_FILEMGMT_PERMS</a> { <a class="el" href="group__osclio.html#gga0a6210100e2b9b5d8edf7f416b2d11c7a45fb43584780f3bd39219d3c1cfb5054">OSCL_FILEMGMT_PERMS_READ</a> =  0x1, 
<a class="el" href="group__osclio.html#gga0a6210100e2b9b5d8edf7f416b2d11c7a5f4b59b4b75917c1df0fa70e8a062888">OSCL_FILEMGMT_PERMS_WRITE</a> =  0x2, 
<a class="el" href="group__osclio.html#gga0a6210100e2b9b5d8edf7f416b2d11c7ac949805558cfabe7b89d0b25dd915621">OSCL_FILEMGMT_PERMS_EXECUTE</a> =  0x4
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga8d312a40a46ddafab591e2300e395293">OSCL_FILEMGMT_MODES</a> { <a class="el" href="group__osclio.html#gga8d312a40a46ddafab591e2300e395293adbad29875c83ddef177efc34518c6ea5">OSCL_FILEMGMT_MODE_DIR</a> =  0x1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggafda4e74c3c2e515d7fe98eb208a122eca8768938f2ff9b009ab3961f83d6354b1">OSCL_FILEMGMT_E_OK</a> =  0, 
<a class="el" href="group__osclio.html#ggafda4e74c3c2e515d7fe98eb208a122eca85b79381e573ea7e3676ebc5e321a75a">OSCL_FILEMGMT_E_PATH_TOO_LONG</a>, 
<a class="el" href="group__osclio.html#ggafda4e74c3c2e515d7fe98eb208a122eca6aa680854414f237de3659cb55274292">OSCL_FILEMGMT_E_PATH_NOT_FOUND</a>, 
<a class="el" href="group__osclio.html#ggafda4e74c3c2e515d7fe98eb208a122eca58149e858cbffc8e9be4813c2e16dc76">OSCL_FILEMGMT_E_ALREADY_EXISTS</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggafda4e74c3c2e515d7fe98eb208a122ecad3d85adddf4b34dc71e6f0403e7752ef">OSCL_FILEMGMT_E_NOT_EMPTY</a>, 
<a class="el" href="group__osclio.html#ggafda4e74c3c2e515d7fe98eb208a122ecacceb3895de13c5f26348d8ea20fda20e">OSCL_FILEMGMT_E_PERMISSION_DENIED</a>, 
<a class="el" href="group__osclio.html#ggafda4e74c3c2e515d7fe98eb208a122eca3ec7f1bcf6d917255006c8a2793ade36">OSCL_FILEMGMT_E_NO_MATCH</a>, 
<a class="el" href="group__osclio.html#ggafda4e74c3c2e515d7fe98eb208a122eca370e9651fce8bd4cace1ccd33e399109">OSCL_FILEMGMT_E_UNKNOWN</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggafda4e74c3c2e515d7fe98eb208a122eca4a48f0d00e48d953e66b6153b630aa05">OSCL_FILEMGMT_E_SYS_SPECIFIC</a>, 
<a class="el" href="group__osclio.html#ggafda4e74c3c2e515d7fe98eb208a122ecaa809843513a143a68edcf6b23fd63902">OSCL_FILEMGMT_E_NOT_IMPLEMENTED</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gab57919719a32e6500ea77326ebd0ead2">TOsclFileOp</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a4d73135b6381fdd9b72d5f5ef9b8aa65">EOsclFileOp_Open</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a7a1d566f2a3cf4b63b91fb8828ced2cb">EOsclFileOp_Close</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a02324b884276d2801a9c71c3b5f471d1">EOsclFileOp_Read</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2add3499cad491475281992fe9e8f1cef9">EOsclFileOp_Write</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2ad61ef69bb00124794f6b16410be731a9">EOsclFileOp_Seek</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2aa0ce6af1533dbd6263397349d89e41be">EOsclFileOp_Tell</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a2c409421c75d4c04bafb704fe8462933">EOsclFileOp_Size</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a34641b8ddee22210ff64faebc3acbfa4">EOsclFileOp_Flush</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a1790a176a4db22bce7bdb8047c034b48">EOsclFileOp_EndOfFile</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a7512db5af532df740c8bccebc1b75a57">EOsclFileOp_SetSize</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a35ca9022e2cb87a660027cf5836c0c5d">EOsclFileOp_NativeOpen</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a11f1c3f214d11d857a810705c1bfc398">EOsclFileOp_NativeClose</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a110a08488e3da15b8b84888472b54c53">EOsclFileOp_NativeRead</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a5aff3d32dbbb7688d3d347ae01664cf2">EOsclFileOp_NativeWrite</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a1a1a7439c54dd074f90131d28e6b35bd">EOsclFileOp_NativeSeek</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a537632359b5a3ea69ee66e54f8e7df53">EOsclFileOp_NativeTell</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a97fcd6544f8e5152cd6c398edf2bd5a9">EOsclFileOp_NativeSize</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a840fa69346fe8fc716ba08abb6a36f07">EOsclFileOp_NativeFlush</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a27f8a923bc526a10c9f1ddd4bdb9ca1a">EOsclFileOp_NativeEndOfFile</a>, 
<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a5188475e9abbdce86b1c3ccaf3b26848">EOsclFileOp_NativeSetSize</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__osclio.html#ggab57919719a32e6500ea77326ebd0ead2a351436e153b68764e4c0b4a7b8740051">EOsclFileOp_Last</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gae997bbfea8829462b81ddc4b974add2b">OsclDNSObserver::~OsclDNSObserver</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga1927b35ee5c4bc6adfdef7f01b182897">OsclDNS::~OsclDNS</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gace3a79456572c0e719f50c8c6dc5e445">TPVDNSEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaad581e3dda431098613777866028ab96">OsclDNS::GetHostByName</a> (char *name, <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;addr, int32 aTimeoutMsec=-1, <a class="el" href="classOscl__Vector.html">Oscl_Vector</a>&lt; <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a>, <a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a> &gt; *aAddressList=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gad348a427cf626160032aa639ac8c754c">OsclDNS::CancelGetHostByName</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga2bc7efb52bb8dee8917c7adbf4ef24b6">oscl_getcwd</a> (<a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *path, uint32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga41a6da28d3ff48a0e615ca4d6322ffee">oscl_getcwd</a> (char *path, uint32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga443f52de8bedde5a071ad87c426ef131">oscl_stat</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *path, <a class="el" href="structoscl__stat__buf.html">OSCL_STAT_BUF</a> *statbuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga4e5f924dd4667dd5e8c6c60b75b8a2d7">oscl_stat</a> (const char *path, <a class="el" href="structoscl__stat__buf.html">OSCL_STAT_BUF</a> *statbuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga8f17a70f485d19b5b768ac0a1d6843ae">oscl_mkdir</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaff3611d4092f372317656781e7d5b797">oscl_mkdir</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga02b42e610423bddc3edbb097e8dca1c2">oscl_rmdir</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga329cab5bdaaf83030d38e91395c3735e">oscl_rmdir</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga381ada8249458dc8cbea3a342626ad1d">oscl_chdir</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gab1ed6fce17c156d6cae5e535be0f12bc">oscl_chdir</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga8df0b978cebdc8aa6ca37b0d43e2a0b7">oscl_rename</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *oldpath, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *newpath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gad93087898bd02d2b996c5929178c2364">oscl_rename</a> (const char *oldpath, const char *newpath)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga2b3e9ca3d28210d73cab754fe4e7ab03">oscl_statfs</a> (<a class="el" href="structoscl__fsstat.html">OSCL_FSSTAT</a> *stats, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <br class="typebreak"/>
<a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga0be8ad3dde38b008e08764176e523485">oscl_statfs</a> (<a class="el" href="structoscl__fsstat.html">OSCL_FSSTAT</a> *stats, const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaba6522090b7b5a78998a36d8ed7b1237">OsclFileManager::OsclGetFileSize</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *aFileName, <a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;aFileSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaac148a62141861bab680b3339ba3600f">OsclFileManager::OsclGetFileSize</a> (const char *aFileName, <a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;aFileSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gae2b79e8a5579e1d7e28fb50e4ed286f7">OsclFileManager::OsclGetFileCreationTime</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *aFileName, <a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;aFileCreationTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga4f0dbbab4893c2b6a10246700201e444">OsclFileManager::OsclGetFileCreationTime</a> (const char *aFileName, <a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;aFileCreationTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga4a4996a2ff4db67540d97369f1a5c738">OsclFileManager::OsclGetFileLastAccessTime</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *aFileName, <a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;aFileLastAccessTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gad52a64804fc70ec5b4d7835174a42cc1">OsclFileManager::OsclGetFileLastAccessTime</a> (const char *aFileName, <a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;aFileLastAccessTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga9302cb14b69eeab0f6dfc9261b93b1fe">OsclFileManager::OsclGetFileLastWriteTime</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *aFileName, <a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;aFileLastWriteTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gabc4c45149243a1796a90d9602e75ac84">OsclFileManager::OsclGetFileLastWriteTime</a> (const char *aFileName, <a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;aFileLastWriteTime)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gac2830d0799bfe091c8a2be2d65c18bf9">OsclFileManager::OsclGetFileAttributes</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *aFileName, uint32 &amp;aFileAttributes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga721199d65708e93b523a0fcb364f9d5d">OsclFileManager::OsclGetFileAttributes</a> (const char *aFileName, uint32 &amp;aFileAttributes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga5c788c54dcb64dc454f55ea6a3807901">OsclFileManager::OsclExtractFilenameFromFullpath</a> (const char *aPath, char *&amp;aFileName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga8084cf400b20611f0734e2735c35da74">OsclFileManager::OsclExtractFilenameFromFullpath</a> (const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *aPath, <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&amp;aFileName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga3fb374cb35b513b0a5924b57cb5203d0">OsclSocketServ::~OsclSocketServ</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaa35288a232ec50d00d2af1dcb45f045d">OsclSocketServ::Connect</a> (uint32 aMessageSlots=8, bool aShareSession=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga168827012df20b4d8c58df5325ea840b">OsclSocketServ::Close</a> (bool aCleanup=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga99c2fa6315fd3eaa9e6db973711ddfe2">OsclUDPSocket::~OsclUDPSocket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga3fe7acbcdf4a566674373c1f60026a3f">OsclUDPSocket::ThreadLogoff</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga77e00f9b14152cbed823c9c2dc78a04d">OsclUDPSocket::ThreadLogon</a> (<a class="el" href="classOsclSocketServ.html">OsclSocketServ</a> &amp;aServ, <a class="el" href="classOsclSocketObserver.html">OsclSocketObserver</a> *aObserver)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga6af4ec626847c0033f6f24edba19a99e">OsclUDPSocket::Close</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gadcbdc19782cf47648f2c715b469666bb">OsclUDPSocket::Bind</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga94c337431bf2f2f72080ddf53da4fac6">OsclUDPSocket::Join</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga8ec575e879ac04ddf42d046f63d7c9d2">OsclUDPSocket::JoinMulticastGroup</a> (<a class="el" href="classOsclIpMReq.html">OsclIpMReq</a> &amp;aMReq)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gac00c21980321fea528fb5df2d14a0f47">OsclUDPSocket::SetMulticastTTL</a> (int32 aTTL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gac4c76afc19ae7618ea26a42c19780596">OsclUDPSocket::SetOptionToReuseAddress</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga7958f0f8e126f2b446d296db0e7e4c25">OsclUDPSocket::SetTOS</a> (const <a class="el" href="classOsclSocketTOS.html">OsclSocketTOS</a> &amp;aTOS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga916a411261398d6a12593db8c96afead">OsclUDPSocket::GetPeerName</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aPeerName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga1141dae2e5a2101bbca5713bda38ce5d">OsclUDPSocket::BindAsync</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress, int32 aTimeoutMsec=(-1))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gafebea9c5f94e43e2fa587ade4e312b1d">OsclUDPSocket::CancelBind</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF uint8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gab93aebf35aba1e905b795f118f04acc3">OsclUDPSocket::GetRecvData</a> (int32 *aLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF uint8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaf2166930bc48ed800ae4150f7ce86856">OsclUDPSocket::GetSendData</a> (int32 *aLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga4a7a37303c08165ce2e138cea27e4d6b">OsclUDPSocket::SendTo</a> (const uint8 *aPtr, uint32 aLen, <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress, int32 aTimeoutMsec=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gabd049538b3956f3d5f8c3c7906537542">OsclUDPSocket::CancelSendTo</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gad9123451a17f421108b54fd180d8d1b9">OsclUDPSocket::RecvFrom</a> (uint8 *aPtr, uint32 aMaxLen, <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress, int32 aTimeoutMsec=-1, uint32 aMultiRecvLimit=0, <a class="el" href="classOscl__Vector.html">Oscl_Vector</a>&lt; uint32, <a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a> &gt; *aPacketLen=NULL, <a class="el" href="classOscl__Vector.html">Oscl_Vector</a>&lt; <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a>, <a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a> &gt; *aPacketSource=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga4fcf8e672d7bd375c48fa5979685a2db">OsclUDPSocket::CancelRecvFrom</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga97f4499e970575572b7c55b4cf35c22e">OsclUDPSocket::SetRecvBufferSize</a> (uint32 size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga971547c10eb222fbb6c661b70bb90d49">OsclTCPSocket::~OsclTCPSocket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga7411e860564c17810ba143c3c5eebce6">OsclTCPSocket::ThreadLogoff</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga1a5b3d96fe0aa38ce3187c646aef91c2">OsclTCPSocket::ThreadLogon</a> (<a class="el" href="classOsclSocketServ.html">OsclSocketServ</a> &amp;aServ, <a class="el" href="classOsclSocketObserver.html">OsclSocketObserver</a> *aObserver)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaecf3d5024256b133eec7c6c646f6a5b7">OsclTCPSocket::Close</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga6487dfd0cae91eefe1324dc7d212b93b">OsclTCPSocket::Bind</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga7c552f2030354da0af4cbe723b94a97d">OsclTCPSocket::BindAsync</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress, int32 aTimeoutMsec=(-1))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga783aa02d66b4c669517250857f607a93">OsclTCPSocket::CancelBind</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga25bf7763e044061dae61dda892bcab13">OsclTCPSocket::SetOptionToReuseAddress</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gad13742c2e7d4a661dee6d53327ed4d06">OsclTCPSocket::SetTOS</a> (const <a class="el" href="classOsclSocketTOS.html">OsclSocketTOS</a> &amp;aTOS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga0a4e9b6b31a160b3aa98a3ba3d01cdef">OsclTCPSocket::GetPeerName</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aPeerName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF int32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaa3e01ad4324cb7f0a2923174dffc1bde">OsclTCPSocket::Listen</a> (int32 aQueueSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gacc374e8540b9e5519ef8a8b64f961667">OsclTCPSocket::ListenAsync</a> (int32 aQueueSize, int32 aTimeoutMsec=(-1))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaf0d3aa25c8c9601b27784040343a5018">OsclTCPSocket::CancelListen</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="classOsclTCPSocket.html">OsclTCPSocket</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga6d58ae50931a3aed80f445c58c739f7f">OsclTCPSocket::GetAcceptedSocketL</a> (uint32 aId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF uint8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga96719357e7341f5a4cdae63f5c1d945b">OsclTCPSocket::GetRecvData</a> (int32 *aLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF uint8 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaeb2599dba7f5c86d3e8884ea6ee4cc21">OsclTCPSocket::GetSendData</a> (int32 *aLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga36cd52b387788080accc341a07e26cf8">OsclTCPSocket::Connect</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress, int32 aTimeoutMsec=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga48723a7ca1a2986175c6f7b4981c90ec">OsclTCPSocket::CancelConnect</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga5422dd9b0afc3e9070658b793bc54199">OsclTCPSocket::Shutdown</a> (<a class="el" href="oscl__socket__types_8h.html#a20988040ed0794b81547c60b5ffdde79">TPVSocketShutdown</a> aHow, int32 aTimeoutMsec=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gaeb5d88816b37974ccb1dd8864c55bae2">OsclTCPSocket::CancelShutdown</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga7a82d8b67880a7a586d29cb534e0fc1c">OsclTCPSocket::Accept</a> (int32 aTimeout=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga60fa6ddef4cc9436048a74a4f648c113">OsclTCPSocket::CancelAccept</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#gac0a77f20541bcd56a7bb4dcf04338e89">OsclTCPSocket::Send</a> (const uint8 *aPtr, uint32 aLen, int32 aTimeoutMsec=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga8cd4c2f59b3c78530ef0819f52541fff">OsclTCPSocket::CancelSend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga3ec8732366c9de9a6c68be217e5b7252">OsclTCPSocket::Recv</a> (uint8 *aPtr, uint32 aMaxLen, int32 aTimeoutMsec=-1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OSCL_IMPORT_REF void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga011c9afecbedc6a76ea9a57755a6fa3d">OsclTCPSocket::CancelRecv</a> ()</td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga77adc5ae59f74e0d96a75e4e8cf92c7a">OsclDNS::OsclDNSRequestAO</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga9255278927868da5d7c4d52a813bdb97">OsclSocketServ::OsclTCPSocket</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga26914fefd8d00952630a8cce7abe26ea">OsclSocketServ::OsclUDPSocket</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__osclio.html#ga0b8f1a42d7f02ad6c457ce890a4f2c98">OsclSocketServ::OsclDNS</a></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaea100e01c32ea2162b946c08c7d8751f"></a><!-- doxytag: member="oscl_file_types.h::OSCL_FILE_CHAR_PATH_DELIMITER" ref="gaea100e01c32ea2162b946c08c7d8751f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_FILE_CHAR_PATH_DELIMITER&nbsp;&nbsp;&nbsp;_STRLIT_CHAR(&quot;/&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga34c8a106fe300de026af3c35da5d4db0"></a><!-- doxytag: member="oscl_file_stats.h::OSCL_FILE_STATS_LOGGER_NODE" ref="ga34c8a106fe300de026af3c35da5d4db0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_FILE_STATS_LOGGER_NODE&nbsp;&nbsp;&nbsp;&quot;OsclFileStats&quot;</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga684e82a8e4f55bda98caacf6a390b7ff"></a><!-- doxytag: member="oscl_file_types.h::OSCL_FILE_WCHAR_PATH_DELIMITER" ref="ga684e82a8e4f55bda98caacf6a390b7ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_FILE_WCHAR_PATH_DELIMITER&nbsp;&nbsp;&nbsp;_STRLIT(&quot;/&quot;)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5ed976264cf1003efd4a758a02d41a82"></a><!-- doxytag: member="oscl_file_types.h::OSCL_IO_EXTENSION_MAXLEN" ref="ga5ed976264cf1003efd4a758a02d41a82" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_IO_EXTENSION_MAXLEN&nbsp;&nbsp;&nbsp;512</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga586e2bacd0c3a3e75ddd4029379b237c"></a><!-- doxytag: member="oscl_file_types.h::OSCL_IO_FILENAME_MAXLEN" ref="ga586e2bacd0c3a3e75ddd4029379b237c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OSCL_IO_FILENAME_MAXLEN&nbsp;&nbsp;&nbsp;512</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga32797bf7b13b0e5a52c356af13a4eebb"></a><!-- doxytag: member="oscl_file_io.h::TOsclFileOffsetInt32" ref="ga32797bf7b13b0e5a52c356af13a4eebb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TOsclFileOffsetInt32&nbsp;&nbsp;&nbsp;int32</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gae5dc50ecd713b39db3e41c6af7120d00"></a><!-- doxytag: member="oscl_file_dir_utils.h::OSCL_FSSTAT" ref="gae5dc50ecd713b39db3e41c6af7120d00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structoscl__fsstat.html">oscl_fsstat</a>  <a class="el" href="structoscl__fsstat.html">OSCL_FSSTAT</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5f071e77b9997cac7b583968bb6c9814"></a><!-- doxytag: member="oscl_file_dir_utils.h::OSCL_STAT_BUF" ref="ga5f071e77b9997cac7b583968bb6c9814" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structoscl__stat__buf.html">oscl_stat_buf</a>  <a class="el" href="structoscl__stat__buf.html">OSCL_STAT_BUF</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9b12ccba57a60b0ed79f20652995ff5f"></a><!-- doxytag: member="oscl_file_handle.h::TOsclFileHandle" ref="ga9b12ccba57a60b0ed79f20652995ff5f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef FILE* <a class="el" href="group__osclio.html#ga9b12ccba57a60b0ed79f20652995ff5f">TOsclFileHandle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TOsclFileHandle is an OS-native file handle type. With a class-based file API such as Symbian, a class ref is used as a file handle. For most ANSI-style file APIs, a file pointer is used as a file handle. </p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="gafda4e74c3c2e515d7fe98eb208a122ec"></a><!-- doxytag: member="oscl_file_dir_utils.h::OSCL_FILEMGMT_ERR_TYPE" ref="gafda4e74c3c2e515d7fe98eb208a122ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggafda4e74c3c2e515d7fe98eb208a122eca8768938f2ff9b009ab3961f83d6354b1"></a><!-- doxytag: member="OSCL_FILEMGMT_E_OK" ref="ggafda4e74c3c2e515d7fe98eb208a122eca8768938f2ff9b009ab3961f83d6354b1" args="" -->OSCL_FILEMGMT_E_OK</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafda4e74c3c2e515d7fe98eb208a122eca85b79381e573ea7e3676ebc5e321a75a"></a><!-- doxytag: member="OSCL_FILEMGMT_E_PATH_TOO_LONG" ref="ggafda4e74c3c2e515d7fe98eb208a122eca85b79381e573ea7e3676ebc5e321a75a" args="" -->OSCL_FILEMGMT_E_PATH_TOO_LONG</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafda4e74c3c2e515d7fe98eb208a122eca6aa680854414f237de3659cb55274292"></a><!-- doxytag: member="OSCL_FILEMGMT_E_PATH_NOT_FOUND" ref="ggafda4e74c3c2e515d7fe98eb208a122eca6aa680854414f237de3659cb55274292" args="" -->OSCL_FILEMGMT_E_PATH_NOT_FOUND</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafda4e74c3c2e515d7fe98eb208a122eca58149e858cbffc8e9be4813c2e16dc76"></a><!-- doxytag: member="OSCL_FILEMGMT_E_ALREADY_EXISTS" ref="ggafda4e74c3c2e515d7fe98eb208a122eca58149e858cbffc8e9be4813c2e16dc76" args="" -->OSCL_FILEMGMT_E_ALREADY_EXISTS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafda4e74c3c2e515d7fe98eb208a122ecad3d85adddf4b34dc71e6f0403e7752ef"></a><!-- doxytag: member="OSCL_FILEMGMT_E_NOT_EMPTY" ref="ggafda4e74c3c2e515d7fe98eb208a122ecad3d85adddf4b34dc71e6f0403e7752ef" args="" -->OSCL_FILEMGMT_E_NOT_EMPTY</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafda4e74c3c2e515d7fe98eb208a122ecacceb3895de13c5f26348d8ea20fda20e"></a><!-- doxytag: member="OSCL_FILEMGMT_E_PERMISSION_DENIED" ref="ggafda4e74c3c2e515d7fe98eb208a122ecacceb3895de13c5f26348d8ea20fda20e" args="" -->OSCL_FILEMGMT_E_PERMISSION_DENIED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafda4e74c3c2e515d7fe98eb208a122eca3ec7f1bcf6d917255006c8a2793ade36"></a><!-- doxytag: member="OSCL_FILEMGMT_E_NO_MATCH" ref="ggafda4e74c3c2e515d7fe98eb208a122eca3ec7f1bcf6d917255006c8a2793ade36" args="" -->OSCL_FILEMGMT_E_NO_MATCH</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafda4e74c3c2e515d7fe98eb208a122eca370e9651fce8bd4cace1ccd33e399109"></a><!-- doxytag: member="OSCL_FILEMGMT_E_UNKNOWN" ref="ggafda4e74c3c2e515d7fe98eb208a122eca370e9651fce8bd4cace1ccd33e399109" args="" -->OSCL_FILEMGMT_E_UNKNOWN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafda4e74c3c2e515d7fe98eb208a122eca4a48f0d00e48d953e66b6153b630aa05"></a><!-- doxytag: member="OSCL_FILEMGMT_E_SYS_SPECIFIC" ref="ggafda4e74c3c2e515d7fe98eb208a122eca4a48f0d00e48d953e66b6153b630aa05" args="" -->OSCL_FILEMGMT_E_SYS_SPECIFIC</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggafda4e74c3c2e515d7fe98eb208a122ecaa809843513a143a68edcf6b23fd63902"></a><!-- doxytag: member="OSCL_FILEMGMT_E_NOT_IMPLEMENTED" ref="ggafda4e74c3c2e515d7fe98eb208a122ecaa809843513a143a68edcf6b23fd63902" args="" -->OSCL_FILEMGMT_E_NOT_IMPLEMENTED</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8d312a40a46ddafab591e2300e395293"></a><!-- doxytag: member="oscl_file_dir_utils.h::OSCL_FILEMGMT_MODES" ref="ga8d312a40a46ddafab591e2300e395293" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__osclio.html#ga8d312a40a46ddafab591e2300e395293">OSCL_FILEMGMT_MODES</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga8d312a40a46ddafab591e2300e395293adbad29875c83ddef177efc34518c6ea5"></a><!-- doxytag: member="OSCL_FILEMGMT_MODE_DIR" ref="gga8d312a40a46ddafab591e2300e395293adbad29875c83ddef177efc34518c6ea5" args="" -->OSCL_FILEMGMT_MODE_DIR</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0a6210100e2b9b5d8edf7f416b2d11c7"></a><!-- doxytag: member="oscl_file_dir_utils.h::OSCL_FILEMGMT_PERMS" ref="ga0a6210100e2b9b5d8edf7f416b2d11c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__osclio.html#ga0a6210100e2b9b5d8edf7f416b2d11c7">OSCL_FILEMGMT_PERMS</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga0a6210100e2b9b5d8edf7f416b2d11c7a45fb43584780f3bd39219d3c1cfb5054"></a><!-- doxytag: member="OSCL_FILEMGMT_PERMS_READ" ref="gga0a6210100e2b9b5d8edf7f416b2d11c7a45fb43584780f3bd39219d3c1cfb5054" args="" -->OSCL_FILEMGMT_PERMS_READ</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0a6210100e2b9b5d8edf7f416b2d11c7a5f4b59b4b75917c1df0fa70e8a062888"></a><!-- doxytag: member="OSCL_FILEMGMT_PERMS_WRITE" ref="gga0a6210100e2b9b5d8edf7f416b2d11c7a5f4b59b4b75917c1df0fa70e8a062888" args="" -->OSCL_FILEMGMT_PERMS_WRITE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0a6210100e2b9b5d8edf7f416b2d11c7ac949805558cfabe7b89d0b25dd915621"></a><!-- doxytag: member="OSCL_FILEMGMT_PERMS_EXECUTE" ref="gga0a6210100e2b9b5d8edf7f416b2d11c7ac949805558cfabe7b89d0b25dd915621" args="" -->OSCL_FILEMGMT_PERMS_EXECUTE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gab57919719a32e6500ea77326ebd0ead2"></a><!-- doxytag: member="oscl_file_stats.h::TOsclFileOp" ref="gab57919719a32e6500ea77326ebd0ead2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__osclio.html#gab57919719a32e6500ea77326ebd0ead2">TOsclFileOp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a4d73135b6381fdd9b72d5f5ef9b8aa65"></a><!-- doxytag: member="EOsclFileOp_Open" ref="ggab57919719a32e6500ea77326ebd0ead2a4d73135b6381fdd9b72d5f5ef9b8aa65" args="" -->EOsclFileOp_Open</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a7a1d566f2a3cf4b63b91fb8828ced2cb"></a><!-- doxytag: member="EOsclFileOp_Close" ref="ggab57919719a32e6500ea77326ebd0ead2a7a1d566f2a3cf4b63b91fb8828ced2cb" args="" -->EOsclFileOp_Close</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a02324b884276d2801a9c71c3b5f471d1"></a><!-- doxytag: member="EOsclFileOp_Read" ref="ggab57919719a32e6500ea77326ebd0ead2a02324b884276d2801a9c71c3b5f471d1" args="" -->EOsclFileOp_Read</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2add3499cad491475281992fe9e8f1cef9"></a><!-- doxytag: member="EOsclFileOp_Write" ref="ggab57919719a32e6500ea77326ebd0ead2add3499cad491475281992fe9e8f1cef9" args="" -->EOsclFileOp_Write</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2ad61ef69bb00124794f6b16410be731a9"></a><!-- doxytag: member="EOsclFileOp_Seek" ref="ggab57919719a32e6500ea77326ebd0ead2ad61ef69bb00124794f6b16410be731a9" args="" -->EOsclFileOp_Seek</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2aa0ce6af1533dbd6263397349d89e41be"></a><!-- doxytag: member="EOsclFileOp_Tell" ref="ggab57919719a32e6500ea77326ebd0ead2aa0ce6af1533dbd6263397349d89e41be" args="" -->EOsclFileOp_Tell</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a2c409421c75d4c04bafb704fe8462933"></a><!-- doxytag: member="EOsclFileOp_Size" ref="ggab57919719a32e6500ea77326ebd0ead2a2c409421c75d4c04bafb704fe8462933" args="" -->EOsclFileOp_Size</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a34641b8ddee22210ff64faebc3acbfa4"></a><!-- doxytag: member="EOsclFileOp_Flush" ref="ggab57919719a32e6500ea77326ebd0ead2a34641b8ddee22210ff64faebc3acbfa4" args="" -->EOsclFileOp_Flush</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a1790a176a4db22bce7bdb8047c034b48"></a><!-- doxytag: member="EOsclFileOp_EndOfFile" ref="ggab57919719a32e6500ea77326ebd0ead2a1790a176a4db22bce7bdb8047c034b48" args="" -->EOsclFileOp_EndOfFile</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a7512db5af532df740c8bccebc1b75a57"></a><!-- doxytag: member="EOsclFileOp_SetSize" ref="ggab57919719a32e6500ea77326ebd0ead2a7512db5af532df740c8bccebc1b75a57" args="" -->EOsclFileOp_SetSize</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a35ca9022e2cb87a660027cf5836c0c5d"></a><!-- doxytag: member="EOsclFileOp_NativeOpen" ref="ggab57919719a32e6500ea77326ebd0ead2a35ca9022e2cb87a660027cf5836c0c5d" args="" -->EOsclFileOp_NativeOpen</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a11f1c3f214d11d857a810705c1bfc398"></a><!-- doxytag: member="EOsclFileOp_NativeClose" ref="ggab57919719a32e6500ea77326ebd0ead2a11f1c3f214d11d857a810705c1bfc398" args="" -->EOsclFileOp_NativeClose</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a110a08488e3da15b8b84888472b54c53"></a><!-- doxytag: member="EOsclFileOp_NativeRead" ref="ggab57919719a32e6500ea77326ebd0ead2a110a08488e3da15b8b84888472b54c53" args="" -->EOsclFileOp_NativeRead</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a5aff3d32dbbb7688d3d347ae01664cf2"></a><!-- doxytag: member="EOsclFileOp_NativeWrite" ref="ggab57919719a32e6500ea77326ebd0ead2a5aff3d32dbbb7688d3d347ae01664cf2" args="" -->EOsclFileOp_NativeWrite</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a1a1a7439c54dd074f90131d28e6b35bd"></a><!-- doxytag: member="EOsclFileOp_NativeSeek" ref="ggab57919719a32e6500ea77326ebd0ead2a1a1a7439c54dd074f90131d28e6b35bd" args="" -->EOsclFileOp_NativeSeek</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a537632359b5a3ea69ee66e54f8e7df53"></a><!-- doxytag: member="EOsclFileOp_NativeTell" ref="ggab57919719a32e6500ea77326ebd0ead2a537632359b5a3ea69ee66e54f8e7df53" args="" -->EOsclFileOp_NativeTell</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a97fcd6544f8e5152cd6c398edf2bd5a9"></a><!-- doxytag: member="EOsclFileOp_NativeSize" ref="ggab57919719a32e6500ea77326ebd0ead2a97fcd6544f8e5152cd6c398edf2bd5a9" args="" -->EOsclFileOp_NativeSize</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a840fa69346fe8fc716ba08abb6a36f07"></a><!-- doxytag: member="EOsclFileOp_NativeFlush" ref="ggab57919719a32e6500ea77326ebd0ead2a840fa69346fe8fc716ba08abb6a36f07" args="" -->EOsclFileOp_NativeFlush</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a27f8a923bc526a10c9f1ddd4bdb9ca1a"></a><!-- doxytag: member="EOsclFileOp_NativeEndOfFile" ref="ggab57919719a32e6500ea77326ebd0ead2a27f8a923bc526a10c9f1ddd4bdb9ca1a" args="" -->EOsclFileOp_NativeEndOfFile</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a5188475e9abbdce86b1c3ccaf3b26848"></a><!-- doxytag: member="EOsclFileOp_NativeSetSize" ref="ggab57919719a32e6500ea77326ebd0ead2a5188475e9abbdce86b1c3ccaf3b26848" args="" -->EOsclFileOp_NativeSetSize</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggab57919719a32e6500ea77326ebd0ead2a351436e153b68764e4c0b4a7b8740051"></a><!-- doxytag: member="EOsclFileOp_Last" ref="ggab57919719a32e6500ea77326ebd0ead2a351436e153b68764e4c0b4a7b8740051" args="" -->EOsclFileOp_Last</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="gace3a79456572c0e719f50c8c6dc5e445"></a><!-- doxytag: member="oscl_dns.h::TPVDNSEvent" ref="gace3a79456572c0e719f50c8c6dc5e445" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__osclio.html#gace3a79456572c0e719f50c8c6dc5e445">TPVDNSEvent</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggace3a79456572c0e719f50c8c6dc5e445aaaadce1ec5e87f8253ceb7f5e749959b"></a><!-- doxytag: member="EPVDNSSuccess" ref="ggace3a79456572c0e719f50c8c6dc5e445aaaadce1ec5e87f8253ceb7f5e749959b" args="" -->EPVDNSSuccess</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggace3a79456572c0e719f50c8c6dc5e445ab79a27c87cf50ae28c2d3d76e500c235"></a><!-- doxytag: member="EPVDNSPending" ref="ggace3a79456572c0e719f50c8c6dc5e445ab79a27c87cf50ae28c2d3d76e500c235" args="" -->EPVDNSPending</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggace3a79456572c0e719f50c8c6dc5e445a4a1c212c698220cae749737b69bc0e99"></a><!-- doxytag: member="EPVDNSTimeout" ref="ggace3a79456572c0e719f50c8c6dc5e445a4a1c212c698220cae749737b69bc0e99" args="" -->EPVDNSTimeout</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggace3a79456572c0e719f50c8c6dc5e445abb532d737fe56e0128da89da0898b0ec"></a><!-- doxytag: member="EPVDNSFailure" ref="ggace3a79456572c0e719f50c8c6dc5e445abb532d737fe56e0128da89da0898b0ec" args="" -->EPVDNSFailure</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggace3a79456572c0e719f50c8c6dc5e445a2d11589798258a79b7b05240110c03ef"></a><!-- doxytag: member="EPVDNSCancel" ref="ggace3a79456572c0e719f50c8c6dc5e445a2d11589798258a79b7b05240110c03ef" args="" -->EPVDNSCancel</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c2ea6404a214241178a4ca83f9d9a7c"></a><!-- doxytag: member="oscl_dns.h::TPVDNSFxn" ref="ga8c2ea6404a214241178a4ca83f9d9a7c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__osclio.html#ga8c2ea6404a214241178a4ca83f9d9a7c">TPVDNSFxn</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga8c2ea6404a214241178a4ca83f9d9a7ca5cd080e81647c4dfe2332aa3fb119f74"></a><!-- doxytag: member="EPVDNSGetHostByName" ref="gga8c2ea6404a214241178a4ca83f9d9a7ca5cd080e81647c4dfe2332aa3fb119f74" args="" -->EPVDNSGetHostByName</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga7a82d8b67880a7a586d29cb534e0fc1c"></a><!-- doxytag: member="OsclTCPSocket::Accept" ref="ga7a82d8b67880a7a586d29cb534e0fc1c" args="(int32 aTimeout=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclTCPSocket::Accept </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeout</em> = <code>-1</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accept incoming connections. This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6487dfd0cae91eefe1324dc7d212b93b"></a><!-- doxytag: member="OsclTCPSocket::Bind" ref="ga6487dfd0cae91eefe1324dc7d212b93b" args="(OsclNetworkAddress &amp;aAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclTCPSocket::Bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aAddress</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bind a TCP socket to an address. This is a synchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aAddress,:</em>&nbsp;</td><td>Bind address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns OsclErrNone for success, or a platform-specific error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gadcbdc19782cf47648f2c715b469666bb"></a><!-- doxytag: member="OsclUDPSocket::Bind" ref="gadcbdc19782cf47648f2c715b469666bb" args="(OsclNetworkAddress &amp;aAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclUDPSocket::Bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aAddress</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bind a UDP socket to an address. This is a synchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aAddress,:</em>&nbsp;</td><td>Bind address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns OsclErrNone for success, or a platform-specific error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7c552f2030354da0af4cbe723b94a97d"></a><!-- doxytag: member="OsclTCPSocket::BindAsync" ref="ga7c552f2030354da0af4cbe723b94a97d" args="(OsclNetworkAddress &amp;aAddress, int32 aTimeoutMsec=(&#45;1))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclTCPSocket::BindAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeoutMsec</em> = <code>(-1)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bind a TCP socket to an address. This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aAddress,:</em>&nbsp;</td><td>Bind address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>Optional timeout. Use a negative value for infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1141dae2e5a2101bbca5713bda38ce5d"></a><!-- doxytag: member="OsclUDPSocket::BindAsync" ref="ga1141dae2e5a2101bbca5713bda38ce5d" args="(OsclNetworkAddress &amp;aAddress, int32 aTimeoutMsec=(&#45;1))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclUDPSocket::BindAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeoutMsec</em> = <code>(-1)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bind a UDP socket to an address. This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aAddress,:</em>&nbsp;</td><td>Bind address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>Optional timeout. Use a negative value for infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dd></dl>

</div>
</div>
<a class="anchor" id="ga60fa6ddef4cc9436048a74a4f648c113"></a><!-- doxytag: member="OsclTCPSocket::CancelAccept" ref="ga60fa6ddef4cc9436048a74a4f648c113" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclTCPSocket::CancelAccept </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel Accept</p>
<p>This method will cancel any pending Accept operation on the current socket, causing the Accept to complete with error EPVSocketCancel. If there is no pending Accept operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="ga783aa02d66b4c669517250857f607a93"></a><!-- doxytag: member="OsclTCPSocket::CancelBind" ref="ga783aa02d66b4c669517250857f607a93" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclTCPSocket::CancelBind </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel Bind</p>
<p>This method will cancel any pending BindAsync operation on the current socket, causing the BindAsync to complete with error EPVSocketCancel. If there is no pending BindAsync operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="gafebea9c5f94e43e2fa587ade4e312b1d"></a><!-- doxytag: member="OsclUDPSocket::CancelBind" ref="gafebea9c5f94e43e2fa587ade4e312b1d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclUDPSocket::CancelBind </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel Bind</p>
<p>This method will cancel any pending BindAsync operation on the current socket, causing the BindAsync to complete with error EPVSocketCancel. If there is no pending BindAsync operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="ga48723a7ca1a2986175c6f7b4981c90ec"></a><!-- doxytag: member="OsclTCPSocket::CancelConnect" ref="ga48723a7ca1a2986175c6f7b4981c90ec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclTCPSocket::CancelConnect </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel Connect</p>
<p>This method will cancel any pending Connect operation on the current socket, causing the Connect to complete with error EPVSocketCancel. If there is no pending Connect operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="gad348a427cf626160032aa639ac8c754c"></a><!-- doxytag: member="OsclDNS::CancelGetHostByName" ref="gad348a427cf626160032aa639ac8c754c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclDNS::CancelGetHostByName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel GetHostByName</p>
<p>This method will cancel any pending GetHostByName operation on the current object, causing the GetHostByName to complete with error EPVDNSCancel. If there is no pending GetHostByName operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="gaf0d3aa25c8c9601b27784040343a5018"></a><!-- doxytag: member="OsclTCPSocket::CancelListen" ref="gaf0d3aa25c8c9601b27784040343a5018" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclTCPSocket::CancelListen </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel Async Listen</p>
<p>This method will cancel any pending ListenAsync operation on the current socket, causing the Listen to complete with error EPVSocketCancel. If there is no pending Listen operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="ga011c9afecbedc6a76ea9a57755a6fa3d"></a><!-- doxytag: member="OsclTCPSocket::CancelRecv" ref="ga011c9afecbedc6a76ea9a57755a6fa3d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclTCPSocket::CancelRecv </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel Recv</p>
<p>This method will cancel any pending Recv operation on the current socket, causing the Recv to complete with error EPVSocketCancel. If there is no pending Recv operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="ga4fcf8e672d7bd375c48fa5979685a2db"></a><!-- doxytag: member="OsclUDPSocket::CancelRecvFrom" ref="ga4fcf8e672d7bd375c48fa5979685a2db" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclUDPSocket::CancelRecvFrom </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel RecvFrom</p>
<p>This method will cancel any pending RecvFrom operation on the current socket, causing the RecvFrom to complete with error EPVSocketCancel. If there is no pending RecvFrom operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="ga8cd4c2f59b3c78530ef0819f52541fff"></a><!-- doxytag: member="OsclTCPSocket::CancelSend" ref="ga8cd4c2f59b3c78530ef0819f52541fff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclTCPSocket::CancelSend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel Send</p>
<p>This method will cancel any pending Send operation on the current socket, causing the Send to complete with error EPVSocketCancel. If there is no pending Send operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="gabd049538b3956f3d5f8c3c7906537542"></a><!-- doxytag: member="OsclUDPSocket::CancelSendTo" ref="gabd049538b3956f3d5f8c3c7906537542" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclUDPSocket::CancelSendTo </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel SendTo</p>
<p>This method will cancel any pending SendTo operation on the current socket, causing the SendTo to complete with error EPVSocketCancel. If there is no pending SendTo operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="gaeb5d88816b37974ccb1dd8864c55bae2"></a><!-- doxytag: member="OsclTCPSocket::CancelShutdown" ref="gaeb5d88816b37974ccb1dd8864c55bae2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclTCPSocket::CancelShutdown </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel Shutdown</p>
<p>This method will cancel any pending Shutdown operation on the current socket, causing the Shutdown to complete with error EPVSocketCancel. If there is no pending Shutdown operation, this method will have no effect. </p>

</div>
</div>
<a class="anchor" id="gaecf3d5024256b133eec7c6c646f6a5b7"></a><!-- doxytag: member="OsclTCPSocket::Close" ref="gaecf3d5024256b133eec7c6c646f6a5b7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclTCPSocket::Close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a TCP socket. This is a synchronous method.</p>
<p>Once it is closed a socket cannot be re-opened. Sockets are automatically closed when they are deleted. This method may be used to see any error code returned from the platform's socket close call. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns OsclErrNone for success, or a platform-specific error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6af4ec626847c0033f6f24edba19a99e"></a><!-- doxytag: member="OsclUDPSocket::Close" ref="ga6af4ec626847c0033f6f24edba19a99e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclUDPSocket::Close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a UDP socket. This is a synchronous method.</p>
<p>Once it is closed a socket cannot be re-opened. Sockets are automatically closed when they are deleted. This method may be used to see any error code returned from the platform's socket close call. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns OsclErrNone for success, or a platform-specific error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga168827012df20b4d8c58df5325ea840b"></a><!-- doxytag: member="OsclSocketServ::Close" ref="ga168827012df20b4d8c58df5325ea840b" args="(bool aCleanup=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF void OsclSocketServ::Close </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aCleanup</em> = <code>true</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close socket server. This is a synchronous method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aCleanup,:</em>&nbsp;</td><td>cleanup the socket system? the socket cleanup should only be done when all parts of the application are done using sockets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36cd52b387788080accc341a07e26cf8"></a><!-- doxytag: member="OsclTCPSocket::Connect" ref="ga36cd52b387788080accc341a07e26cf8" args="(OsclNetworkAddress &amp;aAddress, int32 aTimeoutMsec=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclTCPSocket::Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeoutMsec</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connect to an address. This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aAddress,:</em>&nbsp;</td><td>a network address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa35288a232ec50d00d2af1dcb45f045d"></a><!-- doxytag: member="OsclSocketServ::Connect" ref="gaa35288a232ec50d00d2af1dcb45f045d" args="(uint32 aMessageSlots=8, bool aShareSession=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclSocketServ::Connect </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aMessageSlots</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>aShareSession</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Connect to socket server. This is a synchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Number</em>&nbsp;</td><td>of message slots. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns OsclErrNone for success, or a platform-specific code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d58ae50931a3aed80f445c58c739f7f"></a><!-- doxytag: member="OsclTCPSocket::GetAcceptedSocketL" ref="ga6d58ae50931a3aed80f445c58c739f7f" args="(uint32 aId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="classOsclTCPSocket.html">OsclTCPSocket</a>* OsclTCPSocket::GetAcceptedSocketL </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the accept socket after a successful Accept operation. This is a synchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aId,:</em>&nbsp;</td><td>Socket ID. The caller must assign an ID to each socket. The ID is used to identify the socket in observer callbacks. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns pointer to socket, or NULL if error. Note: The caller is reponsible for deleting any accepted socket that it retrieves. </dd></dl>

</div>
</div>
<a class="anchor" id="gaad581e3dda431098613777866028ab96"></a><!-- doxytag: member="OsclDNS::GetHostByName" ref="gaad581e3dda431098613777866028ab96" args="(char *name, OsclNetworkAddress &amp;addr, int32 aTimeoutMsec=&#45;1, Oscl_Vector&lt; OsclNetworkAddress, OsclMemAllocator &gt; *aAddressList=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gace3a79456572c0e719f50c8c6dc5e445">TPVDNSEvent</a> OsclDNS::GetHostByName </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeoutMsec</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOscl__Vector.html">Oscl_Vector</a>&lt; <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a>, <a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>aAddressList</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>GetHostByName. This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name,:</em>&nbsp;</td><td>Null-terminated string containing the host name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr,:</em>&nbsp;</td><td>The output address corresponding to the host. The ipAddr field will contain the network address of the host in dotted decimal notation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>A timeout for the request in milliseconds, or (-1) to indicate infinite wait. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aAddressList</em>&nbsp;</td><td>: A list of addresses for the host. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>: EPVDNSPending for success, EPVDNSFailure for failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a4e9b6b31a160b3aa98a3ba3d01cdef"></a><!-- doxytag: member="OsclTCPSocket::GetPeerName" ref="ga0a4e9b6b31a160b3aa98a3ba3d01cdef" args="(OsclNetworkAddress &amp;aPeerName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclTCPSocket::GetPeerName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aPeerName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the peer address of the socket </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aPeerName,:</em>&nbsp;</td><td>This will store the peer address when API returns successfully. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns OsclErrNone for success, or a platform-specific error code. or PVSOCK_ERR_NOT_IMPLEMENTED, if this API is not implemented in OSCL for the underlying OS </dd></dl>

</div>
</div>
<a class="anchor" id="ga916a411261398d6a12593db8c96afead"></a><!-- doxytag: member="OsclUDPSocket::GetPeerName" ref="ga916a411261398d6a12593db8c96afead" args="(OsclNetworkAddress &amp;aPeerName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclUDPSocket::GetPeerName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aPeerName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the peer address of the socket </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aPeerName,:</em>&nbsp;</td><td>This will store the peer address when API returns successfully. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns OsclErrNone for success, or a platform-specific error code. or PVSOCK_ERR_NOT_IMPLEMENTED, if this API is not implemented in OSCL for the underlying OS </dd></dl>

</div>
</div>
<a class="anchor" id="ga96719357e7341f5a4cdae63f5c1d945b"></a><!-- doxytag: member="OsclTCPSocket::GetRecvData" ref="ga96719357e7341f5a4cdae63f5c1d945b" args="(int32 *aLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF uint8* OsclTCPSocket::GetRecvData </td>
          <td>(</td>
          <td class="paramtype">int32 *&nbsp;</td>
          <td class="paramname"> <em>aLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the received data after a successful Recv operation. This is a synchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aLength,:</em>&nbsp;</td><td>(output) number of bytes of data received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns pointer to received data, or NULL if none. </dd></dl>

</div>
</div>
<a class="anchor" id="gab93aebf35aba1e905b795f118f04acc3"></a><!-- doxytag: member="OsclUDPSocket::GetRecvData" ref="gab93aebf35aba1e905b795f118f04acc3" args="(int32 *aLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF uint8* OsclUDPSocket::GetRecvData </td>
          <td>(</td>
          <td class="paramtype">int32 *&nbsp;</td>
          <td class="paramname"> <em>aLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the received data after a successful RecvFrom operation. This is a synchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aLength,:</em>&nbsp;</td><td>(output) number of bytes of data received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns pointer to received data, or NULL if none. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb2599dba7f5c86d3e8884ea6ee4cc21"></a><!-- doxytag: member="OsclTCPSocket::GetSendData" ref="gaeb2599dba7f5c86d3e8884ea6ee4cc21" args="(int32 *aLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF uint8* OsclTCPSocket::GetSendData </td>
          <td>(</td>
          <td class="paramtype">int32 *&nbsp;</td>
          <td class="paramname"> <em>aLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the sent data after a successful Send operation. This is a synchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aLength,:</em>&nbsp;</td><td>(output) number of bytes of data sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns pointer to sent data, or NULL if none. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2166930bc48ed800ae4150f7ce86856"></a><!-- doxytag: member="OsclUDPSocket::GetSendData" ref="gaf2166930bc48ed800ae4150f7ce86856" args="(int32 *aLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF uint8* OsclUDPSocket::GetSendData </td>
          <td>(</td>
          <td class="paramtype">int32 *&nbsp;</td>
          <td class="paramname"> <em>aLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the sent data after a successful SendTo operation. This is a synchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aLength,:</em>&nbsp;</td><td>(output) number of bytes of data sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns pointer to sent data, or NULL if none. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94c337431bf2f2f72080ddf53da4fac6"></a><!-- doxytag: member="OsclUDPSocket::Join" ref="ga94c337431bf2f2f72080ddf53da4fac6" args="(OsclNetworkAddress &amp;aAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclUDPSocket::Join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aAddress</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bind a UDP socket to an address and Join the multicast group. This is a synchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aAddress,:</em>&nbsp;</td><td>Bind address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns OsclErrNone for success, or a platform-specific error code. May throw an OsclErrNotSupported Exception </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ec575e879ac04ddf42d046f63d7c9d2"></a><!-- doxytag: member="OsclUDPSocket::JoinMulticastGroup" ref="ga8ec575e879ac04ddf42d046f63d7c9d2" args="(OsclIpMReq &amp;aMReq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclUDPSocket::JoinMulticastGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclIpMReq.html">OsclIpMReq</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aMReq</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Join the multicast group. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aMReq,:</em>&nbsp;</td><td>Multicast group information. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns: OsclErrNone for success, or a platform-specific error code. or PVSOCK_ERR_NOT_SUPPORTED, if underlying OS doesn't support joining multicast group PVSOCK_ERR_BAD_PARAM, if config io file is not configured in accordance with underlying OS PVSOCK_ERR_NOT_IMPLEMENTED, if this API is not implemented in OSCL for the underlying OS </dd></dl>

</div>
</div>
<a class="anchor" id="gaa3e01ad4324cb7f0a2923174dffc1bde"></a><!-- doxytag: member="OsclTCPSocket::Listen" ref="gaa3e01ad4324cb7f0a2923174dffc1bde" args="(int32 aQueueSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclTCPSocket::Listen </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aQueueSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Listen. This is a synchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aQueueSize,:</em>&nbsp;</td><td>Queue size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns OsclErrNone for success, or a platform-specific error code. </dd></dl>

</div>
</div>
<a class="anchor" id="gacc374e8540b9e5519ef8a8b64f961667"></a><!-- doxytag: member="OsclTCPSocket::ListenAsync" ref="gacc374e8540b9e5519ef8a8b64f961667" args="(int32 aQueueSize, int32 aTimeoutMsec=(&#45;1))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclTCPSocket::ListenAsync </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aQueueSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeoutMsec</em> = <code>(-1)</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ListenAsync This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aQueueSize,:</em>&nbsp;</td><td>Queue size. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>Optional timeout. Use a negative value for infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dd></dl>

</div>
</div>
<a class="anchor" id="gab1ed6fce17c156d6cae5e535be0f12bc"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_chdir" ref="gab1ed6fce17c156d6cae5e535be0f12bc" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_chdir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_chdir changes the current directory to the path given </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>character</em>&nbsp;</td><td>path the full path of the directory to change to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga381ada8249458dc8cbea3a342626ad1d"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_chdir" ref="ga381ada8249458dc8cbea3a342626ad1d" args="(const oscl_wchar *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_chdir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_chdir changes the current directory to the path given </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wide</em>&nbsp;</td><td>character path the full path of the directory to change to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga41a6da28d3ff48a0e615ca4d6322ffee"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_getcwd" ref="ga41a6da28d3ff48a0e615ca4d6322ffee" args="(char *path, uint32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_getcwd </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_getcwd function can be used to determine the full path name of the current directory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pointer</em>&nbsp;</td><td>to character buffer to receive the current directory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of buffer in characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bc7efb52bb8dee8917c7adbf4ef24b6"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_getcwd" ref="ga2bc7efb52bb8dee8917c7adbf4ef24b6" args="(oscl_wchar *path, uint32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_getcwd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_getcwd function can be used to determine the full path name of the current directory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pointer</em>&nbsp;</td><td>to wide character buffer to receive the current directory </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>size of buffer in wide characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff3611d4092f372317656781e7d5b797"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_mkdir" ref="gaff3611d4092f372317656781e7d5b797" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_mkdir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_mkdir function creates a directory in the path given </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>character</em>&nbsp;</td><td>path the full path of the directory to create. if parts of the path do not exist the function will fail </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f17a70f485d19b5b768ac0a1d6843ae"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_mkdir" ref="ga8f17a70f485d19b5b768ac0a1d6843ae" args="(const oscl_wchar *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_mkdir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_mkdir function creates a directory in the path given </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wide</em>&nbsp;</td><td>character path the full path of the directory to create. if parts of the path do not exist the function will fail </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="gad93087898bd02d2b996c5929178c2364"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_rename" ref="gad93087898bd02d2b996c5929178c2364" args="(const char *oldpath, const char *newpath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_rename </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>oldpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>newpath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_rmdir removes an empty directory in the path given </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>character</em>&nbsp;</td><td>path the full path of the directory to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8df0b978cebdc8aa6ca37b0d43e2a0b7"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_rename" ref="ga8df0b978cebdc8aa6ca37b0d43e2a0b7" args="(const oscl_wchar *oldpath, const oscl_wchar *newpath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_rename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>oldpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>newpath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_rename function renames a file or directory </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wide</em>&nbsp;</td><td>character path the full path of the file or directory to rename. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wide</em>&nbsp;</td><td>character path the full path the new name for the directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga329cab5bdaaf83030d38e91395c3735e"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_rmdir" ref="ga329cab5bdaaf83030d38e91395c3735e" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_rmdir </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_rmdir removes an empty directory in the path given </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>character</em>&nbsp;</td><td>path the full path of the directory to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02b42e610423bddc3edbb097e8dca1c2"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_rmdir" ref="ga02b42e610423bddc3edbb097e8dca1c2" args="(const oscl_wchar *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_rmdir </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_rmdir function removes and empty directory in the path given </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wide</em>&nbsp;</td><td>character path the full path of the directory to remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e5f924dd4667dd5e8c6c60b75b8a2d7"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_stat" ref="ga4e5f924dd4667dd5e8c6c60b75b8a2d7" args="(const char *path, OSCL_STAT_BUF *statbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_stat </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoscl__stat__buf.html">OSCL_STAT_BUF</a> *&nbsp;</td>
          <td class="paramname"> <em>statbuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_stat function can be used to determine the attributes of a file in addition to whether the file exists or not </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>character</em>&nbsp;</td><td>path the full path of the file to stat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga443f52de8bedde5a071ad87c426ef131"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_stat" ref="ga443f52de8bedde5a071ad87c426ef131" args="(const oscl_wchar *path, OSCL_STAT_BUF *statbuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_stat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structoscl__stat__buf.html">OSCL_STAT_BUF</a> *&nbsp;</td>
          <td class="paramname"> <em>statbuf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>oscl_stat function can be used to determine the attributes of a file in addition to whether the file exists or not </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wide</em>&nbsp;</td><td>character path the full path of the file to stat. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0be8ad3dde38b008e08764176e523485"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_statfs" ref="ga0be8ad3dde38b008e08764176e523485" args="(OSCL_FSSTAT *stats, const oscl_wchar *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_statfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoscl__fsstat.html">OSCL_FSSTAT</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Oscl_StatFS function populates a general structure describing free space available on a filesystem </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>pointer to structure to hold information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>located in desired filesystem (utf8) Note: If the OS does not support a particular field in the structure, it is set to -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b3e9ca3d28210d73cab754fe4e7ab03"></a><!-- doxytag: member="oscl_file_dir_utils.h::oscl_statfs" ref="ga2b3e9ca3d28210d73cab754fe4e7ab03" args="(OSCL_FSSTAT *stats, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="group__osclio.html#gafda4e74c3c2e515d7fe98eb208a122ec">OSCL_FILEMGMT_ERR_TYPE</a> oscl_statfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structoscl__fsstat.html">OSCL_FSSTAT</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>path</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Oscl_StatFS function populates a general structure describing free space available on a filesystem </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>pointer to structure to hold information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path</em>&nbsp;</td><td>located in desired filesystem (utf8) Note: If the OS does not support a particular field in the structure, it is set to -1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>OSCL_FILEMGMT_ERR_TYPE, see enumeration for this type. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8084cf400b20611f0734e2735c35da74"></a><!-- doxytag: member="OsclFileManager::OsclExtractFilenameFromFullpath" ref="ga8084cf400b20611f0734e2735c35da74" args="(const oscl_wchar *aPath, oscl_wchar *&amp;aFileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF void OsclFileManager::OsclExtractFilenameFromFullpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>aPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&amp;&nbsp;</td>
          <td class="paramname"> <em>aFileName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5c788c54dcb64dc454f55ea6a3807901"></a><!-- doxytag: member="OsclFileManager::OsclExtractFilenameFromFullpath" ref="ga5c788c54dcb64dc454f55ea6a3807901" args="(const char *aPath, char *&amp;aFileName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF void OsclFileManager::OsclExtractFilenameFromFullpath </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&nbsp;</td>
          <td class="paramname"> <em>aFileName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclExtractFilenameFromFullpath utility function provide the FileName From Path of a file. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>character</em>&nbsp;</td><td>path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>character</em>&nbsp;</td><td>FileName :file Name .It is assigned a pointer to file name in path itself.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void for all condition </dd></dl>

</div>
</div>
<a class="anchor" id="ga721199d65708e93b523a0fcb364f9d5d"></a><!-- doxytag: member="OsclFileManager::OsclGetFileAttributes" ref="ga721199d65708e93b523a0fcb364f9d5d" args="(const char *aFileName, uint32 &amp;aFileAttributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF bool OsclFileManager::OsclGetFileAttributes </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileAttributes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclGetFileAttributes utility function provides the various attributes of file (or directory) like if it is hidden, read only etc. The uint32 value is to be interpreted as per the enum OSCL_FILE_ATTRIBUTE_TYPE defined in <a class="el" href="oscl__file__manager_8h.html" title="File management class.">oscl_file_manager.h</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>character</em>&nbsp;</td><td>path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>file</em>&nbsp;</td><td>attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="gac2830d0799bfe091c8a2be2d65c18bf9"></a><!-- doxytag: member="OsclFileManager::OsclGetFileAttributes" ref="gac2830d0799bfe091c8a2be2d65c18bf9" args="(const oscl_wchar *aFileName, uint32 &amp;aFileAttributes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF bool OsclFileManager::OsclGetFileAttributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileAttributes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclGetFileAttributes utility function provides the various attributes of file (or directory) like if it is hidden, read only etc. The uint32 value is to be interpreted as per the enum OSCL_FILE_ATTRIBUTE_TYPE defined in <a class="el" href="oscl__file__manager_8h.html" title="File management class.">oscl_file_manager.h</a> </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wide</em>&nbsp;</td><td>character path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>file</em>&nbsp;</td><td>attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4f0dbbab4893c2b6a10246700201e444"></a><!-- doxytag: member="OsclFileManager::OsclGetFileCreationTime" ref="ga4f0dbbab4893c2b6a10246700201e444" args="(const char *aFileName, uint64 &amp;aFileCreationTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF bool OsclFileManager::OsclGetFileCreationTime </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileCreationTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclGetFileCreationTime utility function provides the file (or directory) creation time </p>
<dl class="note"><dt><b>Note:</b></dt><dd>On symbian platform, this api returns last modified time. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>character</em>&nbsp;</td><td>path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>creation</em>&nbsp;</td><td>time in microseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="gae2b79e8a5579e1d7e28fb50e4ed286f7"></a><!-- doxytag: member="OsclFileManager::OsclGetFileCreationTime" ref="gae2b79e8a5579e1d7e28fb50e4ed286f7" args="(const oscl_wchar *aFileName, uint64 &amp;aFileCreationTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF bool OsclFileManager::OsclGetFileCreationTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileCreationTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclGetFileCreationTime utility function provides the file (or directory) creation time </p>
<dl class="note"><dt><b>Note:</b></dt><dd>On symbian platform, this api returns last modified time. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wide</em>&nbsp;</td><td>character path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>creation</em>&nbsp;</td><td>time in microseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="gad52a64804fc70ec5b4d7835174a42cc1"></a><!-- doxytag: member="OsclFileManager::OsclGetFileLastAccessTime" ref="gad52a64804fc70ec5b4d7835174a42cc1" args="(const char *aFileName, uint64 &amp;aFileLastAccessTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF bool OsclFileManager::OsclGetFileLastAccessTime </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileLastAccessTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclGetFileLastAccessTime utility function provides the file (or directory) last access time, which might be different from last modified time. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>On symbian platform, this api returns last modified time. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>character</em>&nbsp;</td><td>path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Last</em>&nbsp;</td><td>access time in microseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a4996a2ff4db67540d97369f1a5c738"></a><!-- doxytag: member="OsclFileManager::OsclGetFileLastAccessTime" ref="ga4a4996a2ff4db67540d97369f1a5c738" args="(const oscl_wchar *aFileName, uint64 &amp;aFileLastAccessTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF bool OsclFileManager::OsclGetFileLastAccessTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileLastAccessTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclGetFileLastAccessTime utility function provides the file (or directory) last access time, which might be different from last modified time. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>On symbian platform, this api returns last modified time. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wide</em>&nbsp;</td><td>character path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>Last</em>&nbsp;</td><td>access time in microseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="gabc4c45149243a1796a90d9602e75ac84"></a><!-- doxytag: member="OsclFileManager::OsclGetFileLastWriteTime" ref="gabc4c45149243a1796a90d9602e75ac84" args="(const char *aFileName, uint64 &amp;aFileLastWriteTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF bool OsclFileManager::OsclGetFileLastWriteTime </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileLastWriteTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclGetFileLastWriteTime utility function provides the file (or directory) last modified time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>character</em>&nbsp;</td><td>path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>last</em>&nbsp;</td><td>modified time in microseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9302cb14b69eeab0f6dfc9261b93b1fe"></a><!-- doxytag: member="OsclFileManager::OsclGetFileLastWriteTime" ref="ga9302cb14b69eeab0f6dfc9261b93b1fe" args="(const oscl_wchar *aFileName, uint64 &amp;aFileLastWriteTime)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF bool OsclFileManager::OsclGetFileLastWriteTime </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileLastWriteTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclGetFileLastWriteTime utility function provides the file (or directory) last modified time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wide</em>&nbsp;</td><td>character path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>last</em>&nbsp;</td><td>modified time in microseconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="gaac148a62141861bab680b3339ba3600f"></a><!-- doxytag: member="OsclFileManager::OsclGetFileSize" ref="gaac148a62141861bab680b3339ba3600f" args="(const char *aFileName, uint64 &amp;aFileSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF bool OsclFileManager::OsclGetFileSize </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclGetFileSize utility function provides the file size. For directory, this value is undefined. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>character</em>&nbsp;</td><td>path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>file</em>&nbsp;</td><td>size in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="gaba6522090b7b5a78998a36d8ed7b1237"></a><!-- doxytag: member="OsclFileManager::OsclGetFileSize" ref="gaba6522090b7b5a78998a36d8ed7b1237" args="(const oscl_wchar *aFileName, uint64 &amp;aFileSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static OSCL_IMPORT_REF bool OsclFileManager::OsclGetFileSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__osclbase.html#gad3f9ec9db55ebd4760c877b17eb596ec">oscl_wchar</a> *&nbsp;</td>
          <td class="paramname"> <em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__osclbase.html#gaeee93fd1c6230965ea7adc3e63fac06e">uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aFileSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>OsclGetFileSize utility function provides the file size. For directory, this value is undefined. creation time </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wide</em>&nbsp;</td><td>character path; the full path of the file or directory </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>file</em>&nbsp;</td><td>size in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if successful, otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ec8732366c9de9a6c68be217e5b7252"></a><!-- doxytag: member="OsclTCPSocket::Recv" ref="ga3ec8732366c9de9a6c68be217e5b7252" args="(uint8 *aPtr, uint32 aMaxLen, int32 aTimeoutMsec=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclTCPSocket::Recv </td>
          <td>(</td>
          <td class="paramtype">uint8 *&nbsp;</td>
          <td class="paramname"> <em>aPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aMaxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeoutMsec</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive Data. This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aPtr,:</em>&nbsp;</td><td>Buffer for received data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aMaxLen,:</em>&nbsp;</td><td>Length of buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dd></dl>

</div>
</div>
<a class="anchor" id="gad9123451a17f421108b54fd180d8d1b9"></a><!-- doxytag: member="OsclUDPSocket::RecvFrom" ref="gad9123451a17f421108b54fd180d8d1b9" args="(uint8 *aPtr, uint32 aMaxLen, OsclNetworkAddress &amp;aAddress, int32 aTimeoutMsec=&#45;1, uint32 aMultiRecvLimit=0, Oscl_Vector&lt; uint32, OsclMemAllocator &gt; *aPacketLen=NULL, Oscl_Vector&lt; OsclNetworkAddress, OsclMemAllocator &gt; *aPacketSource=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclUDPSocket::RecvFrom </td>
          <td>(</td>
          <td class="paramtype">uint8 *&nbsp;</td>
          <td class="paramname"> <em>aPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aMaxLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeoutMsec</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aMultiRecvLimit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOscl__Vector.html">Oscl_Vector</a>&lt; uint32, <a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>aPacketLen</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOscl__Vector.html">Oscl_Vector</a>&lt; <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a>, <a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>aPacketSource</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive Data. This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aPtr,:</em>&nbsp;</td><td>Buffer to receive incoming data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aMaxLen,:</em>&nbsp;</td><td>Length of buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aAddress,:</em>&nbsp;</td><td>(output) Source address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>Timeout in milliseconds, or (-1) for infinite wait.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aMultiRecvLimit</em>&nbsp;</td><td>(optional input): Configures multiple packet receive mode. As long as there are packets queued at the socket and at least aMultiRecvLimit bytes are available in the buffer, recvfrom operations will continue. A value of zero disabled multiple packet mode. The individual packet lengths can be retrieved in the aPacketLen parameter; and the individual packet source addresses can be retrieved in the aPacketSource parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aPacketLen,:</em>&nbsp;</td><td>(optional output) a vector of packet lengths, in case multiple packets were received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aPacketSource,:</em>&nbsp;</td><td>(optional output) a vector of source addresses, in case multiple packets were received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dd></dl>

</div>
</div>
<a class="anchor" id="gac0a77f20541bcd56a7bb4dcf04338e89"></a><!-- doxytag: member="OsclTCPSocket::Send" ref="gac0a77f20541bcd56a7bb4dcf04338e89" args="(const uint8 *aPtr, uint32 aLen, int32 aTimeoutMsec=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclTCPSocket::Send </td>
          <td>(</td>
          <td class="paramtype">const uint8 *&nbsp;</td>
          <td class="paramname"> <em>aPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeoutMsec</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send Data. This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aPtr,:</em>&nbsp;</td><td>Data to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aLen,:</em>&nbsp;</td><td>Length of data to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a7a37303c08165ce2e138cea27e4d6b"></a><!-- doxytag: member="OsclUDPSocket::SendTo" ref="ga4a7a37303c08165ce2e138cea27e4d6b" args="(const uint8 *aPtr, uint32 aLen, OsclNetworkAddress &amp;aAddress, int32 aTimeoutMsec=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclUDPSocket::SendTo </td>
          <td>(</td>
          <td class="paramtype">const uint8 *&nbsp;</td>
          <td class="paramname"> <em>aPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>aLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeoutMsec</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send Data. This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aPtr,:</em>&nbsp;</td><td>Data to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aLen,:</em>&nbsp;</td><td>Length of data to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aAddress,:</em>&nbsp;</td><td>Destination address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dd></dl>

</div>
</div>
<a class="anchor" id="gac00c21980321fea528fb5df2d14a0f47"></a><!-- doxytag: member="OsclUDPSocket::SetMulticastTTL" ref="gac00c21980321fea528fb5df2d14a0f47" args="(int32 aTTL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclUDPSocket::SetMulticastTTL </td>
          <td>(</td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTTL</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Controls the number of intermediate systems through which a multicast datagram can be forwarded. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTTL:Specifies</em>&nbsp;</td><td>the time-to-live value for multicast datagrams sent through this socket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns: OsclErrNone for success, or a platform-specific error code. or PVSOCK_ERR_NOT_SUPPORTED, if underlying OS doesn't support joining multicast group PVSOCK_ERR_BAD_PARAM, if config io file is not configured in accordance with underlying OS PVSOCK_ERR_NOT_IMPLEMENTED, if this API is not implemented in OSCL for the underlying OS </dd></dl>

</div>
</div>
<a class="anchor" id="ga25bf7763e044061dae61dda892bcab13"></a><!-- doxytag: member="OsclTCPSocket::SetOptionToReuseAddress" ref="ga25bf7763e044061dae61dda892bcab13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclTCPSocket::SetOptionToReuseAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the server to bind to an address which is in a TIME_WAIT state. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns: OsclErrNone for success, or a platform-specific error code. or PVSOCK_ERR_NOT_SUPPORTED, if underlying OS doesn't support joining multicast group PVSOCK_ERR_BAD_PARAM, if config io file is not configured in accordance with underlying OS PVSOCK_ERR_NOT_IMPLEMENTED, if this API is not implemented in OSCL for the underlying OS </dd></dl>

</div>
</div>
<a class="anchor" id="gac4c76afc19ae7618ea26a42c19780596"></a><!-- doxytag: member="OsclUDPSocket::SetOptionToReuseAddress" ref="gac4c76afc19ae7618ea26a42c19780596" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclUDPSocket::SetOptionToReuseAddress </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the server to bind to an address which is in a TIME_WAIT state. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns: OsclErrNone for success, or a platform-specific error code. or PVSOCK_ERR_NOT_SUPPORTED, if underlying OS doesn't support joining multicast group PVSOCK_ERR_BAD_PARAM, if config io file is not configured in accordance with underlying OS PVSOCK_ERR_NOT_IMPLEMENTED, if this API is not implemented in OSCL for the underlying OS </dd></dl>

</div>
</div>
<a class="anchor" id="ga97f4499e970575572b7c55b4cf35c22e"></a><!-- doxytag: member="OsclUDPSocket::SetRecvBufferSize" ref="ga97f4499e970575572b7c55b4cf35c22e" args="(uint32 size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclUDPSocket::SetRecvBufferSize </td>
          <td>(</td>
          <td class="paramtype">uint32&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the buffer size of the socket This is a synchronous method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size,:</em>&nbsp;</td><td>buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns OsclErrNone for success, or a platform-specific error code. May throw an OsclErrNotSupported Exception. </dd></dl>

</div>
</div>
<a class="anchor" id="gad13742c2e7d4a661dee6d53327ed4d06"></a><!-- doxytag: member="OsclTCPSocket::SetTOS" ref="gad13742c2e7d4a661dee6d53327ed4d06" args="(const OsclSocketTOS &amp;aTOS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclTCPSocket::SetTOS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOsclSocketTOS.html">OsclSocketTOS</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aTOS</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the Type of Service field of each outgoing IP datagram. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTOS,:</em>&nbsp;</td><td>Specifies the type of service requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns: OsclErrNone for success, or a platform-specific error code. or PVSOCK_ERR_NOT_SUPPORTED, if underlying OS doesn't support joining multicast group PVSOCK_ERR_BAD_PARAM, if config io file is not configured in accordance with underlying OS PVSOCK_ERR_NOT_IMPLEMENTED, if this API is not implemented in OSCL for the underlying OS </dd></dl>

</div>
</div>
<a class="anchor" id="ga7958f0f8e126f2b446d296db0e7e4c25"></a><!-- doxytag: member="OsclUDPSocket::SetTOS" ref="ga7958f0f8e126f2b446d296db0e7e4c25" args="(const OsclSocketTOS &amp;aTOS)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF int32 OsclUDPSocket::SetTOS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOsclSocketTOS.html">OsclSocketTOS</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aTOS</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the Type of Service field of each outgoing IP datagram. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aTOS,:</em>&nbsp;</td><td>Specifies the type of service requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns: OsclErrNone for success, or a platform-specific error code. or PVSOCK_ERR_NOT_SUPPORTED, if underlying OS doesn't support joining multicast group PVSOCK_ERR_BAD_PARAM, if config io file is not configured in accordance with underlying OS PVSOCK_ERR_NOT_IMPLEMENTED, if this API is not implemented in OSCL for the underlying OS </dd></dl>

</div>
</div>
<a class="anchor" id="ga5422dd9b0afc3e9070658b793bc54199"></a><!-- doxytag: member="OsclTCPSocket::Shutdown" ref="ga5422dd9b0afc3e9070658b793bc54199" args="(TPVSocketShutdown aHow, int32 aTimeoutMsec=&#45;1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclTCPSocket::Shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="oscl__socket__types_8h.html#a20988040ed0794b81547c60b5ffdde79">TPVSocketShutdown</a>&nbsp;</td>
          <td class="paramname"> <em>aHow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32&nbsp;</td>
          <td class="paramname"> <em>aTimeoutMsec</em> = <code>-1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shutdown a socket. This is an asynchronous method.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>aHow,:</em>&nbsp;</td><td>type of shutdown </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aTimeoutMsec,:</em>&nbsp;</td><td>Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7411e860564c17810ba143c3c5eebce6"></a><!-- doxytag: member="OsclTCPSocket::ThreadLogoff" ref="ga7411e860564c17810ba143c3c5eebce6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclTCPSocket::ThreadLogoff </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Thread logoff routine. This will prepare for transfer and use of the socket in another thread. All socket requests must be complete prior to calling this routine. If any requests are still active, it will return EPVSocketFailure; </p>

</div>
</div>
<a class="anchor" id="ga3fe7acbcdf4a566674373c1f60026a3f"></a><!-- doxytag: member="OsclUDPSocket::ThreadLogoff" ref="ga3fe7acbcdf4a566674373c1f60026a3f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclUDPSocket::ThreadLogoff </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Thread logoff routine. This will prepare for transfer and use of the socket in another thread. All socket requests must be complete prior to calling this routine. If any requests are still active, it will return EPVSocketFailure; </p>

</div>
</div>
<a class="anchor" id="ga1a5b3d96fe0aa38ce3187c646aef91c2"></a><!-- doxytag: member="OsclTCPSocket::ThreadLogon" ref="ga1a5b3d96fe0aa38ce3187c646aef91c2" args="(OsclSocketServ &amp;aServ, OsclSocketObserver *aObserver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclTCPSocket::ThreadLogon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclSocketServ.html">OsclSocketServ</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aServ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOsclSocketObserver.html">OsclSocketObserver</a> *&nbsp;</td>
          <td class="paramname"> <em>aObserver</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Thread logon routine. This will complete the transfer of a socket from another thread for use in the current thread. The ThreadLogoff API must be called in the original thread prior to calling ThreadLogon. </p>

</div>
</div>
<a class="anchor" id="ga77e00f9b14152cbed823c9c2dc78a04d"></a><!-- doxytag: member="OsclUDPSocket::ThreadLogon" ref="ga77e00f9b14152cbed823c9c2dc78a04d" args="(OsclSocketServ &amp;aServ, OsclSocketObserver *aObserver)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a4997c79c51d21741526e9c3890d2ddff">TPVSocketEvent</a> OsclUDPSocket::ThreadLogon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsclSocketServ.html">OsclSocketServ</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>aServ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOsclSocketObserver.html">OsclSocketObserver</a> *&nbsp;</td>
          <td class="paramname"> <em>aObserver</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Thread logon routine. This will complete the transfer of a socket from another thread for use in the current thread. The ThreadLogoff API must be called in the original thread prior to calling ThreadLogon. </p>

</div>
</div>
<a class="anchor" id="ga1927b35ee5c4bc6adfdef7f01b182897"></a><!-- doxytag: member="OsclDNS::~OsclDNS" ref="ga1927b35ee5c4bc6adfdef7f01b182897" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF OsclDNS::~OsclDNS </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor.</p>
<p>Note: the application must de-allocate the DNS object using the same allocator that was passed in the NewL object creation call. </p>

</div>
</div>
<a class="anchor" id="gae997bbfea8829462b81ddc4b974add2b"></a><!-- doxytag: member="OsclDNSObserver::~OsclDNSObserver" ref="gae997bbfea8829462b81ddc4b974add2b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual OsclDNSObserver::~OsclDNSObserver </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3fb374cb35b513b0a5924b57cb5203d0"></a><!-- doxytag: member="OsclSocketServ::~OsclSocketServ" ref="ga3fb374cb35b513b0a5924b57cb5203d0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF OsclSocketServ::~OsclSocketServ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. The server object must be deleted using the same allocator used in the NewL call. </p>

</div>
</div>
<a class="anchor" id="ga971547c10eb222fbb6c661b70bb90d49"></a><!-- doxytag: member="OsclTCPSocket::~OsclTCPSocket" ref="ga971547c10eb222fbb6c661b70bb90d49" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF OsclTCPSocket::~OsclTCPSocket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. The object must be deleted using the same allocator used in the NewL call. </p>

</div>
</div>
<a class="anchor" id="ga99c2fa6315fd3eaa9e6db973711ddfe2"></a><!-- doxytag: member="OsclUDPSocket::~OsclUDPSocket" ref="ga99c2fa6315fd3eaa9e6db973711ddfe2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OSCL_IMPORT_REF OsclUDPSocket::~OsclUDPSocket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destructor. The object must be deleted using the same allocator used in the NewL call. </p>

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="ga0b8f1a42d7f02ad6c457ce890a4f2c98"></a><!-- doxytag: member="OsclSocketServ::OsclDNS" ref="ga0b8f1a42d7f02ad6c457ce890a4f2c98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classOsclDNS.html">OsclDNS</a><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga77adc5ae59f74e0d96a75e4e8cf92c7a"></a><!-- doxytag: member="OsclDNS::OsclDNSRequestAO" ref="ga77adc5ae59f74e0d96a75e4e8cf92c7a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classOsclDNSRequestAO.html">OsclDNSRequestAO</a><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9255278927868da5d7c4d52a813bdb97"></a><!-- doxytag: member="OsclSocketServ::OsclTCPSocket" ref="ga9255278927868da5d7c4d52a813bdb97" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classOsclTCPSocket.html">OsclTCPSocket</a><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga26914fefd8d00952630a8cce7abe26ea"></a><!-- doxytag: member="OsclSocketServ::OsclUDPSocket" ref="ga26914fefd8d00952630a8cce7abe26ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classOsclUDPSocket.html">OsclUDPSocket</a><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: CORE_9.005.1.1 </small>
</small></address>
</body>
</html>
